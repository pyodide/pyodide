From 9be7fb4d3677205a5ef627816952ff0294e8505e Mon Sep 17 00:00:00 2001
From: Gyeongjae Choi <def6488@gmail.com>
Date: Wed, 16 Apr 2025 20:48:20 +0900
Subject: [PATCH 3/5] Respect runtime paths when loading shared libraries
 (#23872)

This updates `loadDynamicLibrary` to locate shared libraries from the file system
if possible.

When locating a shared library with a relative path, first attempt to find it in
the `LD_LIBRARY_PATH` directories. If it is not found there, search for it in the
runtime path directories. If it is not found, fall back to the original
`Module['locateFile']`.

Followup to #23805.

---------

Co-authored-by: Hood Chatham <roberthoodchatham@gmail.com>
---
 src/lib/libdylink.js                          | 80 +++++++++++++++
 system/lib/libc/dynlink.c                     | 35 +++++--
 tools/emscripten.py                           |  1 +
 11 files changed, 229 insertions(+), 23 deletions(-)

diff --git a/src/lib/libdylink.js b/src/lib/libdylink.js
index 8a2cda359..b1e701782 100644
--- a/src/lib/libdylink.js
+++ b/src/lib/libdylink.js
@@ -48,6 +48,17 @@ var LibraryDylink = {
     registerWasmPlugin();
     `,
   $preloadedWasm: {},
+
+  $replaceORIGIN__deps: ['$PATH'],
+  $replaceORIGIN: (parentLibName, rpath) => {
+    if (rpath.startsWith('$ORIGIN')) {
+      // TODO: what to do if we only know the relative path of the file? It will return "." here.
+      var origin = PATH.dirname(parentLibName);
+      return rpath.replace('$ORIGIN', origin);
+    }
+
+    return rpath;
+  },
 #endif // FILESYSTEM
 
   $isSymbolDefined: (symName) => {
@@ -890,6 +901,10 @@ var LibraryDylink = {
       return postInstantiation(module, instance);
     }
 
+    // We need to set rpath in flags based on the current library's rpath.
+    // We can't mutate flags or else if a depends on b and c and b depends on d,
+    // then c will be loaded with b's rpath instead of a's.
+    flags = {...flags, rpath: { parentLibPath: libName, paths: metadata.runtimePaths }}
     // now load needed libraries and the module itself.
     if (flags.loadAsync) {
       return metadata.neededDynlibs
@@ -932,6 +947,59 @@ var LibraryDylink = {
     return dso;
   },
 
+#if FILESYSTEM
+  $findLibraryFS__deps: [
+    '$replaceORIGIN',
+    '_emscripten_find_dylib',
+    '$withStackSave',
+    '$stackAlloc',
+    '$lengthBytesUTF8',
+    '$stringToUTF8OnStack',
+    '$stringToUTF8',
+    '$FS',
+    '$PATH',
+#if WASMFS
+    '_wasmfs_identify',
+    '_wasmfs_read_file',
+#endif
+  ],
+  $findLibraryFS: (libName, rpath) => {
+    // If we're preloading a dynamic library, the runtime is not ready to call
+    // __wasmfs_identify or __emscripten_find_dylib. So just quit out.
+    //
+    // This means that DT_NEEDED for the main module and transitive dependencies
+    // of it won't work with this code path. Similarly, it means that calling
+    // loadDynamicLibrary in a preRun hook can't use this code path.
+    if (!runtimeInitialized) {
+      return undefined;
+    }
+    if (PATH.isAbs(libName)) {
+#if WASMFS
+      var result = withStackSave(() => __wasmfs_identify(stringToUTF8OnStack(libName)));
+      return result === {{{ cDefs.EEXIST }}} ? libName : undefined;
+#else
+      try {
+        FS.lookupPath(libName);
+        return libName;
+      } catch (e) {
+        return undefined;
+      }
+#endif
+    }
+    var rpathResolved = (rpath?.paths || []).map((p) => replaceORIGIN(rpath?.parentLibPath, p));
+    return withStackSave(() => {
+      // In dylink.c we use: `char buf[2*NAME_MAX+2];` and NAME_MAX is 255.
+      // So we use the same size here.
+      var bufSize = 2*255 + 2;
+      var buf = stackAlloc(bufSize);
+      var rpathC = stringToUTF8OnStack(rpathResolved.join(':'));
+      var libNameC = stringToUTF8OnStack(libName);
+      var resLibNameC = __emscripten_find_dylib(buf, rpathC, libNameC, bufSize);
+      return resLibNameC ? UTF8ToString(resLibNameC) : undefined;
+    });
+  },
+#endif // FILESYSTEM
+
   // loadDynamicLibrary loads dynamic library @ lib URL / path and returns
   // handle for loaded DSO.
   //
@@ -954,6 +1022,7 @@ var LibraryDylink = {
                               '$asyncLoad',
 #if FILESYSTEM
                               '$preloadedWasm',
+                              '$findLibraryFS',
 #endif
 #if DYNCALLS || !WASM_BIGINT
                               '$registerDynCallSymbols',
@@ -1029,6 +1098,17 @@ var LibraryDylink = {
         }
       }
 
+#if FILESYSTEM
+      var f = findLibraryFS(libName, flags.rpath);
+#if DYLINK_DEBUG
+      dbg(`checking filesystem: ${libName}: ${f ? 'found' : 'not found'}`);
+#endif
+      if (f) {
+        var libData = FS.readFile(f, {encoding: 'binary'});
+        return flags.loadAsync ? Promise.resolve(libData) : libData;
+      }
+#endif
+
       var libFile = locateFile(libName);
       if (flags.loadAsync) {
         return asyncLoad(libFile);
diff --git a/system/lib/libc/dynlink.c b/system/lib/libc/dynlink.c
index f5d0c57e9..71d9e14b9 100644
--- a/system/lib/libc/dynlink.c
+++ b/system/lib/libc/dynlink.c
@@ -485,6 +485,9 @@ static void dlopen_onerror(struct dso* dso, void* user_data) {
 
 // Modified version of path_open from musl/ldso/dynlink.c
 static int path_find(const char *name, const char *s, char *buf, size_t buf_size) {
+  if (s == NULL) {
+    return -1;
+  }
   size_t l;
   int fd;
   for (;;) {
@@ -515,13 +518,27 @@ static int path_find(const char *name, const char *s, char *buf, size_t buf_size
 }
 
 // Resolve filename using LD_LIBRARY_PATH
-static const char* resolve_path(char* buf, const char* file, size_t buflen) {
-  if (!strchr(file, '/')) {
-    const char* env_path = getenv("LD_LIBRARY_PATH");
-    if (env_path && path_find(file, env_path, buf, buflen) == 0) {
-      dbg("dlopen: found in LD_LIBRARY_PATH: %s", buf);
-      return buf;
-    }
+const char* _emscripten_find_dylib(char* buf, const char* rpath, const char* file, size_t buflen) {
+  if (strchr(file, '/')) {
+    // Absolute path, leave it alone
+    return NULL;
+  }
+  const char* env_path = getenv("LD_LIBRARY_PATH");
+  if (path_find(file, env_path, buf, buflen) == 0) {
+    dbg("dlopen: found in LD_LIBRARY_PATH: %s", buf);
+    return buf;
+  }
+  if (path_find(file, rpath, buf, buflen) == 0) {
+    dbg("dlopen: found in RPATH: %s", buf);
+    return buf;
+  }
+  return NULL;
+}
+
+static const char* find_dylib(char* buf, const char* file, size_t buflen) {
+  const char* res = _emscripten_find_dylib(buf, NULL, file, buflen);
+  if (res) {
+    return res;
   }
   return file;
 }
@@ -553,7 +570,7 @@ static struct dso* _dlopen(const char* file, int flags) {
   do_write_lock();
 
   char buf[2*NAME_MAX+2];
-  file = resolve_path(buf, file, sizeof buf);
+  file = find_dylib(buf, file, sizeof buf);
 
   struct dso* p = find_existing(file);
   if (p) {
@@ -593,7 +610,7 @@ void emscripten_dlopen(const char* filename, int flags, void* user_data,
   }
   do_write_lock();
   char buf[2*NAME_MAX+2];
-  filename = resolve_path(buf, filename, sizeof buf);
+  filename = find_dylib(buf, filename, sizeof buf);
   struct dso* p = find_existing(filename);
   if (p) {
     onsuccess(user_data, p);
diff --git a/tools/emscripten.py b/tools/emscripten.py
index 6162fff0d..8ab10d40a 100644
--- a/tools/emscripten.py
+++ b/tools/emscripten.py
@@ -1144,6 +1144,7 @@ def create_pointer_conversion_wrappers(metadata):
     '_emscripten_set_offscreencanvas_size_on_thread': '_pp__',
     'fileno': '_p',
     '_emscripten_run_callback_on_thread': '_pp_pp',
+    '_emscripten_find_dylib': 'ppppp',
   }
 
   for function in settings.SIGNATURE_CONVERSIONS:
-- 
2.29.2.windows.2

