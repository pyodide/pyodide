diff --git a/emsdk/upstream/emscripten/src/library.js b/emsdk/upstream/emscripten/src/library.js
index 2990646..517fc33 100644
--- a/emsdk/upstream/emscripten/src/library.js
+++ b/emsdk/upstream/emscripten/src/library.js
@@ -3749,6 +3749,87 @@ LibraryManager.library = {
 #endif
 #if ASSERTIONS
     assert(wasmTable.get(ptr), 'missing table entry in dynCall: ' + ptr);
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS
+    if( ptr in dyncallInvokeMap)
+    {
+        // in fpcast mode, we use a separate table or else we'll attempt
+        // to call the fpcast emulated version which is not what the linker 
+        // expects for a linked dynamic call
+        ptr=dyncallInvokeMap[ptr];
+    }
 #endif
     return wasmTable.get(ptr).apply(null, args)
 #endif
diff --git a/emsdk/upstream/emscripten/src/library_dylink.js b/emsdk/upstream/emscripten/src/library_dylink.js
index 876492b..684f1e0 100644
--- a/emsdk/upstream/emscripten/src/library_dylink.js
+++ b/emsdk/upstream/emscripten/src/library_dylink.js
@@ -3,7 +3,9 @@
 //
 // ==========================================================================
 
+
 var LibraryDylink = {
+
 #if RELOCATABLE
   $asmjsMangle: function(x) {
     var unmangledSymbols = {{{ buildStringArray(WASM_SYSTEM_EXPORTS) }}};
@@ -57,6 +59,7 @@ var LibraryDylink = {
         err("new GOT entry: " + symName);
 #endif
       }
+
       return GOT[symName]
     }
   },
@@ -94,29 +97,59 @@ var LibraryDylink = {
         replace = true;
       }
 #endif
-
-      if (!GOT[symName]) {
-        GOT[symName] = new WebAssembly.Global({value: 'i32', mutable: true});
+      baseName=symName;
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+      const FPCAST_PREFIX="byn$fpcast-emu$";
+      const FPCAST_DYNCALL_PREFIX="$no-fpcast-emu$";
+      if(symName.startsWith(FPCAST_PREFIX))
+      {
+          baseName=symName.substr(FPCAST_PREFIX.length)
+      }else
+      {
+         if(FPCAST_PREFIX+symName in exports)
+         {
+             baseName=FPCAST_DYNCALL_PREFIX+symName;
+         }
       }
-      if (replace || GOT[symName].value == 0) {
+#endif
+      if (!GOT[baseName]) {
+        GOT[baseName] = new WebAssembly.Global({value: 'i32', mutable: true});
+      }
+      if (replace || GOT[baseName].value == 0) {
         if (typeof value === 'function') {
-          GOT[symName].value = addFunctionWasm(value);
+          GOT[baseName].value = addFunctionWasm(value);
 #if DYLINK_DEBUG
-          err("updateGOT FUNC: " + symName + ' : ' + GOT[symName].value);
+          err("updateGOT FUNC: " + symName + ' : ' + GOT[baseName].value);
 #endif
         } else if (typeof value === 'number') {
-          GOT[symName].value = value;
+          GOT[baseName].value = value;
         } else {
           err("unhandled export type for `" + symName + "`: " + (typeof value));
         }
 #if DYLINK_DEBUG
-        err("updateGOT: " + symName + ' : ' + GOT[symName].value);
+        err("updateGOT: " + baseName + "("+ symName + ")" + ' : ' + GOT[symName].value);
 #endif
       }
 #if DYLINK_DEBUG
-      else if (GOT[symName].value != value) {
-        err("updateGOT: EXISTING SYMBOL: " + symName + ' : ' + GOT[symName].value + " " + value);
+      else if (GOT[baseName].value != value) {
+        err("updateGOT: EXISTING SYMBOL: " + symName + ' : ' + GOT[baseName].value + " " + value);
       }
+#endif
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+        // update map for dynamic calls so they can bypass fp casts
+        if(symName.startsWith(FPCAST_PREFIX))
+        {
+            if(GOT[FPCAST_DYNCALL_PREFIX+baseName] && GOT[FPCAST_DYNCALL_PREFIX+baseName].value!=0)
+            {
+                dyncallInvokeMap[GOT[baseName].value]=GOT[FPCAST_DYNCALL_PREFIX+baseName].value;
+            }
+        }else if(baseName.startsWith(FPCAST_DYNCALL_PREFIX))
+        {
+            if(GOT[symName] && GOT[symName].value!=0)
+            {
+                dyncallInvokeMap[GOT[symName].value]=GOT[baseName].value;
+            }
+        }
 #endif
     }
 #if DYLINK_DEBUG
@@ -428,6 +461,8 @@ var LibraryDylink = {
           assert(table.get(tableBase + i) !== undefined, 'table entry was not filled in');
         }
 #endif
+        // make sure that internal wasm stuff knows about everything in the table
+        updateWasmFunctionMap(tableBase,tableSize);
         moduleExports = relocateExports(instance.exports, memoryBase);
         if (!flags.allowUndefined) {
           reportUndefinedSymbols();
@@ -754,6 +789,10 @@ var LibraryDylink = {
     // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
     symbol = UTF8ToString(symbol);
     var result;
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+      // look for fpcast-emu version as this is deffo going to be a function pointer that we return
+      symbol="byn$fpcast-emu$"+symbol
+#endif
 
     if (handle == {{{ cDefine('RTLD_DEFAULT') }}}) {
       result = resolveGlobalSymbol(symbol, true);
diff --git a/emsdk/upstream/emscripten/src/runtime_functions.js b/emsdk/upstream/emscripten/src/runtime_functions.js
index 5ae5cfc..02474b3 100644
--- a/emsdk/upstream/emscripten/src/runtime_functions.js
+++ b/emsdk/upstream/emscripten/src/runtime_functions.js
@@ -114,6 +114,18 @@ function getEmptyTableSlot() {
   return wasmTable.length - 1;
 }
 
+function updateWasmFunctionMap(start,count)
+{
+    for(var i=start;i<start+count;i++)
+    {
+       var item = wasmTable.get(i);
+       // Ignore null values.
+       if (item) {
+         functionsInTableMap.set(item, i);
+       }
+    }
+}
+
 // Add a wasm function to the table.
 function addFunctionWasm(func, sig) {
   // Check if the function is already in the table, to ensure each function
diff --git a/emsdk/upstream/emscripten/src/runtime_init_table.js b/emsdk/upstream/emscripten/src/runtime_init_table.js
index c8af59d..7084ff7 100644
--- a/emsdk/upstream/emscripten/src/runtime_init_table.js
+++ b/emsdk/upstream/emscripten/src/runtime_init_table.js
@@ -13,3 +13,17 @@ var wasmTable = new WebAssembly.Table({
 // the exports are available.
 var wasmTable;
 #endif
+#if EMULATE_FUNCTION_POINTER_CASTS==1
+    // when we call dynamic link functions through the relocation
+    // invoke xxx methods, we aren't doing a function pointer
+    // call, so we don't mess with the function prototype.
+    // however, we do need to make the function table
+    // point to the emulated bny$fpcast-emu$ function pointer calls or else you
+    // can't take function pointers in wasm code.
+    // this means we need a different table for javascript dyncall invokes
+    // as given these are pre-linked and don't use function pointer casts, they
+    // will use the non-emulated version with the normal arguments.
+    // nb. this doesn't have to be a proper wasm table because it is
+    // only ever called from javascript
+    var dyncallInvokeMap={};
+#endif
diff --git a/emsdk/upstream/emscripten/tools/__pycache__/shared.cpython-38.pyc b/emsdk/upstream/emscripten/tools/__pycache__/shared.cpython-38.pyc
index ad0e38b..872c6f0 100644
Binary files a/emsdk/upstream/emscripten/tools/__pycache__/shared.cpython-38.pyc and b/emsdk/upstream/emscripten/tools/__pycache__/shared.cpython-38.pyc differ
diff --git a/emsdk/upstream/emscripten/tools/shared.py b/emsdk/upstream/emscripten/tools/shared.py
index 74666ee..3d5657b 100644
--- a/emsdk/upstream/emscripten/tools/shared.py
+++ b/emsdk/upstream/emscripten/tools/shared.py
@@ -844,7 +844,7 @@ class JS(object):
       else:
         return 'Module["dynCall_%s"](%s)' % (sig, args)
     else:
-      return 'wasmTable.get(%s)(%s)' % (args[0], ','.join(args[1:]))
+        return 'dynCall("%s",%s,[%s])' %(sig,args[0],','.join(args[1:]))
 
   @staticmethod
   def make_invoke(sig, named=True):
