# -*- coding: utf-8 -*-
#
# Configuration file for the Sphinx documentation builder.
#
# This file does only contain a selection of the most common options. For a
# full list see the documentation:
# http://www.sphinx-doc.org/en/master/config

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
import sys
from typing import Dict, Any

for base_path in [".", ".."]:
    sys.path.insert(0, os.path.abspath(base_path))
    sys.path.insert(1, os.path.abspath(os.path.join(base_path, "src", "pyodide-py")))
    sys.path.insert(
        2, os.path.abspath(os.path.join(base_path, "packages", "micropip", "micropip"))
    )

# -- Project information -----------------------------------------------------

project = "Pyodide"
copyright = "2019, Mozilla"
author = "Mozilla"

import pyodide
import micropip  # noqa

# The full version, including alpha/beta/rc tags.
release = version = pyodide.__version__


# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.autosummary",
    "sphinxcontrib.napoleon",
    "myst_parser",
    "sphinx_js",
    "autodocsumm",
]

myst_enable_extensions = ["substitution"]

js_source_path = "../src/"

autosummary_generate = True
autodoc_default_flags = ["members", "inherited-members"]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = [".rst", ".md"]

# The master toctree document.
master_doc = "index"

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = None

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store", "README.md"]

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = None


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
# html_theme = "sphinx_rtd_theme"
html_theme = "sphinx_book_theme"
html_logo = "_static/img/pyodide-logo.png"
html_title = f"Version {version}"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.

html_theme_options: Dict[str, Any] = {}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]


html_css_files = [
    "css/pyodide.css",
]

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# The default sidebars (for documents that don't match any pattern) are
# defined by theme itself.  Builtin themes are using these templates by
# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',
# 'searchbox.html']``.
#
# html_sidebars = {}

# -- Options for HTMLHelp output ---------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = "Pyodidedoc"


# -- Options for Epub output -------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = project

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#
# epub_identifier = ''

# A unique identification for the text.
#
# epub_uid = ''

# A list of files that should not be packed into the epub file.
epub_exclude_files = ["search.html"]

from pygments.lexer import bygroups, inherit, using
from pygments.lexers import PythonLexer
from pygments.lexers.javascript import JavascriptLexer
from pygments.lexers.html import HtmlLexer
from pygments.token import *


class PyodideLexer(JavascriptLexer):
    tokens = {
        "root": [
            (
                rf"""(pyodide)(\.)(runPython|runPythonAsync)(\()(`)""",
                bygroups(
                    Token.Name,
                    Token.Operator,
                    Token.Name,
                    Token.Punctuation,
                    Token.Literal.String.Single,
                ),
                "python-code",
            ),
            inherit,
        ],
        "python-code": [
            (
                r"(.+?)(`)(\))",
                bygroups(
                    using(PythonLexer), Token.Literal.String.Single, Token.Punctuation
                ),
                "#pop",
            )
        ],
    }


class HtmlPyodideLexer(HtmlLexer):
    tokens = {
        "script-content": [
            (
                r"(<)(\s*)(/)(\s*)(script)(\s*)(>)",
                bygroups(
                    Punctuation, Text, Punctuation, Text, Name.Tag, Text, Punctuation
                ),
                "#pop",
            ),
            (r".+?(?=<\s*/\s*script\s*>)", using(PyodideLexer)),
            (r".+?\n", using(PyodideLexer), "#pop"),
            (r".+", using(PyodideLexer), "#pop"),
        ],
    }


from docutils import nodes
from docutils.parsers.rst import Directive, Parser as RstParser
from docutils.statemachine import StringList
from docutils.utils import new_document

from sphinx import addnodes
from sphinx.util import rst
from sphinx.util.docutils import switch_source_input
from sphinx.ext.autosummary import autosummary_table, extract_summary

from sphinx_js.ir import Function
from sphinx_js.parsers import path_and_formal_params, PathVisitor
from sphinx_js.renderers import AutoFunctionRenderer, AutoAttributeRenderer


def longname_to_path(name):
    """Convert the longname field produced by jsdoc to a path appropriate to use
    with _sphinxjs_analyzer.get_object. Based on:
    https://github.com/mozilla/sphinx-js/blob/3.1/sphinx_js/jsdoc.py#L181
    """
    return PathVisitor().visit(path_and_formal_params["path"].parse(name))


def on_builder_inited(app):
    """builder_inited is when sphinx-js processes the jsdoc data, we need
    to run after that becomes available.
    This groups the sphinxjs IR objects into collections based on type.
    We use this for both the autodoc summary and content.
    """

    def get_object_from_json(json):
        path = longname_to_path(json["longname"])
        kind = "function" if json["kind"] == "function" else "attribute"
        obj = app._sphinxjs_analyzer.get_object(path, kind)
        obj.kind = kind
        return obj

    app._js_docs = {"function": [], "attribute": [], "global": []}
    for (key, group) in app._sphinxjs_analyzer._doclets_by_class.items():
        if key[-1] == "globalThis":
            globals = group
        if key[-1] == "Module":
            pyodide = group
    for json in globals:
        obj = get_object_from_json(json)
        app._js_docs["global"].append(obj)
    for json in pyodide:
        obj = get_object_from_json(json)
        app._js_docs[obj.kind].append(obj)


def get_jsdoc_directives(app):
    """These directives need to close over app """

    class JsDocContent(Directive):
        """A directive that just dumps a summary table in place. There are no
        options, it only prints the one thing, we control the behavior from
        here
        """

        def get_rst(self, obj):
            if isinstance(obj, Function):
                renderer = AutoFunctionRenderer
            else:
                renderer = AutoAttributeRenderer
            return renderer(self, app, arguments=["dummy"]).rst(
                [obj.name], obj, use_short_name=False
            )

        def parse_rst(self, rst):
            doc = new_document("", settings=self.state.document.settings)
            RstParser().parse(rst, doc)
            return doc.children

        def get_rst_for_group(self, group):
            result = []
            for obj in app._js_docs[group]:
                result.append(self.get_rst(obj))
            return result

        def run(self):
            rst = []
            rst.append([".. js:module:: globalThis"])
            rst.append(self.get_rst_for_group("global"))
            rst.append([".. js:module:: pyodide"])
            rst.append(self.get_rst_for_group("attribute"))
            rst.append(self.get_rst_for_group("function"))
            joined_rst = "\n\n".join(["\n\n".join(r) for r in rst])
            return self.parse_rst(joined_rst)

    class JsDocSummary(Directive):
        """A directive that just dumps the Js API docs in place. There are no
        options, it only prints the one thing, we control the behavior from
        here
        """

        def run(self):
            result = []
            for name, entries in self.get_items():
                result.append(self.make_heading(name + ":"))
                table = self.get_table(entries)
                result.extend(table)
            return result

        def make_heading(self, text):
            heading = nodes.paragraph("")
            strong = nodes.strong("")
            strong.append(nodes.Text(text))
            heading.append(strong)
            return heading

        def get_items(self):
            result = []
            for group in ["global", "attribute", "function"]:
                pkgname = "globalThis." if group == "global" else "pyodide."
                items = []
                for obj in app._js_docs[group]:
                    sig = self.get_sig(obj)
                    display_name = obj.name
                    summary = extract_summary([obj.description], self.state.document)
                    link_name = pkgname + display_name
                    items.append((display_name, sig, summary, link_name))
                result.append([group.title() + "s", items])
            return result

        def get_sig(self, obj):
            if isinstance(obj, Function):
                return AutoFunctionRenderer(
                    self, app, arguments=["dummy"]
                )._formal_params(obj)
            else:
                return ""

        # This following method is copied almost verbatim from autosummary.
        # We have to change the value of one string:
        # qualifier = 'obj   ==>   qualifier = 'any'
        # https://github.com/sphinx-doc/sphinx/blob/3.x/sphinx/ext/autosummary/__init__.py#L392
        def get_table(self, items):
            """Generate a proper list of table nodes for autosummary:: directive.

            *items* is a list produced by :meth:`get_items`.
            """
            table_spec = addnodes.tabular_col_spec()
            table_spec["spec"] = r"\X{1}{2}\X{1}{2}"

            table = autosummary_table("")
            real_table = nodes.table("", classes=["longtable"])
            table.append(real_table)
            group = nodes.tgroup("", cols=2)
            real_table.append(group)
            group.append(nodes.colspec("", colwidth=10))
            group.append(nodes.colspec("", colwidth=90))
            body = nodes.tbody("")
            group.append(body)

            def append_row(*column_texts: str) -> None:
                row = nodes.row("")
                source, line = self.state_machine.get_source_and_line()
                for text in column_texts:
                    node = nodes.paragraph("")
                    vl = StringList()
                    vl.append(text, "%s:%d:<autosummary>" % (source, line))
                    with switch_source_input(self.state, vl):
                        self.state.nested_parse(vl, 0, node)
                        try:
                            if isinstance(node[0], nodes.paragraph):
                                node = node[0]
                        except IndexError:
                            pass
                        row.append(nodes.entry("", node))
                body.append(row)

            for name, sig, summary, real_name in items:
                qualifier = "any"  # <== Only thing changed from autosummary version
                if "nosignatures" not in self.options:
                    col1 = ":%s:`%s <%s>`\\ %s" % (
                        qualifier,
                        name,
                        real_name,
                        rst.escape(sig),
                    )
                else:
                    col1 = ":%s:`%s <%s>`" % (qualifier, name, real_name)
                col2 = summary
                append_row(col1, col2)

            return [table_spec, table]

    return JsDocSummary, JsDocContent


def setup(app):
    app.add_lexer("pyodide", PyodideLexer)
    app.add_lexer("html-pyodide", HtmlPyodideLexer)
    app.connect("builder-inited", on_builder_inited)
    JsDocSummary, JsDocContent = get_jsdoc_directives(app)
    app.add_directive("js-doc-summary", JsDocSummary)
    app.add_directive("js-doc-content", JsDocContent)
