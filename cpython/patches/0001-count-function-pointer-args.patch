From f2b8917600c2209d13603ba28d68aa191b78c20f Mon Sep 17 00:00:00 2001
From: Hood Chatham <roberthoodchatham@gmail.com>
Date: Fri, 3 Dec 2021 20:55:40 -0800
Subject: [PATCH] count function pointer args

---
 Include/fpcast.h       | 33 +++++++++++++++++++++
 Objects/call.c         |  5 +++-
 Objects/descrobject.c  | 65 +++++++++++++++++++++++++++++++++++-------
 Objects/methodobject.c | 26 +++++++++++++++--
 Objects/typeobject.c   |  6 +++-
 5 files changed, 119 insertions(+), 16 deletions(-)
 create mode 100644 Include/fpcast.h

diff --git a/Include/fpcast.h b/Include/fpcast.h
new file mode 100644
index 0000000000..8d22e6fbf4
--- /dev/null
+++ b/Include/fpcast.h
@@ -0,0 +1,33 @@
+#define FP_NARGS_OFFSET 24
+#define FP_NARGS(func) ((int)func >> FP_NARGS_OFFSET)
+#define FP_ACTUAL_PTR(func) ((PyCFunction)((int)func & (~((1<<FP_NARGS_OFFSET) - 1))))
+
+void
+argument_mismatch_error(void);
+
+int get_fp_nargs(PyCFunction func);
+
+typedef PyObject* (*zeroarg)(void) ;
+typedef PyObject* (*onearg)(PyObject*);
+typedef PyObject* (*twoarg)(PyObject*, PyObject*);
+typedef PyObject* (*threearg)(PyObject*, PyObject*, PyObject*);
+
+
+
+inline PyObject *
+call_func(PyCFunction func, int nargs, PyObject *self, PyObject *arg1, PyObject *arg2){
+    switch(nargs){
+        case 0:
+            return ((zeroarg)func)();
+        case 1:
+            return ((onearg)func)(self);
+        case 2:
+            return ((twoarg)func)(self, arg1);
+        case 3:
+            return ((threearg)func)(self, arg1, arg2);
+        default:
+            // TODO: be more helpful?
+            argument_mismatch_error();
+    }
+}
+
diff --git a/Objects/call.c b/Objects/call.c
index 87dc0dbbdb..cf5f29e0f6 100644
--- a/Objects/call.c
+++ b/Objects/call.c
@@ -143,6 +143,8 @@ PyObject_VectorcallDict(PyObject *callable, PyObject *const *args,
 }
 
 
+#include <fpcast.h>
+
 PyObject *
 _PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable,
                      PyObject *const *args, Py_ssize_t nargs,
@@ -188,7 +190,8 @@ _PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable,
     PyObject *result = NULL;
     if (_Py_EnterRecursiveCall(tstate, " while calling a Python object") == 0)
     {
-        result = call(callable, argstuple, kwdict);
+        int nargs = (Py_TYPE(callable)->tp_flags >> 4) & 0xF;
+        result = call_func((PyCFunction)call, nargs, callable, argstuple, kwdict);
         _Py_LeaveRecursiveCall(tstate);
     }
 
diff --git a/Objects/descrobject.c b/Objects/descrobject.c
index fce9cdd309..d7d1b7faae 100644
--- a/Objects/descrobject.c
+++ b/Objects/descrobject.c
@@ -174,6 +174,10 @@ member_get(PyMemberDescrObject *descr, PyObject *obj, PyObject *type)
     return PyMember_GetOne((char *)obj, descr->d_member);
 }
 
+#include <fpcast.h>
+
+
+
 static PyObject *
 getset_get(PyGetSetDescrObject *descr, PyObject *obj, PyObject *type)
 {
@@ -181,8 +185,21 @@ getset_get(PyGetSetDescrObject *descr, PyObject *obj, PyObject *type)
 
     if (descr_check((PyDescrObject *)descr, obj, &res))
         return res;
-    if (descr->d_getset->get != NULL)
-        return descr->d_getset->get(obj, descr->d_getset->closure);
+    if (descr->d_getset->get != NULL){
+        int nargs = FP_NARGS(descr->d_getset->get);
+        getter get = (getter)FP_ACTUAL_PTR(descr->d_getset->get);
+        switch(nargs){
+            case 0:
+                return ((zeroarg)get)();
+            case 1:
+                return ((onearg)get)(obj);
+            case 2:
+                return get(obj, descr->d_getset->closure);
+            default:
+                printf("Getter defined with surprising number of arguments %d. Surprise!", nargs);
+                argument_mismatch_error();
+        }
+    }
     PyErr_Format(PyExc_AttributeError,
                  "attribute '%V' of '%.100s' objects is not readable",
                  descr_name((PyDescrObject *)descr), "?",
@@ -235,9 +252,19 @@ getset_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value)
 
     if (descr_setcheck((PyDescrObject *)descr, obj, value, &res))
         return res;
-    if (descr->d_getset->set != NULL)
-        return descr->d_getset->set(obj, value,
-                                    descr->d_getset->closure);
+    if (descr->d_getset->set != NULL){
+        int nargs = FP_NARGS(descr->d_getset->set);
+        setter set = (setter)FP_ACTUAL_PTR(descr->d_getset->set);
+        switch(nargs){
+            case 2:
+                return (int)((twoarg)set)(obj, value);
+            case 3:
+                return set(obj, value, descr->d_getset->closure);
+            default:
+                printf("Setter defined with surprising number of arguments %d. Surprise!", nargs);
+                argument_mismatch_error();    
+        }
+    }
     PyErr_Format(PyExc_AttributeError,
                  "attribute '%V' of '%.100s' objects is not writable",
                  descr_name((PyDescrObject *)descr), "?",
@@ -291,6 +318,7 @@ method_enter_call(PyThreadState *tstate, PyObject *func)
     return (funcptr)((PyMethodDescrObject *)func)->d_method->ml_meth;
 }
 
+
 /* Now the actual vectorcall functions */
 static PyObject *
 method_vectorcall_VARARGS(
@@ -310,7 +338,9 @@ method_vectorcall_VARARGS(
         Py_DECREF(argstuple);
         return NULL;
     }
-    PyObject *result = meth(args[0], argstuple);
+    int meth_nargs = FP_NARGS(meth);
+    meth = FP_ACTUAL_PTR(meth);
+    PyObject *result = call_func(meth, meth_nargs, args[0], argstuple, NULL);
     Py_DECREF(argstuple);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -338,12 +368,13 @@ method_vectorcall_VARARGS_KEYWORDS(
             goto exit;
         }
     }
-    PyCFunctionWithKeywords meth = (PyCFunctionWithKeywords)
-                                   method_enter_call(tstate, func);
+    PyCFunction meth = (PyCFunction)method_enter_call(tstate, func);
     if (meth == NULL) {
         goto exit;
     }
-    result = meth(args[0], argstuple, kwdict);
+    int meth_nargs = FP_NARGS(meth);
+    meth = FP_ACTUAL_PTR(meth);
+    result = call_func(meth, meth_nargs, args[0], argstuple, kwdict);
     _Py_LeaveRecursiveCall(tstate);
 exit:
     Py_DECREF(argstuple);
@@ -364,6 +395,7 @@ method_vectorcall_FASTCALL_KEYWORDS_METHOD(
     if (meth == NULL) {
         return NULL;
     }
+    meth = (PyCMethod)FP_ACTUAL_PTR(meth);
     PyObject *result = meth(args[0],
                             ((PyMethodDescrObject *)func)->d_common.d_type,
                             args+1, nargs-1, kwnames);
@@ -385,6 +417,7 @@ method_vectorcall_FASTCALL(
     if (meth == NULL) {
         return NULL;
     }
+    meth = (_PyCFunctionFast)FP_ACTUAL_PTR(meth);
     PyObject *result = meth(args[0], args+1, nargs-1);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -404,6 +437,7 @@ method_vectorcall_FASTCALL_KEYWORDS(
     if (meth == NULL) {
         return NULL;
     }
+    meth = (_PyCFunctionFastWithKeywords)FP_ACTUAL_PTR(meth);
     PyObject *result = meth(args[0], args+1, nargs-1, kwnames);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -431,7 +465,9 @@ method_vectorcall_NOARGS(
     if (meth == NULL) {
         return NULL;
     }
-    PyObject *result = meth(args[0], NULL);
+    int meth_nargs = FP_NARGS(meth);
+    meth = FP_ACTUAL_PTR(meth);
+    PyObject *result = call_func(meth, meth_nargs, args[0], NULL, NULL);
     _Py_LeaveRecursiveCall(tstate);
     return result;
 }
@@ -459,7 +495,9 @@ method_vectorcall_O(
     if (meth == NULL) {
         return NULL;
     }
-    PyObject *result = meth(args[0], args[1]);
+    int meth_nargs = FP_NARGS(meth);
+    meth = FP_ACTUAL_PTR(meth);
+    PyObject *result = call_func(meth, meth_nargs, args[0], args[1], NULL);
     _Py_LeaveRecursiveCall(tstate);
     return result;
 }
@@ -976,6 +1014,11 @@ PyDescr_NewGetSet(PyTypeObject *type, PyGetSetDef *getset)
 
     descr = (PyGetSetDescrObject *)descr_new(&PyGetSetDescr_Type,
                                              type, getset->name);
+    int get_nargs = get_fp_nargs((PyCFunction)getset->get);
+    int set_nargs = get_fp_nargs((PyCFunction)getset->set);
+    *(int*)(getset->get) |= get_nargs << FP_NARGS_OFFSET;
+    *(int*)(getset->set) |= set_nargs << FP_NARGS_OFFSET;
+
     if (descr != NULL)
         descr->d_getset = getset;
     return (PyObject *)descr;
diff --git a/Objects/methodobject.c b/Objects/methodobject.c
index 7b430416c5..fe24e1066f 100644
--- a/Objects/methodobject.c
+++ b/Objects/methodobject.c
@@ -40,6 +40,16 @@ PyCFunction_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module)
     return PyCMethod_New(ml, self, module, NULL);
 }
 
+#include <emscripten.h>
+#include <fpcast.h>
+EM_JS(int, get_fp_nargs, (PyCFunction func), {
+    return wasmTable.get(func).length;
+})
+
+EM_JS(void, argument_mismatch_error, (void), {
+    throw new Error("Argument mismatch error!");
+});
+
 PyObject *
 PyCMethod_New(PyMethodDef *ml, PyObject *self, PyObject *module, PyTypeObject *cls)
 {
@@ -77,6 +87,8 @@ PyCMethod_New(PyMethodDef *ml, PyObject *self, PyObject *module, PyTypeObject *c
 
     PyCFunctionObject *op = NULL;
 
+    *(int*)ml->ml_meth |= get_fp_nargs(ml->ml_meth) << FP_NARGS_OFFSET;
+
     if (ml->ml_flags & METH_METHOD) {
         if (!cls) {
             PyErr_SetString(PyExc_SystemError,
@@ -423,6 +435,7 @@ cfunction_vectorcall_FASTCALL(
     if (meth == NULL) {
         return NULL;
     }
+    meth = (_PyCFunctionFast)FP_ACTUAL_PTR(meth);
     PyObject *result = meth(PyCFunction_GET_SELF(func), args, nargs);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -439,6 +452,7 @@ cfunction_vectorcall_FASTCALL_KEYWORDS(
     if (meth == NULL) {
         return NULL;
     }
+    meth = (_PyCFunctionFastWithKeywords)FP_ACTUAL_PTR(meth);
     PyObject *result = meth(PyCFunction_GET_SELF(func), args, nargs, kwnames);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -455,6 +469,7 @@ cfunction_vectorcall_FASTCALL_KEYWORDS_METHOD(
     if (meth == NULL) {
         return NULL;
     }
+    meth = (PyCMethod)FP_ACTUAL_PTR(meth);
     PyObject *result = meth(PyCFunction_GET_SELF(func), cls, args, nargs, kwnames);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -482,7 +497,9 @@ cfunction_vectorcall_NOARGS(
     if (meth == NULL) {
         return NULL;
     }
-    PyObject *result = meth(PyCFunction_GET_SELF(func), NULL);
+    int meth_nargs = FP_NARGS(meth);
+    meth = FP_ACTUAL_PTR(meth);
+    PyObject *result = call_func(meth, meth_nargs, PyCFunction_GET_SELF(func), NULL, NULL);
     _Py_LeaveRecursiveCall(tstate);
     return result;
 }
@@ -509,6 +526,7 @@ cfunction_vectorcall_O(
     if (meth == NULL) {
         return NULL;
     }
+    meth = FP_ACTUAL_PTR(meth);
     PyObject *result = meth(PyCFunction_GET_SELF(func), args[0]);
     _Py_LeaveRecursiveCall(tstate);
     return result;
@@ -535,8 +553,10 @@ cfunction_call(PyObject *func, PyObject *args, PyObject *kwargs)
     PyObject *self = PyCFunction_GET_SELF(func);
 
     PyObject *result;
+    int meth_nargs = FP_NARGS(meth);
+    meth = FP_ACTUAL_PTR(meth);
     if (flags & METH_KEYWORDS) {
-        result = (*(PyCFunctionWithKeywords)(void(*)(void))meth)(self, args, kwargs);
+        result = call_func(meth, meth_nargs, self, args, kwargs);
     }
     else {
         if (kwargs != NULL && PyDict_GET_SIZE(kwargs) != 0) {
@@ -545,7 +565,7 @@ cfunction_call(PyObject *func, PyObject *args, PyObject *kwargs)
                           ((PyCFunctionObject*)func)->m_ml->ml_name);
             return NULL;
         }
-        result = meth(self, args);
+        result = call_func(meth, meth_nargs, self, args, NULL);
     }
     return _Py_CheckFunctionResult(tstate, func, result, NULL);
 }
diff --git a/Objects/typeobject.c b/Objects/typeobject.c
index acbe3fa3b5..247c1df057 100644
--- a/Objects/typeobject.c
+++ b/Objects/typeobject.c
@@ -5364,6 +5364,8 @@ inherit_slots(PyTypeObject *type, PyTypeObject *base)
 
 static int add_operators(PyTypeObject *);
 
+#include <fpcast.h>
+
 int
 PyType_Ready(PyTypeObject *type)
 {
@@ -5391,7 +5393,9 @@ PyType_Ready(PyTypeObject *type)
         _PyObject_ASSERT((PyObject *)type, type->tp_vectorcall_offset > 0);
         _PyObject_ASSERT((PyObject *)type, type->tp_call != NULL);
     }
-
+    if(type->tp_call != NULL){
+        *(int*)type->tp_call |= get_fp_nargs((PyCFunction)type->tp_call) << FP_NARGS_OFFSET;
+    }
     type->tp_flags |= Py_TPFLAGS_READYING;
 
 #ifdef Py_TRACE_REFS
-- 
2.25.1

