diff --git a/setup.py b/setup.py
index 4e810df..d191d6d 100644
--- a/setup.py
+++ b/setup.py
@@ -68,8 +68,8 @@ Details can be found at `https://pysathq.github.io <https://pysathq.github.io>`_
 
 # solvers to install
 #==============================================================================
-to_install = ['cadical', 'glucose30', 'glucose41', 'lingeling', 'maplechrono',
-        'maplecm', 'maplesat', 'minicard', 'minisat22', 'minisatgh']
+to_install = ['cadical', 'glucose30', 'glucose41', 'maplechrono', 'maplecm',
+        'maplesat', 'minicard', 'minisat22', 'minisatgh']
 
 
 # example scripts to install as standalone executables
@@ -77,47 +77,9 @@ to_install = ['cadical', 'glucose30', 'glucose41', 'lingeling', 'maplechrono',
 scripts = ['fm', 'genhard', 'lbx', 'lsu', 'mcsls', 'models', 'musx', 'rc2']
 
 
-# we need to redefine the build command to
-# be able to download and compile solvers
-#==============================================================================
-class build(distutils.command.build.build):
-    """
-        Our custom builder class.
-    """
-
-    def run(self):
-        """
-            Download, patch and compile SAT solvers before building.
-        """
-        # download and compile solvers
-        if platform.system() != 'Windows':
-            prepare.do(to_install)
-
-        # now, do standard build
-        distutils.command.build.build.run(self)
-
-# same with build_ext
-#==============================================================================
-class build_ext(distutils.command.build_ext.build_ext):
-    """
-        Our custom builder class.
-    """
-
-    def run(self):
-        """
-            Download, patch and compile SAT solvers before building.
-        """
-        # download and compile solvers
-        if platform.system() != 'Windows':
-            prepare.do(to_install)
-
-        # now, do standard build
-        distutils.command.build_ext.build_ext.run(self)
-
-
 # compilation flags for C extensions
 #==============================================================================
-compile_flags, cpplib = ['-std=c++11', '-Wall', '-Wno-deprecated'],  ['stdc++']
+compile_flags, cpplib = ['-std=c++11', '-O3', '-Wall', '-Wno-deprecated', '-DQUIET'],  ['stdc++']
 if platform.system() == 'Darwin':
     compile_flags += ['--stdlib=libc++']
     cpplib = ['c++']
@@ -140,23 +102,19 @@ pycard_ext = Extension('pycard',
 
 pysolvers_sources = ['solvers/pysolvers.cc']
 
-if platform.system() == 'Windows':
-    prepare.do(to_install)
-    with chdir('solvers'):
-        for solver in to_install:
-            with chdir(solver):
-                for filename in glob.glob('*.c*'):
-                    pysolvers_sources += ['solvers/%s/%s' % (solver, filename)]
-                for filename in glob.glob('*/*.c*'):
-                    pysolvers_sources += ['solvers/%s/%s' % (solver, filename)]
-    libraries = []
-    library_dirs = []
-else:
-    libraries = to_install + cpplib
-    library_dirs = list(map(lambda x: os.path.join('solvers', x), to_install))
+prepare.do(to_install)
+with chdir('solvers'):
+    for solver in to_install:
+        with chdir(solver):
+            for filename in glob.glob('*.c*'):
+                pysolvers_sources += ['solvers/%s/%s' % (solver, filename)]
+            for filename in glob.glob('*/*.c*'):
+                pysolvers_sources += ['solvers/%s/%s' % (solver, filename)]
+libraries = []
+library_dirs = []
 
 pysolvers_ext = Extension('pysolvers',
-    sources=pysolvers_sources,
+    sources=sorted(pysolvers_sources),
     extra_compile_args=compile_flags + \
         list(map(lambda x: '-DWITH_{0}'.format(x.upper()), to_install)),
     include_dirs=['solvers'],
@@ -181,7 +139,6 @@ setup(name='python-sat',
     url='https://github.com/pysathq/pysat',
     ext_modules=[pycard_ext, pysolvers_ext],
     scripts=['examples/{0}.py'.format(s) for s in scripts],
-    cmdclass={'build': build, 'build_ext': build_ext},
     install_requires=['six'],
     extras_require = {
         'aiger': ['py-aiger-cnf>=2.0.0'],
diff --git a/solvers/patches/cadical.patch b/solvers/patches/cadical.patch
index cb86f73..c98d4c1 100644
--- a/solvers/patches/cadical.patch
+++ b/solvers/patches/cadical.patch
@@ -1,6 +1,6 @@
-diff -Naur build/solvers/cadical/Makefile solvers/cadical/Makefile
---- build/solvers/cadical/Makefile	1970-01-01 01:00:00.000000000 +0100
-+++ solvers/cadical/Makefile	2019-12-03 22:13:49.525556200 +0100
+diff -Naur solvers/cadical/Makefile solvers/cdc/Makefile
+--- solvers/cadical/Makefile	1970-01-01 10:00:00.000000000 +1000
++++ solvers/cdc/Makefile	2019-08-22 04:47:23.000000000 +1000
 @@ -0,0 +1,42 @@
 +### Makefile ---
 +
@@ -15,7 +15,7 @@ diff -Naur build/solvers/cadical/Makefile solvers/cadical/Makefile
 +CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
 +INCLUDES := -I.
 +LIBS     := -L.
-+SOURCES  := analyze.cpp arena.cpp assume.cpp averages.cpp backtrack.cpp backward.cpp bins.cpp block.cpp ccadical.cpp checker.cpp clause.cpp collect.cpp compact.cpp config.cpp cover.cpp decide.cpp decompose.cpp deduplicate.cpp elim.cpp ema.cpp extend.cpp external.cpp file.cpp flags.cpp format.cpp gates.cpp instantiate.cpp internal.cpp ipasir.cpp limit.cpp logging.cpp lucky.cpp message.cpp minimize.cpp occs.cpp options.cpp parse.cpp phases.cpp probe.cpp profile.cpp proof.cpp propagate.cpp queue.cpp random.cpp reduce.cpp rephase.cpp report.cpp resources.cpp restart.cpp restore.cpp score.cpp signal.cpp solution.cpp solver.cpp stats.cpp subsume.cpp terminal.cpp ternary.cpp tracer.cpp transred.cpp util.cpp var.cpp version.cpp vivify.cpp walk.cpp watch.cpp
++SOURCES  := analyze.cpp arena.cpp assume.cpp averages.cpp backtrack.cpp backward.cpp bins.cpp block.cpp ccadical.cpp checker.cpp clause.cpp collect.cpp compact.cpp config.cpp cover.cpp decide.cpp decompose.cpp deduplicate.cpp elim.cpp ema.cpp extend.cpp external.cpp file.cpp flags.cpp format.cpp gates.cpp instantiate.cpp internal.cpp ipasir.cpp limit.cpp logging.cpp lucky.cpp message.cpp minimize.cpp mobical.cpp occs.cpp options.cpp parse.cpp phases.cpp probe.cpp profile.cpp proof.cpp propagate.cpp queue.cpp random.cpp reduce.cpp rephase.cpp report.cpp resources.cpp restart.cpp restore.cpp score.cpp signal.cpp solution.cpp solver.cpp stats.cpp subsume.cpp terminal.cpp ternary.cpp tracer.cpp transred.cpp util.cpp var.cpp version.cpp vivify.cpp walk.cpp watch.cpp
 +OBJECTS  := $(SOURCES:.cpp=.o)
 +TRGT     := cadical
 +
@@ -44,347 +44,7590 @@ diff -Naur build/solvers/cadical/Makefile solvers/cadical/Makefile
 +	@-find . -name '*.a' -delete
 +
 +#-------------------------------------------------------------------------------
-diff -Naur build/solvers/cadical/build.hpp solvers/cadical/build.hpp
---- build/solvers/cadical/build.hpp	1970-01-01 01:00:00.000000000 +0100
-+++ solvers/cadical/build.hpp	2019-12-02 08:41:16.201635400 +0100
-@@ -0,0 +1,3 @@
-+#define VERSION "1.0.2"
-+#define IDENTIFIER "93cea3a86d42697a35af7ea477ef5214332f059f"
-+#define DATE "Thu Jul 11 10:16:56 WEST 2019 Darwin antares.local 18.6.0 x86_64"
-diff -Naur build/solvers/cadical/contract.hpp solvers/cadical/contract.hpp
---- build/solvers/cadical/contract.hpp	2019-07-12 22:22:02.000000000 +0200
-+++ solvers/cadical/contract.hpp	2019-12-02 08:41:16.269955000 +0100
-@@ -1,6 +1,10 @@
- #ifndef _contract_hpp_INCLUDED
- #define _contract_hpp_INCLUDED
- 
-+#ifdef _MSC_VER
-+#define __PRETTY_FUNCTION__ __FUNCTION__
-+#endif
-+
- /*------------------------------------------------------------------------*/
+diff -Naur solvers/cadical/VERSION solvers/cdc/VERSION
+--- solvers/cadical/VERSION	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/VERSION	2019-07-11 19:13:40.000000000 +1000
+@@ -1 +1 @@
+-1.0.3
++1.0.2
+diff -Naur solvers/cadical/analyze.cpp solvers/cdc/analyze.cpp
+--- solvers/cadical/analyze.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/analyze.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -39,9 +39,8 @@
+   if (!links[idx].next) return;
+   queue.dequeue (links, idx);
+   queue.enqueue (links, idx);
+-  assert (stats.bumped != INT64_MAX);
+   btab[idx] = ++stats.bumped;
+-  LOG ("moved to front variable %d and bumped to %" PRId64 "", idx, btab[idx]);
++  LOG ("moved to front variable %d and bumped to %ld", idx, btab[idx]);
+   if (!vals[idx]) update_queue_unassigned (idx);
+ }
  
- // If the user violates API contracts while calling functions declared in
-diff -Naur build/solvers/cadical/file.cpp solvers/cadical/file.cpp
---- build/solvers/cadical/file.cpp	2019-07-12 22:22:02.000000000 +0200
-+++ solvers/cadical/file.cpp	2019-12-02 08:41:16.375326400 +0100
-@@ -19,6 +19,19 @@
+@@ -78,7 +77,7 @@
+     stab[idx] *= factor;
+   scinc *= factor;
+   PHASE ("rescore", stats.rescored,
+-    "new score increment %g after %" PRId64 " conflicts",
++    "new score increment %g after %ld conflicts",
+     scinc, stats.conflicts);
+ }
  
- /*------------------------------------------------------------------------*/
+@@ -131,17 +130,15 @@
+ struct analyze_bumped_rank {
+   Internal * internal;
+   analyze_bumped_rank (Internal * i) : internal (i) { }
+-  uint64_t operator () (const int & a) const {
+-    return internal->bumped (a);
+-  }
++  size_t operator () (const int & a) const { return internal->bumped (a); }
+ };
  
-+#ifdef _MSC_VER
-+#ifndef S_ISDIR
-+#define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
-+#endif
-+
-+#ifndef S_ISREG
-+#define S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)
-+#endif
-+
-+#define popen _popen
-+#define pclose _pclose
-+#endif
-+
- // Private constructor.
+ struct analyze_bumped_smaller {
+   Internal * internal;
+   analyze_bumped_smaller (Internal * i) : internal (i) { }
+   bool operator () (const int & a, const int & b) const {
+-    const auto s = analyze_bumped_rank (internal) (a);
+-    const auto t = analyze_bumped_rank (internal) (b);
++    const size_t s = analyze_bumped_rank (internal) (a);
++    const size_t t = analyze_bumped_rank (internal) (b);
+     return s < t;
+   }
+ };
+@@ -163,8 +160,7 @@
+     // queue and seems to work best.  We also experimented with focusing on
+     // variables of the last decision level, but results were mixed.
+ 
+-    MSORT (opts.radixsortlim,
+-      analyzed.begin (), analyzed.end (),
++    MSORT (analyzed.begin (), analyzed.end (),
+       analyze_bumped_rank (this), analyze_bumped_smaller (this));
+   }
+ 
+@@ -298,9 +294,9 @@
+ struct analyze_trail_negative_rank {
+   Internal * internal;
+   analyze_trail_negative_rank (Internal * s) : internal (s) { }
+-  uint64_t operator () (int a) {
++  size_t operator () (int a) {
+     Var & v = internal->var (a);
+-    uint64_t res = v.level;
++    size_t res = v.level;
+     res <<= 32;
+     res |= v.trail;
+     return ~res;
+@@ -348,8 +344,7 @@
+     // the opposite order) with the hope to hit the recursion limit less
+     // frequently.  Thus sorting effort is doubled here.
+     //
+-    MSORT (opts.radixsortlim,
+-      clause.begin (), clause.end (),
++    MSORT (clause.begin (), clause.end (),
+       analyze_trail_negative_rank (this), analyze_trail_larger (this));
  
- File::File (Internal *i, bool w, int c, FILE * f, const char * n)
-diff -Naur build/solvers/cadical/file.hpp solvers/cadical/file.hpp
---- build/solvers/cadical/file.hpp	2019-07-12 22:22:02.000000000 +0200
-+++ solvers/cadical/file.hpp	2019-12-02 08:41:16.385087600 +0100
-@@ -9,6 +9,10 @@
- #include <climits>
+     jump = var (clause[1]).level;
+@@ -484,7 +479,7 @@
+         best_idx = idx;
+         best_pos = i;
+       }
+-      LOG ("best variable bumped %" PRId64 "", bumped (best_idx));
++      LOG ("best variable bumped %ld", bumped (best_idx));
+     }
+     assert (best_idx);
+     LOG ("best variable %d at trail position %d", best_idx, best_pos);
+@@ -521,11 +516,11 @@
+   assert (opts.eagersubsume);
+   LOG (c, "trying eager subsumption with");
+   mark (c);
+-  int64_t lim = stats.eagertried + opts.eagersubsumelim;
++  long lim = stats.eagertried + opts.eagersubsumelim;
+   const auto begin = clauses.begin ();
+   auto it = clauses.end ();
+ #ifdef LOGGING
+-  int64_t before = stats.eagersub;
++  long before = stats.eagersub;
+ #endif
+   while (it != begin && stats.eagertried++ <= lim) {
+     Clause * d =  *--it;
+@@ -545,7 +540,7 @@
+   }
+   unmark (c);
+ #ifdef LOGGING
+-  uint64_t subsumed = stats.eagersub - before;
++  long subsumed = stats.eagersub - before;
+   if (subsumed) LOG ("eagerly subsumed %d clauses", subsumed);
  #endif
+ }
+@@ -672,8 +667,8 @@
+   // Update glue statistics.
+   //
+   const int glue = (int) levels.size ();
+-  LOG (clause, "1st UIP size %zd and glue %d clause",
+-    clause.size (), glue);
++  LOG (clause, "1st UIP size %ld and glue %d clause",
++    (long) clause.size (), glue);
+   UPDATE_AVERAGE (averages.current.glue.fast, glue);
+   UPDATE_AVERAGE (averages.current.glue.slow, glue);
+ 
+diff -Naur solvers/cadical/arena.cpp solvers/cdc/arena.cpp
+--- solvers/cadical/arena.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/arena.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -13,7 +13,7 @@
+ }
+ 
+ void Arena::prepare (size_t bytes) {
+-  LOG ("preparing 'to' space of arena with %zd bytes", bytes);
++  LOG ("preparing 'to' space of arena with %ld bytes", (long) bytes);
+   assert (!to.start);
+   to.top = to.start = new char[bytes];
+   to.end = to.start + bytes;
+@@ -21,8 +21,8 @@
+ 
+ void Arena::swap () {
+   delete [] from.start;
+-  LOG ("delete 'from' space of arena with %zd bytes",
+-    (size_t) (from.end - from.start));
++  LOG ("delete 'from' space of arena with %ld bytes",
++    (long) (from.end - from.start));
+   from = to;
+   to.start = to.top = to.end = 0;
+ }
+diff -Naur solvers/cadical/averages.hpp solvers/cdc/averages.hpp
+--- solvers/cadical/averages.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/averages.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -7,7 +7,7 @@
+ 
+ struct Averages {
+ 
+-  int64_t swapped;
++  long swapped;
+ 
+   struct {
+ 
+diff -Naur solvers/cadical/block.cpp solvers/cdc/block.cpp
+--- solvers/cadical/block.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/block.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -206,7 +206,7 @@
+       if (marked_skip (lit)) { skipped++; continue; }
+       if (!marked_block (lit)) continue;
+       unmark_block (lit);
+-      LOG ("scheduling %d with %" PRId64 " positive and %" PRId64 " negative occurrences",
++      LOG ("scheduling %d with %ld positive and %ld negative occurrences",
+         lit, noccs (lit), noccs (-lit));
+       blocker.schedule.push_back (vlit (lit));
+     }
+@@ -242,7 +242,7 @@
+   stats.blockpurelits++;
+   LOG ("found pure literal %d", lit);
+ 
+-  int64_t pured = 0;
++  long pured = 0;
+ 
+   for (const auto & c : pos) {
+     if (c->garbage) continue;
+@@ -260,7 +260,7 @@
+ 
+   mark_pure (lit);
+   stats.blockpured++;
+-  LOG ("blocking %" PRId64 " clauses on pure literal %d", pured, lit);
++  LOG ("blocking %ld clauses on pure literal %d", pured, lit);
+ }
  
-+#ifdef _MSC_VER
-+#define NUNLOCKED
-+#endif
-+
  /*------------------------------------------------------------------------*/
- #ifndef NUNLOCKED
- #define cadical_putc_unlocked putc_unlocked
-diff -Naur build/solvers/cadical/make-build-header.sh solvers/cadical/make-build-header.sh
---- build/solvers/cadical/make-build-header.sh	2019-07-12 22:22:02.000000000 +0200
-+++ solvers/cadical/make-build-header.sh	2019-12-02 08:41:16.480734900 +0100
-@@ -19,17 +19,9 @@
+@@ -305,7 +305,7 @@
+   LOG (d, "common antecedent", lit);
+   mark (d);
+ 
+-  int64_t blocked = 0, skipped = 0;
++  long blocked = 0, skipped = 0;
+ 
+   Occs & pos = occs (lit);
+ 
+@@ -376,7 +376,7 @@
+   else pos.resize (j - pos.begin ());
+ 
+   stats.blocked += blocked;
+-  LOG ("blocked %" PRId64 " clauses on %d (skipped %" PRId64 ")", blocked, lit, skipped);
++  LOG ("blocked %ld clauses on %d (skipped %ld)", blocked, lit, skipped);
+ 
+   unmark (d);
  }
+@@ -547,10 +547,10 @@
+     return;
+   }
  
- #--------------------------------------------------------------------------#
--
--[ ! -f VERSION -a ! -f ../VERSION ] && \
--die "needs to be called from build sub-directory"
--
--[ -f makefile ] || \
--warning "could not find 'makefile'"
--
--#--------------------------------------------------------------------------#
- # The version.
- #
--VERSION="`cat ../VERSION`"
-+VERSION="`cat VERSION`"
- if [ x"$VERSION" = x ]
- then
-   warning "could not determine 'VERSION'"
-@@ -40,7 +32,7 @@
- #--------------------------------------------------------------------------#
- # The unique GIT hash.
- #
--IDENTIFIER="`../scripts/get-git-id.sh`"
-+IDENTIFIER="`./get-git-id.sh`"
- if [ x"$IDENTIFIER" = x ]
- then
-   warning "could not determine 'IDENTIFIER' (git id)"
-@@ -51,9 +43,15 @@
- #--------------------------------------------------------------------------#
- # C++ compiler 'CXX' used in 'makefile'.
- #
--COMPILER="`sed -e '/^CXX=/!d' -e 's,^CXX=,,' makefile 2>/dev/null`"
--case x"$COMPILER" in 
--  xg++* | xclang++*)
-+if [[ "$OSTYPE" == "darwin"* ]]; then
-+  SEDMAC=-E
-+else
-+  SEDMAC=
-+fi
-+
-+  COMPILER="`sed $SEDMAC -e '/^CXX[ \t]+:=/!d' -e 's,^CXX[ \t]+:= ,,' Makefile 2>/dev/null`"
-+case x"$COMPILER" in
-+  xc++* | xg++* | xclang++*)
-     COMPILER="`$COMPILER --version 2>/dev/null|head -1`";;
-   *) COMPILER="";;
- esac
-@@ -67,7 +65,7 @@
- #--------------------------------------------------------------------------#
- # C++ compiler flags 'CXXFLAGS' used in 'makefile'.
- #
--FLAGS="`sed -e '/^CXXFLAGS=/!d' -e 's,^CXXFLAGS=,,' makefile 2>/dev/null`"
-+FLAGS="`sed $SEDMAC -e '/^CXXFLAGS[ \t]+:=/!d' -e 's,^CXXFLAGS[ \t]+:= ,,' Makefile 2>/dev/null`"
- if [ x"$FLAGS" = x ]
- then
-   warning "could not determine 'FLAGS' ('CXXFLAGS')"
-diff -Naur build/solvers/cadical/resources.cpp solvers/cadical/resources.cpp
---- build/solvers/cadical/resources.cpp	2019-07-12 22:22:02.000000000 +0200
-+++ solvers/cadical/resources.cpp	2019-12-02 08:41:16.629094100 +0100
-@@ -6,8 +6,15 @@
- // TODO: port these functions to different OS.
- 
- extern "C" {
-+#ifndef _MSC_VER
- #include <sys/time.h>
- #include <sys/resource.h>
-+#else
-+#include <time.h>
-+#include <windows.h>
-+#include <psapi.h>
-+#endif
-+
- #include <sys/types.h>
- #include <unistd.h>
- #include <string.h>
-@@ -15,6 +22,39 @@
+-  LOG ("trying to block %zd clauses out of %" PRId64 " with literal %d",
++  LOG ("trying to block %zd clauses out of %ld with literal %d",
+     candidates, noccs (lit), lit);
+ 
+-  int64_t blocked = 0;
++  long blocked = 0;
+ 
+   // Go over all remaining candidates and try to block them on 'lit'.
+   //
+@@ -565,7 +565,7 @@
+     mark_garbage (c);
+   }
+ 
+-  LOG ("blocked %" PRId64 " clauses on %d out of %zd candidates in %zd occurrences",
++  LOG ("blocked %ld clauses on %d out of %zd candidates in %zd occurrences",
+     blocked, lit, blocker.candidates.size (), occs (lit).size ());
+ 
+   blocker.candidates.clear ();
+@@ -587,11 +587,11 @@
+ 
+   for (const auto & other : *c) {
+ 
+-    int64_t & n = noccs (other);
++    long & n = noccs (other);
+     assert (n > 0);
+     n--;
+ 
+-    LOG ("updating %d with %" PRId64 " positive and %" PRId64 " negative occurrences",
++    LOG ("updating %d with %ld positive and %ld negative occurrences",
+       other, noccs (other), noccs (-other));
+ 
+     if (blocker.schedule.contains (vlit (-other)))
+@@ -638,7 +638,7 @@
+   if (noccs (-lit) > opts.blockocclim) return;
+ 
+   LOG ("blocking literal candidate %d "
+-    "with %" PRId64 " positive and %" PRId64 " negative occurrences",
++    "with %ld positive and %ld negative occurrences",
+     lit, noccs (lit), noccs (-lit));
+ 
+   stats.blockcands++;
+@@ -691,7 +691,7 @@
+ 
+   stats.blockings++;
+ 
+-  LOG ("block-%" PRId64 "", stats.blockings);
++  LOG ("block-%ld", stats.blockings);
+ 
+   assert (!level);
+   assert (!watching ());
+@@ -705,10 +705,10 @@
+   Blocker blocker (this);
+   block_schedule (blocker);
+ 
+-  int64_t blocked = stats.blocked;
+-  int64_t resolutions = stats.blockres;
+-  int64_t purelits = stats.blockpurelits;
+-  int64_t pured = stats.blockpured;
++  long blocked = stats.blocked;
++  long resolutions = stats.blockres;
++  long purelits = stats.blockpurelits;
++  long pured = stats.blockpured;
+ 
+   while (!terminating () &&
+          !blocker.schedule.empty ()) {
+@@ -726,7 +726,7 @@
+   blocked = stats.blocked - blocked;
+ 
+   PHASE ("block", stats.blockings,
+-    "blocked %" PRId64 " clauses in %" PRId64 " resolutions",
++    "blocked %ld clauses in %ld resolutions",
+     blocked, resolutions);
+ 
+   pured = stats.blockpured - pured;
+@@ -737,7 +737,7 @@
+ 
+   if (purelits)
+     PHASE ("block", stats.blockings,
+-      "found %" PRId64 " pure literals in %" PRId64 " clauses",
++      "found %ld pure literals in %ld clauses",
+       purelits, pured);
+   else
+     PHASE ("block", stats.blockings,
+diff -Naur solvers/cadical/build.hpp solvers/cdc/build.hpp
+--- solvers/cadical/build.hpp	1970-01-01 10:00:00.000000000 +1000
++++ solvers/cdc/build.hpp	2019-07-11 19:16:56.000000000 +1000
+@@ -0,0 +1,3 @@
++#define VERSION "1.0.2"
++#define IDENTIFIER "93cea3a86d42697a35af7ea477ef5214332f059f"
++#define DATE "Thu Jul 11 10:16:56 WEST 2019 Darwin antares.local 18.6.0 x86_64"
+diff -Naur solvers/cadical/cadical.hpp solvers/cdc/cadical.hpp
+--- solvers/cadical/cadical.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/cadical.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -2,7 +2,6 @@
+ #define _cadical_hpp_INCLUDED
+ 
+ #include <cstdio>
+-#include <cstdint>
+ #include <vector>
  
  namespace CaDiCaL {
+@@ -432,8 +431,8 @@
+   //   ensure (VALID)
+   //
+   int active () const;          // Number of active variables.
+-  int64_t redundant () const;   // Number of active redundant clauses.
+-  int64_t irredundant () const; // Number of active irredundant clauses.
++  long redundant () const;      // Number of active redundant clauses.
++  long irredundant () const;    // Number of active irredundant clauses.
  
-+#ifdef _MSC_VER
-+#define WIN32_LEAN_AND_MEAN
-+
-+#include <stdint.h> // portable: uint64_t   MSVC: __int64
-+
-+// MSVC defines this in winsock2.h!?
-+typedef struct timeval {
-+    long tv_sec;
-+    long tv_usec;
-+} timeval;
-+
-+int gettimeofday(struct timeval * tp, struct timezone * tzp)
-+{
-+    // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
-+    // This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)
-+    // until 00:00:00 January 1, 1970
-+    static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
-+
-+    SYSTEMTIME  system_time;
-+    FILETIME    file_time;
-+    uint64_t    time;
-+
-+    GetSystemTime( &system_time );
-+    SystemTimeToFileTime( &system_time, &file_time );
-+    time =  ((uint64_t)file_time.dwLowDateTime )      ;
-+    time += ((uint64_t)file_time.dwHighDateTime) << 32;
-+
-+    tp->tv_sec  = (long) ((time - EPOCH) / 10000000L);
-+    tp->tv_usec = (long) (system_time.wMilliseconds * 1000);
-+    return 0;
-+}
-+#endif
-+
- double absolute_real_time () {
-   struct timeval tv;
-   if (gettimeofday (&tv, 0)) return 0;
-@@ -32,12 +72,28 @@
- // etc.  For different variants of Unix not all fields are meaningful.
- 
- double absolute_process_time () {
-+#ifndef _MSC_VER
-   struct rusage u;
-   double res;
-   if (getrusage (RUSAGE_SELF, &u)) return 0;
-   res = u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec;  // user time
-   res += u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec; // + system time
-   return res;
-+#else
-+HANDLE hProcess;
-+FILETIME creationTime;
-+FILETIME exitTime;
-+FILETIME kernelTime;
-+FILETIME userTime;
-+ULARGE_INTEGER wrkTime;
-+hProcess=GetCurrentProcess();
-+if (GetProcessTimes(hProcess,  &creationTime, &exitTime, &kernelTime, &userTime)) {
-+    wrkTime.LowPart = userTime.dwLowDateTime;
-+    wrkTime.HighPart = userTime.dwHighDateTime;
-+    return wrkTime.QuadPart / 10000000.0;
-+    }
-+return 0;
-+#endif
+   //------------------------------------------------------------------------
+   // Same as 'solve' with 'limits ("conflicts", 0)' and
+diff -Naur solvers/cadical/ccadical.cpp solvers/cdc/ccadical.cpp
+--- solvers/cadical/ccadical.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/ccadical.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -32,12 +32,12 @@
  }
  
- double Internal::process_time () {
-@@ -49,9 +105,20 @@
- // This seems to work on Linux (man page says since Linux 2.6.32).
+ void ccadical_set_option (CCaDiCaL * wrapper,
+-                          const char * name, int val) {
++                          const char * name, double val) {
+   ((Wrapper*) wrapper)->solver->set (name, val);
+ }
  
- size_t maximum_resident_set_size () {
-+#ifndef _MSC_VER
-   struct rusage u;
-   if (getrusage (RUSAGE_SELF, &u)) return 0;
-   return ((size_t) u.ru_maxrss) << 10;
-+#else
-+HANDLE hProcess;
-+PROCESS_MEMORY_COUNTERS processMemoryCounters;
-+
-+hProcess=GetCurrentProcess();
-+if (GetProcessMemoryInfo(hProcess,  &processMemoryCounters, sizeof(processMemoryCounters))) {
-+    return processMemoryCounters.PeakWorkingSetSize;
-+    }
-+return 0;
-+#endif
+ void ccadical_limit (CCaDiCaL * wrapper,
+-                     const char * name, int val) {
++                     const char * name, long val) {
+   ((Wrapper*) wrapper)->solver->limit (name, val);
  }
  
- // Unfortunately 'getrusage' on Linux does not support current resident set
-@@ -62,6 +129,7 @@
- // '_SC_PAGESIZE' are available).
+@@ -77,11 +77,11 @@
+   ((Wrapper*) wrapper)->solver->terminate ();
+ }
  
- size_t current_resident_set_size () {
-+#ifndef _MSC_VER
-   char path[40];
-   sprintf (path, "/proc/%" PRId64 "/statm", (int64_t) getpid ());
-   FILE * file = fopen (path, "r");
-@@ -70,6 +138,16 @@
-   int scanned = fscanf (file, "%" PRId64 " %" PRId64 "", &dummy, &rss);
-   fclose (file);
-   return scanned == 2 ? rss * sysconf (_SC_PAGESIZE) : 0;
-+#else
-+HANDLE hProcess;
-+PROCESS_MEMORY_COUNTERS processMemoryCounters;
-+
-+hProcess=GetCurrentProcess();
-+if (GetProcessMemoryInfo(hProcess,  &processMemoryCounters, sizeof(processMemoryCounters))) {
-+    return processMemoryCounters.WorkingSetSize;
-+    }
-+return 0;
-+#endif
+-int64_t ccadical_active (CCaDiCaL * wrapper) {
++long ccadical_active (CCaDiCaL * wrapper) {
+   return ((Wrapper*) wrapper)->solver->active ();
  }
  
+-int64_t ccadical_irredundant (CCaDiCaL * wrapper) {
++long ccadical_irredundant (CCaDiCaL * wrapper) {
+   return ((Wrapper*) wrapper)->solver->irredundant ();
  }
-diff -Naur build/solvers/cadical/signal.cpp solvers/cadical/signal.cpp
---- build/solvers/cadical/signal.cpp	2019-07-12 22:22:02.000000000 +0200
-+++ solvers/cadical/signal.cpp	2019-12-02 08:41:16.664222200 +0100
-@@ -25,8 +25,12 @@
- static int alarm_time = -1;
- static Handler * signal_handler;
  
--void Handler::catch_alarm () { catch_signal (SIGALRM); }
+diff -Naur solvers/cadical/ccadical.h solvers/cdc/ccadical.h
+--- solvers/cadical/ccadical.h	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/ccadical.h	2019-07-11 20:31:18.000000000 +1000
+@@ -7,8 +7,6 @@
+ #endif
+ /*------------------------------------------------------------------------*/
+ 
+-#include <stdint.h>
 -
-+void Handler::catch_alarm () {
-+#ifndef _MSC_VER
-+catch_signal (SIGALRM);
-+#endif
-+}
-+#ifndef _MSC_VER
- #define SIGNALS \
- SIGNAL(SIGABRT) \
- SIGNAL(SIGBUS) \
-@@ -34,6 +38,14 @@
- SIGNAL(SIGSEGV) \
- SIGNAL(SIGTERM) \
+ // C wrapper for CaDiCaL's C++ API following IPASIR.
  
-+#else
-+#define SIGNALS \
-+SIGNAL(SIGABRT) \
-+SIGNAL(SIGINT) \
-+SIGNAL(SIGSEGV) \
-+SIGNAL(SIGTERM) \
-+
-+#endif
- #define SIGNAL(SIG) \
- static void (*SIG ## _handler)(int);
- SIGNALS
-@@ -42,7 +54,9 @@
- 
- void Signal::reset_alarm () {
-   if (!alarm_set) return;
-+#ifndef _MSC_VER
-   (void) signal (SIGALRM, SIGALRM_handler);
-+#endif
-   SIGALRM_handler = 0;
-   caught_alarm = false;
-   alarm_set = false;
-@@ -65,7 +79,9 @@
-   if (sig == SIG) return # SIG;
-   SIGNALS
- #undef SIGNAL
-+#ifndef _MSC_VER
-   if (sig == SIGALRM) return "SIGALRM";
-+#endif
-   return "UNKNOWN";
- }
+ typedef struct CCaDiCaL CCaDiCaL;
+@@ -30,12 +28,12 @@
  
-@@ -76,6 +92,7 @@
- // exclusive access to.  All these solutions are painful and not elegant.
+ // Non-IPASIR conformant 'C' functions.
  
- static void catch_signal (int sig) {
-+#ifndef _MSC_VER
-   if (sig == SIGALRM && absolute_real_time () >= alarm_time) {
-     if (!caught_alarm) {
-       caught_alarm = true;
-@@ -83,13 +100,16 @@
-     }
-     Signal::reset_alarm ();
+-void ccadical_set_option (CCaDiCaL *, const char * name, int val);
+-void ccadical_limit (CCaDiCaL *, const char * name, int limit);
++void ccadical_set_option (CCaDiCaL *, const char * name, double val);
++void ccadical_limit (CCaDiCaL *, const char * name, long limit);
+ int ccadical_get_option (CCaDiCaL *, const char * name);
+ void ccadical_print_statistics (CCaDiCaL *);
+-int64_t ccadical_active (CCaDiCaL *);
+-int64_t ccadical_irredundant (CCaDiCaL *);
++long ccadical_active (CCaDiCaL *);
++long ccadical_irredundant (CCaDiCaL *);
+ int ccadical_fixed (CCaDiCaL *, int lit);
+ void ccadical_terminate (CCaDiCaL *);
+ void ccadical_freeze (CCaDiCaL *, int lit);
+diff -Naur solvers/cadical/checker.cpp solvers/cdc/checker.cpp
+--- solvers/cadical/checker.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/checker.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -203,13 +203,13 @@
+ // signed integer literal, comes with the price of slightly more complex
+ // code in deleting and enlarging the checker data structures.
+ 
+-void Checker::enlarge_vars (int64_t idx) {
++void Checker::enlarge_vars (long idx) {
+ 
+   assert (0 < idx), assert (idx <= INT_MAX);
+ 
+-  int64_t new_size_vars = size_vars ? 2*size_vars : 2;
++  long new_size_vars = size_vars ? 2*size_vars : 2;
+   while (idx >= new_size_vars) new_size_vars *= 2;
+-  LOG ("CHECKER enlarging variables of checker from %" PRId64 " to %" PRId64 "",
++  LOG ("CHECKER enlarging variables of checker from %ld to %ld",
+     size_vars, new_size_vars);
+ 
+   signed char * new_vals;
+diff -Naur solvers/cadical/checker.hpp solvers/cdc/checker.hpp
+--- solvers/cadical/checker.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/checker.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -54,7 +54,7 @@
+ 
+   // Capacity of variable values.
+   //
+-  int64_t size_vars;
++  long size_vars;
+ 
+   // For the assignment we want to have an as fast access as possible and
+   // thus we use an array which can also be indexed by negative literals and
+@@ -87,7 +87,7 @@
+ 
+   unsigned next_to_propagate;   // next to propagate on trail
+ 
+-  void enlarge_vars (int64_t idx);
++  void enlarge_vars (long idx);
+   void import_literal (int lit);
+   void import_clause (const vector<int> &);
+   bool tautological ();
+@@ -125,23 +125,23 @@
+ 
+   struct {
+ 
+-    int64_t added;                 // number of added clauses
+-    int64_t original;              // number of added original clauses
+-    int64_t derived;               // number of added derived clauses
++    long added;                 // number of added clauses
++    long original;              // number of added original clauses
++    long derived;               // number of added derived clauses
+ 
+-    int64_t deleted;               // number of deleted clauses
++    long deleted;               // number of deleted clauses
+ 
+-    int64_t assumptions;           // number of assumed literals
+-    int64_t propagations;          // number of propagated literals
++    long assumptions;           // number of assumed literals
++    long propagations;          // number of propagated literals
+ 
+-    int64_t insertions;            // number of clauses added to hash table
+-    int64_t collisions;            // number of hash collisions in 'find'
+-    int64_t searches;              // number of searched clauses in 'find'
++    long insertions;            // number of clauses added to hash table
++    long collisions;            // number of hash collisions in 'find'
++    long searches;              // number of searched clauses in 'find'
+ 
+-    int64_t checks;                // number of implication checks
++    long checks;                // number of implication checks
+ 
+-    int64_t collections;           // garbage collections
+-    int64_t units;
++    long collections;           // garbage collections
++    long units;
+ 
+   } stats;
+ 
+diff -Naur solvers/cadical/clause.cpp solvers/cdc/clause.cpp
+--- solvers/cadical/clause.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/clause.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -172,7 +172,7 @@
+     size_t new_bytes = c->bytes ();
+     if (old_bytes > new_bytes) {
+       res = old_bytes - new_bytes;
+-      assert (stats.irrbytes >= (int64_t) res);
++      assert (stats.irrbytes >= (long) res);
+       stats.irrbytes -= res;
+     } else {
+ 
+@@ -209,7 +209,7 @@
+   size_t bytes = c->bytes ();
+   stats.collected += bytes;
+   if (c->garbage) {
+-    assert (stats.garbage >= (int64_t) bytes);
++    assert (stats.garbage >= (long) bytes);
+     stats.garbage -= bytes;
+ 
+     // See the discussion in 'propagate' on avoiding to eagerly trace binary
+@@ -261,7 +261,7 @@
    } else {
-+#endif
-     if (!caught_signal) {
-       caught_signal = true;
-       if (signal_handler) signal_handler->catch_signal (sig);
-     }
-     Signal::reset ();
-     ::raise (sig);
-+#ifndef _MSC_VER
+     assert (stats.current.irredundant > 0);
+     stats.current.irredundant--;
+-    assert (stats.irrbytes >= (int64_t) bytes);
++    assert (stats.irrbytes >= (long) bytes);
+     stats.irrbytes -= bytes;
+     mark_removed (c);
    }
-+#endif
+diff -Naur solvers/cadical/clause.hpp solvers/cdc/clause.hpp
+--- solvers/cadical/clause.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/clause.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -24,7 +24,7 @@
+ 
+ struct Clause {
+ #ifdef LOGGING
+-  int64_t id;         // Only useful for debugging.
++  long id;            // Only useful for debugging.
+ #endif
+   bool covered:1;     // Already considered for covered clause elimination.
+   bool enqueued:1;    // Enqueued on backward queue.
+diff -Naur solvers/cadical/collect.cpp solvers/cdc/collect.cpp
+--- solvers/cadical/collect.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/collect.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -153,7 +153,7 @@
+   flush_all_occs_and_watches ();
+ 
+   LOG ("deleting garbage clauses");
+-  int64_t collected_bytes = 0, collected_clauses = 0;
++  long collected_bytes = 0, collected_clauses = 0;
+   const auto end = clauses.end ();
+   auto j = clauses.begin (), i = j;
+   while (i != end) {
+@@ -168,7 +168,7 @@
+   shrink_vector (clauses);
+ 
+   PHASE ("collect", stats.collections,
+-    "collected %" PRId64 " bytes of %" PRId64 " garbage clauses",
++    "collected %ld bytes of %ld garbage clauses",
+     collected_bytes, collected_clauses);
  }
  
- void Signal::set (Handler * h) {
-@@ -104,10 +124,14 @@
-   assert (seconds >= 0);
-   assert (!alarm_set);
-   assert (alarm_time < 0);
-+#ifndef _MSC_VER
-   SIGALRM_handler = signal (SIGALRM, catch_signal);
-+#endif
-   alarm_set = true;
-   alarm_time = absolute_real_time () + seconds;
-+#ifndef _MSC_VER
-   ::alarm (seconds);
-+#endif
+@@ -212,10 +212,10 @@
+     else collected_bytes += c->bytes (), collected_clauses++;
+ 
+   PHASE ("collect", stats.collections,
+-    "moving %zd bytes %.0f%% of %zd non garbage clauses",
+-    moved_bytes,
++    "moving %ld bytes %.0f%% of %ld non garbage clauses",
++    (long) moved_bytes,
+     percent (moved_bytes, collected_bytes + moved_bytes),
+-    moved_clauses);
++    (long) moved_clauses);
+ 
+   // Prepare 'to' space of size 'moved_bytes'.
+   //
+@@ -308,10 +308,10 @@
+   arena.swap ();
+ 
+   PHASE ("collect", stats.collections,
+-    "collected %zd bytes %.0f%% of %zd garbage clauses",
+-    collected_bytes,
++    "collected %ld bytes %.0f%% of %ld garbage clauses",
++    (long) collected_bytes,
+     percent (collected_bytes, collected_bytes + moved_bytes),
+-    collected_clauses);
++    (long) collected_clauses);
+ }
+ 
+ /*------------------------------------------------------------------------*/
+@@ -323,7 +323,7 @@
+ 
+ void Internal::check_clause_stats () {
+ #ifndef NDEBUG
+-  int64_t irredundant = 0, redundant = 0, total = 0, irrbytes = 0;
++  long irredundant = 0, redundant = 0, total = 0, irrbytes = 0;
+   for (const auto & c : clauses) {
+     if (c->garbage) continue;
+     if (c->redundant) redundant++; else irredundant++;
+diff -Naur solvers/cadical/compact.cpp solvers/cdc/compact.cpp
+--- solvers/cadical/compact.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/compact.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -197,7 +197,7 @@
+     int src = external->e2i[eidx], dst;
+     if (!src) continue;
+     dst = mapper.map_lit (src);
+-    LOG ("compact %" PRId64 " maps external %d to internal %d from internal %d",
++    LOG ("compact %ld maps external %d to internal %d from internal %d",
+       stats.compacts, eidx, dst, src);
+     external->e2i[eidx] = dst;
+   }
+@@ -400,11 +400,11 @@
+ 
+   check_var_stats ();
+ 
+-  int64_t delta = opts.compactint * (stats.compacts + 1);
++  long delta = opts.compactint * (stats.compacts + 1);
+   lim.compact = stats.conflicts + delta;
+ 
+   PHASE ("compact", stats.compacts,
+-    "new compact limit %" PRId64 " after %" PRId64 " conflicts",
++    "new compact limit %ld after %ld conflicts",
+     lim.compact, delta);
+ 
+   STOP (compact);
+diff -Naur solvers/cadical/contract.hpp solvers/cdc/contract.hpp
+--- solvers/cadical/contract.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/contract.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -54,7 +54,7 @@
+ #define REQUIRE_VALID_LIT(LIT) \
+ do { \
+   REQUIRE ((int)(LIT) && ((int) (LIT)) != INT_MIN, \
+-    "invalid literal '%d'", (int)(LIT)); \
++    "invalid literal '%ld'", (long)(LIT)); \
+ } while (0)
+ 
+ /*------------------------------------------------------------------------*/
+diff -Naur solvers/cadical/cover.cpp solvers/cdc/cover.cpp
+--- solvers/cadical/cover.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/cover.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -368,23 +368,23 @@
+   }
+ };
+ 
+-int64_t Internal::cover_round () {
++long Internal::cover_round () {
+ 
+   if (unsat) return 0;
+ 
+   init_watches ();
+   connect_watches (true);     // irredundant watches only is enough
+ 
+-  int64_t delta = stats.propagations.search;
++  long delta = stats.propagations.search;
+   delta *= 1e-3 * opts.coverreleff;
+   if (delta < opts.covermineff) delta = opts.covermineff;
+   if (delta > opts.covermaxeff) delta = opts.covermaxeff;
+-  delta = max (delta, ((int64_t) 2) * active ());
++  delta = max (delta, 2l * active ());
+ 
+   PHASE ("cover", stats.cover.count,
+-    "covered clause elimination limit of %" PRId64 " propagations", delta);
++    "covered clause elimination limit of %ld propagations", delta);
+ 
+-  int64_t limit = stats.propagations.cover + delta;
++  long limit = stats.propagations.cover + delta;
+ 
+   init_occs ();
+ 
+@@ -393,7 +393,7 @@
+ 
+   // First connect all clauses and find all not yet tried clauses.
+   //
+-  int64_t untried = 0;
++  long untried = 0;
+   //
+   for (auto c : clauses) {
+     assert (!c->frozen);
+@@ -462,7 +462,7 @@
+ 
+   // This is the main loop of trying to do CCE of candidate clauses.
+   //
+-  int64_t covered = 0;
++  long covered = 0;
+   //
+   while (!terminating () &&
+          !schedule.empty () &&
+@@ -477,11 +477,11 @@
+   const size_t remain = schedule.size ();
+   const size_t tried = scheduled - remain;
+   PHASE ("cover", stats.cover.count,
+-    "eliminated %" PRId64 " covered clauses out of %zd tried %.0f%%",
++    "eliminated %ld covered clauses out of %zd tried %.0f%%",
+     covered, tried, percent (covered, tried));
+   if (remain)
+     PHASE ("cover", stats.cover.count,
+-      "remaining %" PRId64 " clauses %.0f%% untried",
++      "remaining %ld clauses %.0f%% untried",
+       remain, percent (remain, scheduled));
+   else
+     PHASE ("cover", stats.cover.count,
+@@ -527,7 +527,7 @@
+   if (propagated < trail.size ()) {
+     init_watches ();
+     connect_watches ();         // need to propagated over all clauses!
+-    LOG ("elimination produced %" PRId64 " units", trail.size () - propagated);
++    LOG ("elimination produced %ld units", trail.size () - propagated);
+     if (!propagate ()) {
+       LOG ("propagating units before covered clause elimination "
+         "results in empty clause");
+@@ -538,7 +538,7 @@
+   }
+   assert (unsat || propagated == trail.size ());
+ 
+-  int64_t covered = cover_round ();
++  long covered = cover_round ();
+ 
+   STOP_SIMPLIFIER (cover, COVER);
+   report ('c', !opts.reportall && !covered);
+diff -Naur solvers/cadical/decide.cpp solvers/cdc/decide.cpp
+--- solvers/cadical/decide.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/decide.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -10,7 +10,7 @@
+ // the assigned variables (if 'opts.restartreusetrail' is non-zero).
+ 
+ int Internal::next_decision_variable_on_queue () {
+-  int64_t searched = 0;
++  long searched = 0;
+   int res = queue.unassigned;
+   while (val (res))
+     res = link (res).prev, searched++;
+@@ -18,7 +18,7 @@
+     stats.searched += searched;
+     update_queue_unassigned (res);
+   }
+-  LOG ("next queue decision variable %d bumped %" PRId64 "", res, bumped (res));
++  LOG ("next queue decision variable %d bumped %ld", res, bumped (res));
+   return res;
+ }
+ 
+diff -Naur solvers/cadical/decompose.cpp solvers/cdc/decompose.cpp
+--- solvers/cadical/decompose.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/decompose.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -295,8 +295,8 @@
+   }
+ 
+   if (!unsat && !postponed_garbage.empty ()) {
+-    LOG ("now marking %zd postponed garbage clauses",
+-      postponed_garbage.size ());
++    LOG ("now marking %ld postponed garbage clauses",
++      (long) postponed_garbage.size ());
+     for (const auto & c : postponed_garbage)
+       mark_garbage (c);
+   }
+@@ -304,7 +304,7 @@
+ 
+   PHASE ("decompose",
+     stats.decompositions,
+-    "%" PRId64 " clauses replaced %.2f%% producing %" PRId64 " garbage clauses %.2f%%",
++    "%ld clauses replaced %.2f%% producing %ld garbage clauses %.2f%%",
+     replaced, percent (replaced, clauses_size),
+     garbage, percent (garbage, replaced));
+ 
+diff -Naur solvers/cadical/deduplicate.cpp solvers/cdc/deduplicate.cpp
+--- solvers/cadical/deduplicate.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/deduplicate.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -30,8 +30,8 @@
+ 
+   vector<int> stack;    // To save marked literals and unmark them later.
+ 
+-  int64_t subsumed = 0;
+-  int64_t units = 0;
++  long subsumed = 0;
++  long units = 0;
+ 
+   for (int idx = 1; !unsat && idx <= max_var; idx++) {
+ 
+diff -Naur solvers/cadical/elim.cpp solvers/cdc/elim.cpp
+--- solvers/cadical/elim.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/elim.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -9,8 +9,8 @@
+ // inprocessing version, i.e., it is interleaved with search and triggers
+ // blocked clause elimination, subsumption and strengthening rounds during
+ // elimination rounds.  It focuses only those variables which occurred in
+-// removed irredundant clauses since the last time an elimination round
+-// was run.  By bounding the maximum resolvent size we can run each
++// removed irredundant clauses since the last time an elimination round was
++// run.  By bounding the maximum the maximum resolvent size we can run each
+ // elimination round until completion.  See the code of 'elim' for how
+ // elimination rounds are interleaved with blocked clause elimination and
+ // subsumption (which in turn also calls vivification and transitive
+@@ -33,8 +33,8 @@
+ /*------------------------------------------------------------------------*/
+ 
+ inline bool elim_more::operator () (unsigned a, unsigned b) {
+-  const auto s = internal->compute_elim_score (a);
+-  const auto t = internal->compute_elim_score (b);
++  const unsigned long s = internal->compute_elim_score (a);
++  const unsigned long t = internal->compute_elim_score (b);
+   if (s > t) return true;
+   if (s < t) return false;
+   return a > b;
+@@ -92,7 +92,7 @@
+ void Internal::elim_update_removed_lit (Eliminator & eliminator, int lit) {
+   if (!active (lit)) return;
+   if (frozen (lit)) return;
+-  int64_t & score = noccs (lit);
++  long & score = noccs (lit);
+   assert (score > 0);
+   score--;
+   const int idx = abs (lit);
+@@ -270,7 +270,7 @@
+   }
+ 
+   unmark (c);
+-  const int64_t size = clause.size ();
++  const long size = (long) clause.size ();
+ 
+   if (satisfied) {
+     LOG (d, "satisfied by %d antecedent", satisfied);
+@@ -369,12 +369,12 @@
+ 
+   const Occs & ps = occs (pivot);
+   const Occs & ns = occs (-pivot);
+-  const int64_t pos = ps.size ();
+-  const int64_t neg = ns.size ();
++  const long pos = ps.size ();
++  const long neg = ns.size ();
+   if (!pos || !neg) return lim.elimbound >= 0;
+-  const int64_t bound = pos + neg + lim.elimbound;
++  const long bound = pos + neg + lim.elimbound;
+ 
+-  LOG ("checking number resolvents on %d bounded by %" PRId64 " = %" PRId64 " + %" PRId64 " + %d",
++  LOG ("checking number resolvents on %d bounded by %ld = %ld + %ld + %d",
+     pivot, bound, pos, neg, lim.elimbound);
+ 
+   // Try all resolutions between a positive occurrence (outer loop) of
+@@ -382,7 +382,7 @@
+   // bound on non-tautological resolvents is not hit and the size of the
+   // generated resolvents does not exceed the resolvent clause size limit.
+ 
+-  int64_t resolvents = 0;          // Non-tautological resolvents.
++  long resolvents = 0;          // Non-tautological resolvents.
+ 
+   for (const auto & c : ps) {
+     assert (!c->redundant);
+@@ -396,10 +396,10 @@
+         resolvents++;
+         int size = clause.size ();
+         clause.clear ();
+-        LOG ("now at least %" PRId64 " non-tautological resolvents on pivot %d",
++        LOG ("now at least %ld non-tautological resolvents on pivot %d",
+           resolvents, pivot);
+         if (size > opts.elimclslim) {
+-          LOG ("resolvent size %d too big after %" PRId64 " resolvents on %d",
++          LOG ("resolvent size %d too big after %ld resolvents on %d",
+             size, resolvents, pivot);
+           return false;
+         }
+@@ -412,7 +412,7 @@
+     }
+   }
+ 
+-  LOG ("need %" PRId64 " <= %" PRId64 " non-tautological resolvents", resolvents, bound);
++  LOG ("need %ld <= %ld non-tautological resolvents", resolvents, bound);
+ 
+   return true;
  }
+@@ -438,7 +438,7 @@
+   const Occs & ps = occs (pivot);
+   const Occs & ns = occs (-pivot);
+ 
+-  int64_t resolvents = 0;
++  long resolvents = 0;
+ 
+   for (auto & c : ps) {
+     if (unsat) break;
+@@ -458,7 +458,7 @@
+     }
+   }
  
+-  LOG ("added %" PRId64 " resolvents to eliminate %d", resolvents, pivot);
++  LOG ("added %ld resolvents to eliminate %d", resolvents, pivot);
  }
+ 
+ /*------------------------------------------------------------------------*/
+@@ -474,11 +474,11 @@
+ 
+   LOG ("marking irredundant clauses with %d as garbage", pivot);
+ 
+-  const int64_t substitute = eliminator.gates.size ();
++  const long substitute = eliminator.gates.size ();
+   if (substitute)
+-    LOG ("pushing %" PRId64 " gate clauses on extension stack", substitute);
++    LOG ("pushing %ld gate clauses on extension stack", substitute);
+ 
+-  int64_t pushed = 0;
++  long pushed = 0;
+ 
+   Occs & ps = occs (pivot);
+   for (const auto & c : ps) {
+@@ -527,11 +527,11 @@
+ 
+   // First flush garbage clauses.
+   //
+-  int64_t pos = flush_occs (pivot);
+-  int64_t neg = flush_occs (-pivot);
++  long pos = flush_occs (pivot);
++  long neg = flush_occs (-pivot);
+ 
+   if (pos > neg) { pivot = -pivot; swap (pos, neg); }
+-  LOG ("pivot %d occurs positively %" PRId64 " times and negatively %" PRId64 " times",
++  LOG ("pivot %d occurs positively %ld times and negatively %ld times",
+     pivot, pos, neg);
+   assert (!eliminator.schedule.contains (abs (pivot)));
+   assert (pos <= neg);
+@@ -602,17 +602,17 @@
+   last.elim.marked = stats.mark.elim;
+   assert (!level);
+ 
+-  int64_t resolution_limit;
++  long resolution_limit;
+ 
+   if (opts.elimlimited) {
+-    int64_t delta = stats.propagations.search;
++    long delta = stats.propagations.search;
+     delta *= 1e-3 * opts.elimreleff;
+     if (delta < opts.elimineff) delta = opts.elimineff;
+     if (delta > opts.elimaxeff) delta = opts.elimaxeff;
+-    delta = max (delta, (int64_t) 2l * active ());
++    delta = max (delta, 2l * active ());
+ 
+     PHASE ("elim-round", stats.elimrounds,
+-      "limit of %" PRId64 " resolutions", delta);
++      "limit of %ld resolutions", delta);
+ 
+      resolution_limit = stats.elimres + delta;
+   } else {
+@@ -667,11 +667,11 @@
+   schedule.shrink ();
+ 
+ #ifndef QUIET
+-  int64_t scheduled = schedule.size ();
++  long scheduled = schedule.size ();
+ #endif
+ 
+   PHASE ("elim-round", stats.elimrounds,
+-    "scheduled %" PRId64 " variables %.0f%% for elimination",
++    "scheduled %ld variables %.0f%% for elimination",
+     scheduled, percent (scheduled, active ()));
+ 
+   // Connect irredundant clauses.
+@@ -683,7 +683,7 @@
+           occs (lit).push_back (c);
+ 
+ #ifndef QUIET
+-  const int64_t old_resolutions = stats.elimres;
++  const long old_resolutions = stats.elimres;
+ #endif
+   const int old_eliminated = stats.all.eliminated;
+   const int old_fixed = stats.all.fixed;
+@@ -691,12 +691,12 @@
+   // Limit on garbage bytes during variable elimination. If the limit is hit
+   // a garbage collection is performed.
+   //
+-  const int64_t garbage_limit = (2*stats.irrbytes/3) + (1<<20);
++  const long garbage_limit = (2*stats.irrbytes/3) + (1<<20);
+ 
+   // Try eliminating variables according to the schedule.
+   //
+ #ifndef QUIET
+-  int64_t tried = 0;
++  long tried = 0;
+ #endif
+   while (!unsat &&
+          !terminating () &&
+@@ -714,11 +714,11 @@
+     garbage_collection ();
+   }
+ 
+-  const int64_t remain = schedule.size ();
++  const long remain = schedule.size ();
+   const bool completed = !remain;
+ 
+   PHASE ("elim-round", stats.elimrounds,
+-    "tried to eliminate %" PRId64 " variables %.0f%% (%" PRId64 " remain)",
++    "tried to eliminate %ld variables %.0f%% (%ld remain)",
+     tried, percent (tried, scheduled), remain);
+ 
+   schedule.erase ();
+@@ -742,9 +742,9 @@
+ 
+   int eliminated = stats.all.eliminated - old_eliminated;
+ #ifndef QUIET
+-  int64_t resolutions = stats.elimres - old_resolutions;
++  long resolutions = stats.elimres - old_resolutions;
+   PHASE ("elim-round", stats.elimrounds,
+-    "eliminated %" PRId64 " variables %.0f%% in %" PRId64 " resolutions",
++    "eliminated %ld variables %.0f%% in %ld resolutions",
+     eliminated, percent (eliminated, scheduled), resolutions);
+ #endif
+ 
+@@ -779,7 +779,7 @@
+     lim.elimbound = opts.elimboundmax;
+ 
+   PHASE ("elim-phase", stats.elimphases,
+-    "new elimination bound %" PRId64 "", lim.elimbound);
++    "new elimination bound %ld", lim.elimbound);
+ 
+   // Now reschedule all active variables for elimination again.
+   //
+@@ -860,11 +860,11 @@
+   if (completed) {
+     stats.elimcompleted++;
+     PHASE ("elim-phase", stats.elimphases,
+-      "fully completed elimination %" PRId64 " at elimination bound %" PRId64 "",
++      "fully completed elimination %ld at elimination bound %ld",
+       stats.elimcompleted, lim.elimbound);
+   } else {
+     PHASE ("elim-phase", stats.elimphases,
+-      "incomplete elimination %" PRId64 " at elimination bound %" PRId64 "",
++      "incomplete elimination %ld at elimination bound %ld",
+       stats.elimcompleted + 1, lim.elimbound);
+   }
+ 
+@@ -873,7 +873,7 @@
+ 
+   if (unsat) LOG ("elimination derived empty clause");
+   else if (propagated < trail.size ()) {
+-    LOG ("elimination produced %" PRId64 " units", trail.size () - propagated);
++    LOG ("elimination produced %ld units", trail.size () - propagated);
+     if (!propagate ()) {
+       LOG ("propagating units after elimination results in empty clause");
+       learn_empty_clause ();
+@@ -891,11 +891,11 @@
+ 
+   if (!update_limits) return;
+ 
+-  int64_t delta = scale (opts.elimint * (stats.elimphases + 1));
++  long delta = scale (opts.elimint * (stats.elimphases + 1));
+   lim.elim = stats.conflicts + delta;
+ 
+   PHASE ("elim-phase", stats.elimphases,
+-    "new limit at %" PRId64 " conflicts after %" PRId64 " conflicts", lim.elim, delta);
++    "new limit at %ld conflicts after %ld conflicts", lim.elim, delta);
+ 
+   last.elim.fixed = stats.all.fixed;
+ }
+diff -Naur solvers/cadical/ema.cpp solvers/cdc/ema.cpp
+--- solvers/cadical/ema.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/ema.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -36,7 +36,7 @@
+   wait = period = 2*(period + 1) - 1;
+   beta *= 0.5;
+   if (beta < alpha) beta = alpha;
+-  LOG ("new %s EMA wait = period = %" PRId64 ", beta = %g", name, wait, beta);
++  LOG ("new %s EMA wait = period = %ld, beta = %g", name, wait, beta);
+ }
+ 
+ }
+diff -Naur solvers/cadical/ema.hpp solvers/cdc/ema.hpp
+--- solvers/cadical/ema.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/ema.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -13,8 +13,8 @@
+   double value;         // current average value
+   double alpha;         // percentage contribution of new values
+   double beta;          // current upper approximation of alpha
+-  int64_t wait;         // count-down using 'beta' instead of 'alpha'
+-  int64_t period;       // length of current waiting phase
++  long wait;            // count-down using 'beta' instead of 'alpha'
++  long period;          // length of current waiting phase
+ 
+   EMA () : value (0), alpha (0), beta (0), wait (0), period (0) { }
+ 
+diff -Naur solvers/cadical/extend.cpp solvers/cdc/extend.cpp
+--- solvers/cadical/extend.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/extend.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -97,7 +97,7 @@
+     "mapping internal %d assignments to %d assignments",
+     internal->max_var, max_var);
+ 
+-  int64_t updated = 0;
++  long updated = 0;
+   for (unsigned i = 1; i <= (unsigned) max_var; i++) {
+     const int ilit = e2i[i];
+     if (!ilit) continue;
+@@ -107,13 +107,13 @@
+     updated++;
+   }
+   PHASE ("extend", internal->stats.extensions,
+-    "updated %" PRId64 " external assignments", updated);
++    "updated %ld external assignments", updated);
+   PHASE ("extend", internal->stats.extensions,
+-    "extending through extension stack of size %zd",
+-    extension.size ());
++    "extending through extension stack of size %ld",
++    (long) extension.size ());
+   const auto begin = extension.begin ();
+   auto i = extension.end ();
+-  int64_t flipped = 0;
++  long flipped = 0;
+   while (i != begin) {
+     bool satisfied = false;
+     int lit;
+@@ -146,7 +146,7 @@
+     }
+   }
+   PHASE ("extend", internal->stats.extensions,
+-    "flipped %" PRId64 " literals during extension", flipped);
++    "flipped %ld literals during extension", flipped);
+   extended = true;
+   LOG ("extended");
+   STOP (extend);
+diff -Naur solvers/cadical/external.cpp solvers/cdc/external.cpp
+--- solvers/cadical/external.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/external.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -26,7 +26,7 @@
+ 
+   size_t new_vsize = vsize ? 2*vsize : 1 + (size_t) new_max_var;
+   while (new_vsize <= (size_t) new_max_var) new_vsize *= 2;
+-  LOG ("enlarge external size from %zd to new size %zd", vsize, new_vsize);
++  LOG ("enlarge external size from %ld to new size %ld", vsize, new_vsize);
+   vsize = new_vsize;
+ }
+ 
+@@ -58,7 +58,7 @@
+     assert (e2i[eidx] == iidx);
+   }
+   if (internal->opts.checkfrozen)
+-    while (new_max_var >= (int64_t) moltentab.size ())
++    while (new_max_var >= (long) moltentab.size ())
+       moltentab.push_back (false);
+   assert (iidx == new_internal_max_var + 1);
+   assert (eidx == new_max_var + 1);
+@@ -104,7 +104,7 @@
+       if (elit < 0) ilit = -ilit;
+     }
+     if (internal->opts.checkfrozen) {
+-      assert (eidx < (int64_t) moltentab.size ());
++      assert (eidx < (long) moltentab.size ());
+       if (moltentab[eidx])
+         FATAL ("can not reuse molten literal %d", eidx);
+     }
+@@ -189,7 +189,7 @@
+ 
+ void External::update_molten_literals () {
+   if (!internal->opts.checkfrozen) return;
+-  assert (max_var + 1 == (int64_t) moltentab.size ());
++  assert (max_var + 1 == (long) moltentab.size ());
+   int registered = 0, molten = 0;
+   for (int lit = 1; lit <= max_var; lit++) {
+     if (moltentab[lit]) {
+@@ -210,6 +210,7 @@
+ 
+ int External::solve () {
+   reset_extended ();
++  SECTION ("solving");
+   update_molten_literals ();
+   int res = internal->solve ();
+   if (res == 10) extend ();
+@@ -274,7 +275,7 @@
+   bool satisfied = false;
+   const auto end = original.end ();
+   auto start = original.begin (), i = start;
+-  int64_t count = 0;
++  long count = 0;
+   for (; i != end; i++) {
+     int lit = *i;
+     if (!lit) {
+@@ -292,7 +293,7 @@
+     } else if (!satisfied && (this->*a) (lit) > 0) satisfied = true;
+   }
+   VERBOSE (1,
+-    "satisfying assignment checked on %" PRId64 " clauses",
++    "satisfying assignment checked on %ld clauses",
+     count);
+ }
+ 
+diff -Naur solvers/cadical/file.cpp solvers/cdc/file.cpp
+--- solvers/cadical/file.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/file.cpp	1970-01-01 10:00:00.000000000 +1000
+@@ -1,301 +0,0 @@
+-#include "internal.hpp"
+-
+-/*------------------------------------------------------------------------*/
+-
+-// Some more low-level 'C' headers.
+-
+-extern "C" {
+-#include <string.h>
+-#include <errno.h>
+-#include <sys/stat.h>
+-#include <sys/types.h>
+-#include <unistd.h>
+-#include <stdlib.h>
+-}
+-
+-/*------------------------------------------------------------------------*/
+-
+-namespace CaDiCaL {
+-
+-/*------------------------------------------------------------------------*/
+-
+-// Private constructor.
+-
+-File::File (Internal *i, bool w, int c, FILE * f, const char * n)
+-:
+-#ifndef QUIET
+-  internal (i),
+-#endif
+-#if !defined(QUIET) || !defined(NDEBUG)
+-  writing (w),
+-#endif
+-  close_file (c), file (f),
+-  _name (n), _lineno (1), _bytes (0)
+-{
+-  (void) i, (void) w;
+-  assert (f), assert (n);
+-}
+-
+-/*------------------------------------------------------------------------*/
+-
+-bool File::exists (const char * path) {
+-  struct stat buf;
+-  if (stat (path, &buf)) return false;
+-  if (access (path, R_OK)) return false;
+-  return true;
+-}
+-
+-bool File::writable (const char * path) {
+-  int res;
+-  if (!path) res = 1;
+-  else if (!strcmp (path, "/dev/null")) res = 0;
+-  else {
+-    if (!*path) res = 2;
+-    else {
+-      struct stat buf;
+-      const char * p = strrchr (path, '/');
+-      if (!p) {
+-        if (stat (path, &buf)) res = ((errno == ENOENT) ? 0 : -2);
+-        else if (S_ISDIR (buf.st_mode)) res = 3;
+-        else res = (access (path, W_OK) ? 4 : 0);
+-      } else if (!p[1]) res = 5;
+-      else {
+-        size_t len = p - path;
+-        char * dirname = new char[len + 1];
+-        strncpy (dirname, path, len);
+-        dirname[len] = 0;
+-        if (stat (dirname, &buf)) res = 6;
+-        else if (!S_ISDIR (buf.st_mode)) res = 7;
+-        else if (access (dirname, W_OK)) res = 8;
+-        else if (stat (path, &buf)) res = (errno == ENOENT) ? 0 : -3;
+-        else res = access (path, W_OK) ? 9 : 0;
+-        delete [] dirname;
+-      }
+-    }
+-  }
+-  return !res;
+-}
+-
+-// These are signatures for supported compressed file types.  In 2018 the
+-// SAT Competition was running on StarExec and used internally 'bzip2'
+-// compressed files, but gave them uncompressed to the solver using exactly
+-// the same path (with '.bz2' suffix).  Then 'CaDiCaL' tried to read that
+-// actually uncompressed file through 'bzip2', which of course failed.  Now
+-// we double check and fall back to reading the file as is, if the signature
+-// does not match after issuing a warning.
+-
+-static int xzsig[] = { 0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00, 0x00, EOF };
+-static int bz2sig[] = { 0x42, 0x5A, 0x68, EOF };
+-static int gzsig[] = { 0x1F, 0x8B, EOF };
+-static int sig7z[] = { 0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C, EOF };
+-static int lzmasig[] = { 0x5D, 0x00, 0x00, 0x80, 0x00, EOF };
+-
+-bool File::match (Internal * internal,
+-                  const char * path, const int * sig) {
+-  assert (path);
+-  FILE * tmp = fopen (path, "r");
+-  if (!tmp) {
+-    WARNING ("failed to open '%s' to check signature", path);
+-    return false;
+-  }
+-  bool res = true;
+-  for (const int *p = sig; res && (*p != EOF); p++)
+-    res = (cadical_getc_unlocked (tmp) == *p);
+-  fclose (tmp);
+-  if (!res) WARNING ("file type signature check for '%s' failed", path);
+-  return res;
+-}
+-
+-size_t File::size (const char * path) {
+-  struct stat buf;
+-  if (stat (path, &buf)) return 0;
+-  return (size_t) buf.st_size;
+-}
+-
+-// Check that 'prg' is in the 'PATH' and thus can be found if executed
+-// through 'popen'.
+-
+-char * File::find (const char * prg) {
+-  size_t prglen = strlen (prg);
+-  const char * c = getenv ("PATH");
+-  if (!c) return 0;;
+-  size_t len = strlen (c);
+-  char * e = new char[len + 1];
+-  strcpy (e, c);
+-  char * res = 0;
+-  for (char * p = e, * q; !res && p < e + len; p = q) {
+-    for (q = p; *q && *q != ':'; q++)
+-      ;
+-    *q++ = 0;
+-    size_t pathlen = (q - p) + prglen;
+-    char * path = new char [pathlen + 1];
+-    sprintf (path, "%s/%s", p, prg);
+-    assert (strlen (path) == pathlen);
+-    if (exists (path)) res = path;
+-    else delete [] path;
+-  }
+-  delete [] e;
+-  return res;
+-}
+-
+-/*------------------------------------------------------------------------*/
+-
+-FILE * File::open_file (Internal * internal, const char * path,
+-                                             const char * mode) {
+-  (void) internal;
+-  return fopen (path, mode);
+-}
+-
+-FILE * File::read_file (Internal * internal, const char * path) {
+-  MSG ("opening file to read '%s'", path);
+-  return open_file (internal, path, "r");
+-}
+-
+-FILE * File::write_file (Internal * internal, const char * path) {
+-  MSG ("opening file to write '%s'", path);
+-  return open_file (internal, path, "w");
+-}
+-
+-/*------------------------------------------------------------------------*/
+-
+-FILE * File::open_pipe (Internal * internal,
+-                        const char * fmt, const char * path,
+-                        const char * mode) {
+-#ifdef QUIET
+-  (void) internal;
+-#endif
+-  size_t prglen = 0;
+-  while (fmt[prglen] && fmt[prglen] != ' ') prglen++;
+-  char * prg = new char [prglen + 1];
+-  strncpy (prg, fmt, prglen);
+-  prg[prglen] = 0;
+-  char * found = find (prg);
+-  if (found) MSG ("found '%s' in path for '%s'", found, prg);
+-  if (!found) MSG ("did not find '%s' in path", prg);
+-  delete [] prg;
+-  if (!found) return 0;
+-  delete [] found;
+-  char * cmd = new char [strlen (fmt) + strlen (path)];
+-  sprintf (cmd, fmt, path);
+-  FILE * res = popen (cmd, mode);
+-  delete [] cmd;
+-  return res;
+-}
+-
+-FILE * File::read_pipe (Internal * internal,
+-                        const char * fmt,
+-                        const int * sig,
+-                        const char * path) {
+-  if (!File::exists (path)) {
+-    LOG ("file '%s' does not exist", path);
+-    return 0;
+-  }
+-  LOG ("file '%s' exists", path);
+-  if (sig && !File::match (internal, path, sig)) return 0;
+-  LOG ("file '%s' matches signature for '%s'", path, fmt);
+-  MSG ("opening pipe to read '%s'", path);
+-  return open_pipe (internal, fmt, path, "r");
+-}
+-
+-FILE * File::write_pipe (Internal * internal,
+-                         const char * fmt, const char * path) {
+-  MSG ("opening pipe to write '%s'", path);
+-  return open_pipe (internal, fmt, path, "w");
+-}
+-
+-/*------------------------------------------------------------------------*/
+-
+-File * File::read (Internal * internal, FILE * f, const char * n) {
+-  return new File (internal, false, 0, f, n);
+-}
+-
+-File * File::write (Internal * internal, FILE * f, const char * n) {
+-  return new File (internal, true, 0, f, n);
+-}
+-
+-File * File::read (Internal * internal, const char * path) {
+-  FILE * file;
+-  int close_input = 2;
+-  if (has_suffix (path, ".xz")) {
+-    file = read_pipe (internal, "xz -c -d %s", xzsig, path);
+-    if (!file) goto READ_FILE;
+-  } else if (has_suffix (path, ".lzma")) {
+-    file = read_pipe (internal, "lzma -c -d %s", lzmasig, path);
+-    if (!file) goto READ_FILE;
+-  } else if (has_suffix (path, ".bz2")) {
+-    file = read_pipe (internal, "bzip2 -c -d %s", bz2sig, path);
+-    if (!file) goto READ_FILE;
+-  } else if (has_suffix (path, ".gz")) {
+-    file = read_pipe (internal, "gzip -c -d %s", gzsig, path);
+-    if (!file) goto READ_FILE;
+-  } else if (has_suffix (path, ".7z")) {
+-    file = read_pipe (internal, "7z x -so %s 2>/dev/null", sig7z, path);
+-    if (!file) goto READ_FILE;
+-  } else {
+-READ_FILE:
+-    file = read_file (internal, path);
+-    close_input = 1;
+-  }
+-
+-  return file ? new File (internal, false, close_input, file, path) : 0;
+-}
+-
+-File * File::write (Internal * internal, const char * path) {
+-  FILE * file;
+-  int close_input = 2;
+-  if (has_suffix (path, ".xz"))
+-    file = write_pipe (internal, "xz -c > %s", path);
+-  else if (has_suffix (path, ".bz2"))
+-    file = write_pipe (internal, "bzip2 -c > %s", path);
+-  else if (has_suffix (path, ".gz"))
+-    file = write_pipe (internal, "gzip -c > %s", path);
+-  else if (has_suffix (path, ".7z"))
+-    file = write_pipe (internal,
+-                       "7z a -an -txz -si -so > %s 2>/dev/null", path);
+-  else
+-    file = write_file (internal, path), close_input = 1;
+-
+-  return file ? new File (internal, true, close_input, file, path) : 0;
+-}
+-
+-void File::close () {
+-  assert (file);
+-  if (close_file == 0) {
+-    VERBOSE (1, "disconnecting from '%s'", name ());
+-  }
+-  if (close_file == 1) {
+-    VERBOSE (1, "closing file '%s'", name ());
+-    fclose (file);
+-  }
+-  if (close_file == 2) {
+-    VERBOSE (1, "closing pipe command on '%s'", name ());
+-    pclose (file);
+-  }
+-
+-  file = 0;     // mark as closed
+-
+-#ifndef QUIET
+-  if (internal->opts.verbose > 1) return;
+-  double mb = bytes () / (double) (1 << 20);
+-  if (writing)
+-    VERBOSE (1, "after writing %" PRId64 " bytes %.1f MB", bytes (), mb);
+-  else
+-    VERBOSE (1, "after reading %" PRId64 " bytes %.1f MB", bytes (), mb);
+-  if (close_file == 2) {
+-    int64_t s = size (name ());
+-    double mb = s / (double) (1<<20);
+-    if (writing)
+-      VERBOSE (1, "deflated to %" PRId64 " bytes %.1f MB by factor %.2f "
+-        "(%.2f%% compression)",
+-        s, mb, relative (bytes (), s), percent (bytes () - s, bytes ()));
+-    else
+-      VERBOSE (1, "inflated from %" PRId64 " bytes %.1f MB by factor %.2f "
+-        "(%.2f%% compression)",
+-        s, mb, relative (bytes (), s), percent (bytes () - s, bytes ()));
+-  }
+-#endif
+-}
+-
+-File::~File () { if (file) close (); }
+-
+-}
+diff -Naur solvers/cadical/file.hpp solvers/cdc/file.hpp
+--- solvers/cadical/file.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/file.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -40,8 +40,8 @@
+   int close_file;       // need to close file (1=fclose, 2=pclose)
+   FILE * file;
+   const char * _name;
+-  int64_t _lineno;
+-  int64_t _bytes;
++  long _lineno;
++  long _bytes;
+ 
+   File (Internal *, bool, int, FILE *, const char *);
+ 
+@@ -141,18 +141,19 @@
+     }
+   }
+ 
+-  bool put (int64_t l) {
++  bool put (long l) {
+     assert (writing);
+     if (!l) return put ('0');
+-    else if (l == INT64_MIN) {
++    else if (l == LONG_MIN) {
+       assert (sizeof l == 8);
++      assert (l == LONG_MIN);
+       return put ("-9223372036854775808");
+     } else {
+       char buffer[21];
+       int i = sizeof buffer;
+       buffer[--i] = 0;
+-      assert (l != INT64_MIN);
+-      uint64_t k = l < 0 ? -l : l;
++      assert (l != LONG_MIN);
++      unsigned long k = l < 0 ? -l : l;
+       while (k) {
+         assert (i > 0);
+         buffer[--i] = '0' + k % 10;
+@@ -164,8 +165,8 @@
+   }
+ 
+   const char * name () const { return _name; }
+-  int64_t lineno () const { return _lineno; }
+-  int64_t bytes () const { return _bytes; }
++  long lineno () const { return _lineno; }
++  long bytes () const { return _bytes; }
+ 
+   bool closed () { return !file; }
+   void close ();
+diff -Naur solvers/cadical/file0.cpp solvers/cdc/file0.cpp
+--- solvers/cadical/file0.cpp	1970-01-01 10:00:00.000000000 +1000
++++ solvers/cdc/file0.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -0,0 +1,301 @@
++#include "internal.hpp"
++
++/*------------------------------------------------------------------------*/
++
++// Some more low-level 'C' headers.
++
++extern "C" {
++#include <string.h>
++#include <errno.h>
++#include <sys/stat.h>
++#include <sys/types.h>
++#include <unistd.h>
++#include <stdlib.h>
++}
++
++/*------------------------------------------------------------------------*/
++
++namespace CaDiCaL {
++
++/*------------------------------------------------------------------------*/
++
++// Private constructor.
++
++File::File (Internal *i, bool w, int c, FILE * f, const char * n)
++:
++#ifndef QUIET
++  internal (i),
++#endif
++#if !defined(QUIET) || !defined(NDEBUG)
++  writing (w),
++#endif
++  close_file (c), file (f),
++  _name (n), _lineno (1), _bytes (0)
++{
++  (void) i, (void) w;
++  assert (f), assert (n);
++}
++
++/*------------------------------------------------------------------------*/
++
++bool File::exists (const char * path) {
++  struct stat buf;
++  if (stat (path, &buf)) return false;
++  if (access (path, R_OK)) return false;
++  return true;
++}
++
++bool File::writable (const char * path) {
++  int res;
++  if (!path) res = 1;
++  else if (!strcmp (path, "/dev/null")) res = 0;
++  else {
++    if (!*path) res = 2;
++    else {
++      struct stat buf;
++      const char * p = strrchr (path, '/');
++      if (!p) {
++        if (stat (path, &buf)) res = ((errno == ENOENT) ? 0 : -2);
++        else if (S_ISDIR (buf.st_mode)) res = 3;
++        else res = (access (path, W_OK) ? 4 : 0);
++      } else if (!p[1]) res = 5;
++      else {
++        size_t len = p - path;
++        char * dirname = new char[len + 1];
++        strncpy (dirname, path, len);
++        dirname[len] = 0;
++        if (stat (dirname, &buf)) res = 6;
++        else if (!S_ISDIR (buf.st_mode)) res = 7;
++        else if (access (dirname, W_OK)) res = 8;
++        else if (stat (path, &buf)) res = (errno == ENOENT) ? 0 : -3;
++        else res = access (path, W_OK) ? 9 : 0;
++        delete [] dirname;
++      }
++    }
++  }
++  return !res;
++}
++
++// These are signatures for supported compressed file types.  In 2018 the
++// SAT Competition was running on StarExec and used internally 'bzip2'
++// compressed files, but gave them uncompressed to the solver using exactly
++// the same path (with '.bz2' suffix).  Then 'CaDiCaL' tried to read that
++// actually uncompressed file through 'bzip2', which of course failed.  Now
++// we double check and fall back to reading the file as is, if the signature
++// does not match after issuing a warning.
++
++static int xzsig[] = { 0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00, 0x00, EOF };
++static int bz2sig[] = { 0x42, 0x5A, 0x68, EOF };
++static int gzsig[] = { 0x1F, 0x8B, EOF };
++static int sig7z[] = { 0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C, EOF };
++static int lzmasig[] = { 0x5D, 0x00, 0x00, 0x80, 0x00, EOF };
++
++bool File::match (Internal * internal,
++                  const char * path, const int * sig) {
++  assert (path);
++  FILE * tmp = fopen (path, "r");
++  if (!tmp) {
++    WARNING ("failed to open '%s' to check signature", path);
++    return false;
++  }
++  bool res = true;
++  for (const int *p = sig; res && (*p != EOF); p++)
++    res = (cadical_getc_unlocked (tmp) == *p);
++  fclose (tmp);
++  if (!res) WARNING ("file type signature check for '%s' failed", path);
++  return res;
++}
++
++size_t File::size (const char * path) {
++  struct stat buf;
++  if (stat (path, &buf)) return 0;
++  return (size_t) buf.st_size;
++}
++
++// Check that 'prg' is in the 'PATH' and thus can be found if executed
++// through 'popen'.
++
++char * File::find (const char * prg) {
++  size_t prglen = strlen (prg);
++  const char * c = getenv ("PATH");
++  if (!c) return 0;;
++  size_t len = strlen (c);
++  char * e = new char[len + 1];
++  strcpy (e, c);
++  char * res = 0;
++  for (char * p = e, * q; !res && p < e + len; p = q) {
++    for (q = p; *q && *q != ':'; q++)
++      ;
++    *q++ = 0;
++    size_t pathlen = (q - p) + prglen;
++    char * path = new char [pathlen + 1];
++    sprintf (path, "%s/%s", p, prg);
++    assert (strlen (path) == pathlen);
++    if (exists (path)) res = path;
++    else delete [] path;
++  }
++  delete [] e;
++  return res;
++}
++
++/*------------------------------------------------------------------------*/
++
++FILE * File::open_file (Internal * internal, const char * path,
++                                             const char * mode) {
++  (void) internal;
++  return fopen (path, mode);
++}
++
++FILE * File::read_file (Internal * internal, const char * path) {
++  MSG ("opening file to read '%s'", path);
++  return open_file (internal, path, "r");
++}
++
++FILE * File::write_file (Internal * internal, const char * path) {
++  MSG ("opening file to write '%s'", path);
++  return open_file (internal, path, "w");
++}
++
++/*------------------------------------------------------------------------*/
++
++FILE * File::open_pipe (Internal * internal,
++                        const char * fmt, const char * path,
++                        const char * mode) {
++#ifdef QUIET
++  (void) internal;
++#endif
++  size_t prglen = 0;
++  while (fmt[prglen] && fmt[prglen] != ' ') prglen++;
++  char * prg = new char [prglen + 1];
++  strncpy (prg, fmt, prglen);
++  prg[prglen] = 0;
++  char * found = find (prg);
++  if (found) MSG ("found '%s' in path for '%s'", found, prg);
++  if (!found) MSG ("did not find '%s' in path", prg);
++  delete [] prg;
++  if (!found) return 0;
++  delete [] found;
++  char * cmd = new char [strlen (fmt) + strlen (path)];
++  sprintf (cmd, fmt, path);
++  FILE * res = popen (cmd, mode);
++  delete [] cmd;
++  return res;
++}
++
++FILE * File::read_pipe (Internal * internal,
++                        const char * fmt,
++                        const int * sig,
++                        const char * path) {
++  if (!File::exists (path)) {
++    LOG ("file '%s' does not exist", path);
++    return 0;
++  }
++  LOG ("file '%s' exists", path);
++  if (sig && !File::match (internal, path, sig)) return 0;
++  LOG ("file '%s' matches signature for '%s'", path, fmt);
++  MSG ("opening pipe to read '%s'", path);
++  return open_pipe (internal, fmt, path, "r");
++}
++
++FILE * File::write_pipe (Internal * internal,
++                         const char * fmt, const char * path) {
++  MSG ("opening pipe to write '%s'", path);
++  return open_pipe (internal, fmt, path, "w");
++}
++
++/*------------------------------------------------------------------------*/
++
++File * File::read (Internal * internal, FILE * f, const char * n) {
++  return new File (internal, false, 0, f, n);
++}
++
++File * File::write (Internal * internal, FILE * f, const char * n) {
++  return new File (internal, true, 0, f, n);
++}
++
++File * File::read (Internal * internal, const char * path) {
++  FILE * file;
++  int close_input = 2;
++  if (has_suffix (path, ".xz")) {
++    file = read_pipe (internal, "xz -c -d %s", xzsig, path);
++    if (!file) goto READ_FILE;
++  } else if (has_suffix (path, ".lzma")) {
++    file = read_pipe (internal, "lzma -c -d %s", lzmasig, path);
++    if (!file) goto READ_FILE;
++  } else if (has_suffix (path, ".bz2")) {
++    file = read_pipe (internal, "bzip2 -c -d %s", bz2sig, path);
++    if (!file) goto READ_FILE;
++  } else if (has_suffix (path, ".gz")) {
++    file = read_pipe (internal, "gzip -c -d %s", gzsig, path);
++    if (!file) goto READ_FILE;
++  } else if (has_suffix (path, ".7z")) {
++    file = read_pipe (internal, "7z x -so %s 2>/dev/null", sig7z, path);
++    if (!file) goto READ_FILE;
++  } else {
++READ_FILE:
++    file = read_file (internal, path);
++    close_input = 1;
++  }
++
++  return file ? new File (internal, false, close_input, file, path) : 0;
++}
++
++File * File::write (Internal * internal, const char * path) {
++  FILE * file;
++  int close_input = 2;
++  if (has_suffix (path, ".xz"))
++    file = write_pipe (internal, "xz -c > %s", path);
++  else if (has_suffix (path, ".bz2"))
++    file = write_pipe (internal, "bzip2 -c > %s", path);
++  else if (has_suffix (path, ".gz"))
++    file = write_pipe (internal, "gzip -c > %s", path);
++  else if (has_suffix (path, ".7z"))
++    file = write_pipe (internal,
++                       "7z a -an -txz -si -so > %s 2>/dev/null", path);
++  else
++    file = write_file (internal, path), close_input = 1;
++
++  return file ? new File (internal, true, close_input, file, path) : 0;
++}
++
++void File::close () {
++  assert (file);
++  if (close_file == 0) {
++    VERBOSE (1, "disconnecting from '%s'", name ());
++  }
++  if (close_file == 1) {
++    VERBOSE (1, "closing file '%s'", name ());
++    fclose (file);
++  }
++  if (close_file == 2) {
++    VERBOSE (1, "closing pipe command on '%s'", name ());
++    pclose (file);
++  }
++
++  file = 0;     // mark as closed
++
++#ifndef QUIET
++  if (internal->opts.verbose > 1) return;
++  double mb = bytes () / (double) (1 << 20);
++  if (writing)
++    VERBOSE (1, "after writing %ld bytes %.1f MB", bytes (), mb);
++  else
++    VERBOSE (1, "after reading %ld bytes %.1f MB", bytes (), mb);
++  if (close_file == 2) {
++    long s = size (name ());
++    double mb = s / (double) (1<<20);
++    if (writing)
++      VERBOSE (1, "deflated to %ld bytes %.1f MB by factor %.2f "
++        "(%.2f%% compression)",
++        s, mb, relative (bytes (), s), percent (bytes () - s, bytes ()));
++    else
++      VERBOSE (1, "inflated from %ld bytes %.1f MB by factor %.2f "
++        "(%.2f%% compression)",
++        s, mb, relative (bytes (), s), percent (bytes () - s, bytes ()));
++  }
++#endif
++}
++
++File::~File () { if (file) close (); }
++
++}
+diff -Naur solvers/cadical/format.hpp solvers/cdc/format.hpp
+--- solvers/cadical/format.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/format.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -11,7 +11,7 @@
+ 
+ class Format {
+   char * buffer;
+-  int64_t count, size;
++  long count, size;
+   void enlarge ();
+   void push_char (char);
+   void push_string (const char *);
+diff -Naur solvers/cadical/instantiate.cpp solvers/cdc/instantiate.cpp
+--- solvers/cadical/instantiate.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/instantiate.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -59,7 +59,7 @@
+ 
+ bool Internal::inst_propagate () {      // Adapted from 'propagate'.
+   START (propagate);
+-  int64_t before = propagated;
++  long before = propagated;
+   bool ok = true;
+   while (ok && propagated != trail.size ()) {
+     const int lit = -trail[propagated++];
+@@ -124,7 +124,7 @@
+       ws.resize (j - ws.begin ());
+     }
+   }
+-  int64_t delta = propagated - before;
++  long delta = propagated - before;
+   stats.propagations.instantiate += delta;
+   STOP (propagate);
+   return ok;
+@@ -196,9 +196,9 @@
+   START (instantiate);
+   stats.instrounds++;
+ #ifndef QUIET
+-  const int64_t candidates = instantiator.candidates.size ();
++  const long candidates = instantiator.candidates.size ();
+ #endif
+-  int64_t instantiated = 0, tried = 0;
++  long instantiated = 0, tried = 0;
+   init_watches ();
+   connect_watches ();
+   if (propagated < trail.size ()) {
+@@ -223,13 +223,13 @@
+       "%zd negative occurrences in", cand.lit, cand.negoccs);
+     if (!instantiate_candidate (cand.lit, cand.clause)) continue;
+     instantiated++;
+-    VERBOSE (2, "instantiation %" PRId64 " (%.1f%%) succeeded (%.1f%%) with "
++    VERBOSE (2, "instantiation %ld (%.1f%%) succeeded (%.1f%%) with "
+       "%zd negative occurrences in size %d clause",
+       tried, percent (tried, candidates),
+       percent (instantiated, tried), cand.negoccs, cand.size);
+   }
+   PHASE ("instantiate", stats.instrounds,
+-    "instantiated %" PRId64 " candidate successfully out of %" PRId64 " tried %.1f%%",
++    "instantiated %ld candidate successfully out of %ld tried %.1f%%",
+     instantiated, tried, percent (instantiated, tried));
+   report ('I', !instantiated);
+   reset_watches ();
+diff -Naur solvers/cadical/internal.cpp solvers/cdc/internal.cpp
+--- solvers/cadical/internal.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/internal.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -114,7 +114,7 @@
+   assert (!level);
+   size_t new_vsize = vsize ? 2*vsize : 1 + (size_t) new_max_var;
+   while (new_vsize <= (size_t) new_max_var) new_vsize *= 2;
+-  LOG ("enlarge internal size from %zd to new size %zd", vsize, new_vsize);
++  LOG ("enlarge internal size from %ld to new size %ld", vsize, new_vsize);
+   // Ordered in the size of allocated memory (larger block first).
+   enlarge_only (wtab, 2*new_vsize);
+   enlarge_only (vtab, new_vsize);
+@@ -231,7 +231,7 @@
+     mode = "initial";
+   }
+   (void) mode;
+-  LOG ("%s reduce limit %" PRId64 " after %" PRId64 " conflicts",
++  LOG ("%s reduce limit %ld after %ld conflicts",
+     mode, lim.reduce, lim.reduce - stats.conflicts);
+ 
+   /*----------------------------------------------------------------------*/
+@@ -243,7 +243,7 @@
+     mode = "initial";
+   }
+   (void) mode;
+-  LOG ("%s flush limit %" PRId64 " interval %" PRId64 "",
++  LOG ("%s flush limit %ld interval %ld",
+     mode, lim.flush, inc.flush);
+ 
+   /*----------------------------------------------------------------------*/
+@@ -254,7 +254,7 @@
+     mode = "initial";
+   }
+   (void) mode;
+-  LOG ("%s subsume limit %" PRId64 " after %" PRId64 " conflicts",
++  LOG ("%s subsume limit %ld after %ld conflicts",
+     mode, lim.subsume, lim.subsume - stats.conflicts);
+ 
+   /*----------------------------------------------------------------------*/
+@@ -266,13 +266,13 @@
+     mode = "initial";
+   }
+   (void) mode;
+-  LOG ("%s elim limit %" PRId64 " after %" PRId64 " conflicts",
++  LOG ("%s elim limit %ld after %ld conflicts",
+     mode, lim.elim, lim.elim - stats.conflicts);
+ 
+   // Initialize and reset elimination bounds in any case.
+ 
+   lim.elimbound = opts.elimboundmin;
+-  LOG ("elimination bound %" PRId64 "", lim.elimbound);
++  LOG ("elimination bound %ld", lim.elimbound);
+ 
+   /*----------------------------------------------------------------------*/
+ 
+@@ -282,7 +282,7 @@
+     mode = "initial";
+   }
+   (void) mode;
+-  LOG ("%s probe limit %" PRId64 " after %" PRId64 " conflicts",
++  LOG ("%s probe limit %ld after %ld conflicts",
+     mode, lim.probe, lim.probe - stats.conflicts);
+ 
+   /*----------------------------------------------------------------------*/
+@@ -292,7 +292,7 @@
+     last.ternary.marked = -1;   // TODO explain why this is necessary.
+ 
+     lim.compact = stats.conflicts + opts.compactint;
+-    LOG ("initial compact limit %" PRId64 " increment %" PRId64 "",
++    LOG ("initial compact limit %ld increment %ld",
+       lim.compact, lim.compact - stats.conflicts);
+   }
+ 
+@@ -302,7 +302,7 @@
+ 
+   lim.rephase = stats.conflicts + opts.rephaseint;
+   lim.rephased[0] = lim.rephased[1] = 0;
+-  LOG ("new rephase limit %" PRId64 " after %" PRId64 " conflicts",
++  LOG ("new rephase limit %ld after %ld conflicts",
+     lim.rephase, lim.rephase - stats.conflicts);
+ 
+   /*----------------------------------------------------------------------*/
+@@ -310,7 +310,7 @@
+   // Initialize or reset 'restart' limits in any case.
+ 
+   lim.restart = stats.conflicts + opts.restartint;
+-  LOG ("new restart limit %" PRId64 " increment %" PRId64 "",
++  LOG ("new restart limit %ld increment %ld",
+     lim.restart, lim.restart - stats.conflicts);
+ 
+   /*----------------------------------------------------------------------*/
+@@ -338,7 +338,7 @@
+ 
+   inc.stabilize = opts.stabilizeint;
+   lim.stabilize = stats.conflicts + inc.stabilize;
+-  LOG ("new stabilize limit %" PRId64 " after %" PRId64 " conflicts",
++  LOG ("new stabilize limit %ld after %ld conflicts",
+     lim.stabilize, inc.stabilize);
+ 
+   if (opts.stabilize && opts.reluctant) {
+@@ -356,7 +356,7 @@
+     LOG ("no limit on conflicts");
+   } else {
+     lim.conflicts = stats.conflicts + inc.conflicts;
+-    LOG ("conflict limit after %" PRId64 " conflicts at %" PRId64 " conflicts",
++    LOG ("conflict limit after %ld conflicts at %ld conflicts",
+       inc.conflicts, lim.conflicts);
+   }
+ 
+@@ -365,7 +365,7 @@
+     LOG ("no limit on decisions");
+   } else {
+     lim.decisions = stats.decisions + inc.decisions;
+-    LOG ("conflict limit after %" PRId64 " decisions at %" PRId64 " decisions",
++    LOG ("conflict limit after %ld decisions at %ld decisions",
+       inc.decisions, lim.decisions);
+   }
+ 
+@@ -401,14 +401,14 @@
+   if (unsat) return false;
+   if (!max_var) return false;
+   START (preprocess);
+-  struct { int64_t vars, clauses; } before, after;
++  struct { int vars; long clauses; } before, after;
+   before.vars = active ();
+   before.clauses = stats.current.irredundant;
+   stats.preprocessings++;
+   assert (!preprocessing);
+   preprocessing = true;
+   PHASE ("preprocessing", stats.preprocessings,
+-    "starting round %" PRId64 " with %d variables and %" PRId64 " clauses",
++    "starting round %d with %d variables and %ld clauses",
+     round, before.vars, before.clauses);
+   int old_elimbound = lim.elimbound;
+   if (opts.probe) probe (false);
+@@ -418,7 +418,7 @@
+   assert (preprocessing);
+   preprocessing = false;
+   PHASE ("preprocessing", stats.preprocessings,
+-    "finished round %d with %" PRId64 " variables and %" PRId64 " clauses",
++    "finished round %d with %d variables and %ld clauses",
+     round, after.vars, after.clauses);
+   STOP (preprocess);
+   report ('P');
+@@ -498,7 +498,7 @@
+ 
+   // Determine propagation limit quadratically scaled with rounds.
+   //
+-  int64_t limit = opts.walkmineff;
++  long limit = opts.walkmineff;
+   limit *= round;
+   if (LONG_MAX / round > limit) limit *= round;
+   else limit = LONG_MAX;
+@@ -608,12 +608,12 @@
+ }
+ 
+ void Internal::dump () {
+-  int64_t m = assumptions.size ();
++  long m = assumptions.size ();
+   for (int idx = 1; idx <= max_var; idx++)
+     if (fixed (idx)) m++;
+   for (const auto & c : clauses)
+     if (!c->garbage) m++;
+-  printf ("p cnf %d %" PRId64 "\n", max_var, m);
++  printf ("p cnf %d %ld\n", max_var, m);
+   for (int idx = 1; idx <= max_var; idx++) {
+     const int tmp = fixed (idx);
+     if (tmp) printf ("%d 0\n", tmp < 0 ? -idx : idx);
+diff -Naur solvers/cadical/internal.hpp solvers/cdc/internal.hpp
+--- solvers/cadical/internal.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/internal.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -13,7 +13,6 @@
+ #include <cstring>
+ #include <cctype>
+ #include <csignal>
+-#include <cinttypes>
+ 
+ // Less common 'C' header.
+ 
+@@ -165,11 +164,11 @@
+   vector<Var> vtab;             // variable table [1,max_var]
+   Links links;                  // table of links for decision queue
+   vector<Flags> ftab;           // variable and literal flags
+-  vector<int64_t> btab;         // enqueue time stamps for queue
++  vector<long> btab;            // enqueue time stamps for queue
+   vector<Occs> otab;            // table of occurrences for all literals
+   vector<int> ptab;             // table for caching probing attempts
+-  vector<int64_t> ntab;         // number of one-sided occurrences table
+-  vector<int64_t> ntab2;        // number of two-sided occurrences table
++  vector<long> ntab;            // number of one-sided occurrences table
++  vector<long> ntab2;           // number of two-sided occurrences table
+   vector<Bins> big;             // binary implication graph
+   vector<Watches> wtab;         // table of watches for all literals
+   Clause * conflict;            // set in 'propagation', reset in 'analyze'
+@@ -257,9 +256,9 @@
+ 
+   // Currently remaining active redundant and irredundant clauses.
+ 
+-  int64_t redundant () const { return stats.current.redundant; }
++  long redundant () const { return stats.current.redundant; }
+ 
+-  int64_t irredundant () const { return stats.current.irredundant; }
++  long irredundant () const { return stats.current.irredundant; }
+ 
+   double clause_variable_ratio () const {
+     return relative (irredundant (), active ());
+@@ -298,7 +297,7 @@
+   Var & var (int lit)         { return vtab[vidx (lit)]; }
+   Link & link (int lit)       { return links[vidx (lit)]; }
+   Flags & flags (int lit)     { return ftab[vidx (lit)]; }
+-  int64_t & bumped (int lit) { return btab[vidx (lit)]; }
++  long & bumped (int lit)     { return btab[vidx (lit)]; }
+   int & propfixed (int lit)   { return ptab[vlit (lit)]; }
+   double & score (int lit)    { return stab[vidx (lit)]; }
+ 
+@@ -309,8 +308,8 @@
+ 
+   Bins & bins (int lit) { assert (!big.empty ()); return big[vlit (lit)]; }
+   Occs & occs (int lit) { assert (!otab.empty ()); return otab[vlit (lit)]; }
+-  int64_t & noccs (int lit) { assert (!ntab.empty ()); return ntab[vlit (lit)]; }
+-  int64_t & noccs2 (int lit) { assert (!ntab2.empty ()); return ntab2[vidx (lit)]; }
++  long & noccs (int lit) { assert (!ntab.empty ()); return ntab[vlit (lit)]; }
++  long & noccs2 (int lit) { assert (!ntab2.empty ()); return ntab2[vidx (lit)]; }
+   Watches & watches (int lit) { assert (!wtab.empty ()); return wtab[vlit (lit)]; }
+ 
+   // Variable bumping (through exponential VSIDS).
+@@ -400,7 +399,7 @@
+     assert (0 < idx), assert (idx <= max_var);
+     queue.unassigned = idx;
+     queue.bumped = btab[idx];
+-    LOG ("queue unassigned now %d bumped %" PRId64 "", idx, btab[idx]);
++    LOG ("queue unassigned now %d bumped %ld", idx, btab[idx]);
+   }
+ 
+   void bump_queue (int idx);
+@@ -582,7 +581,7 @@
+   bool cover_propagate_asymmetric (int lit, Clause * ignore, Coveror &);
+   bool cover_propagate_covered (int lit, Coveror &);
+   bool cover_clause (Clause * c, Coveror &);
+-  int64_t cover_round ();
++  long cover_round ();
+   bool cover ();
+ 
+   // Strengthening through vivification in 'vivify.cpp'.
+@@ -597,7 +596,7 @@
+   void vivify_assume (int lit);
+   bool vivify_propagate ();
+   void vivify_clause (Vivifier &, Clause * candidate);
+-  void vivify_round (bool redundant_mode, int64_t delta);
++  void vivify_round (bool redundant_mode, long delta);
+   void vivify ();
+ 
+   // Compacting (shrinking internal variable tables) in 'compact.cpp'
+@@ -777,9 +776,9 @@
+   bool ternary_find_ternary_clause (int, int, int);
+   Clause * new_hyper_ternary_resolved_clause (bool red);
+   bool hyper_ternary_resolve (Clause *, int, Clause *);
+-  void ternary_lit (int pivot, int64_t & steps, int64_t & htrs);
+-  void ternary_idx (int idx, int64_t & steps, int64_t & htrs);
+-  bool ternary_round (int64_t & steps, int64_t & htrs);
++  void ternary_lit (int pivot, long & steps, long & htrs);
++  void ternary_idx (int idx, long & steps, long & htrs);
++  bool ternary_round (long & steps, long & htrs);
+   bool ternary ();
+ 
+   // Probing in 'probe.cpp'.
+@@ -808,7 +807,7 @@
+   unsigned walk_break_value (int lit);
+   int walk_pick_lit (Walker &, Clause *);
+   void walk_flip_lit (Walker &, int lit);
+-  int walk_round (int64_t limit, bool prev);
++  int walk_round (long limit, bool prev);
+   void walk ();
+ 
+   // Detect strongly connected components in the binary implication graph
+@@ -1042,7 +1041,7 @@
+   //
+   //  c [<phase>-<count>] ...
+   //
+-  void phase (const char * phase, int64_t count, const char *, ...);
++  void phase (const char * phase, long count, const char *, ...);
+ #endif
+ 
+   // Print error messages which are really always printed (even if 'quiet'
+diff -Naur solvers/cadical/limit.cpp solvers/cdc/limit.cpp
+--- solvers/cadical/limit.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/limit.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -34,7 +34,7 @@
+       !localsearching &&
+       lim.conflicts >= 0 &&
+       stats.conflicts >= lim.conflicts) {
+-    LOG ("conflict limit %" PRId64 " reached", lim.conflicts);
++    LOG ("conflict limit %ld reached", lim.conflicts);
+     return true;
+   }
+ 
+@@ -42,7 +42,7 @@
+       !localsearching &&
+       lim.decisions >= 0 &&
+       stats.decisions >= lim.decisions) {
+-    LOG ("decision limit %" PRId64 " reached", lim.decisions);
++    LOG ("decision limit %ld reached", lim.decisions);
+     return true;
+   }
+ 
+diff -Naur solvers/cadical/limit.hpp solvers/cdc/limit.hpp
+--- solvers/cadical/limit.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/limit.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -7,53 +7,53 @@
+ 
+   bool initialized;
+ 
+-  int64_t conflicts;        // conflict limit if non-negative
+-  int64_t decisions;        // decision limit if non-negative
+-  int64_t preprocessing;   // limit on preprocessing rounds
+-  int64_t localsearch;     // limit on local search rounds
+-
+-  int64_t compact;         // conflict limit for next 'compact'
+-  int64_t elim;            // conflict limit for next 'elim'
+-  int64_t flush;           // conflict limit for next 'flush'
+-  int64_t probe;           // conflict limit for next 'probe'
+-  int64_t reduce;          // conflict limit for next 'reduce'
+-  int64_t rephase;         // conflict limit for next 'rephase'
+-  int64_t report;          // report limit for header
+-  int64_t restart;         // conflict limit for next 'restart'
+-  int64_t stabilize;       // conflict limit for next 'stabilize'
+-  int64_t subsume;         // conflict limit for next 'subsume'
++  long conflicts;       // conflict limit if non-negative
++  long decisions;       // decision limit if non-negative
++  long preprocessing;   // limit on preprocessing rounds
++  long localsearch;     // limit on local search rounds
++
++  long compact;         // conflict limit for next 'compact'
++  long elim;            // conflict limit for next 'elim'
++  long flush;           // conflict limit for next 'flush'
++  long probe;           // conflict limit for next 'probe'
++  long reduce;          // conflict limit for next 'reduce'
++  long rephase;         // conflict limit for next 'rephase'
++  long report;          // report limit for header
++  long restart;         // conflict limit for next 'restart'
++  long stabilize;       // conflict limit for next 'stabilize'
++  long subsume;         // conflict limit for next 'subsume'
+ 
+   int keptsize;         // maximum kept size in 'reduce'
+   int keptglue;         // maximum kept glue in 'reduce'
+ 
+   // How often rephased during (1) or out (0) of stabilization.
+   //
+-  int64_t rephased[2];
++  long rephased[2];
+ 
+   // Current elimination bound per eliminated variable.
+   //
+-  int64_t elimbound;
++  long elimbound;
+ 
+   Limit ();
+ };
+ 
+ struct Last {
+-  struct { int64_t propagations; } transred, vivify;
+-  struct { int64_t fixed, subsumephases, marked; } elim;
+-  struct { int64_t propagations, reductions; } probe;
+-  struct { int64_t conflicts; } reduce, rephase;
+-  struct { int64_t marked; } ternary;
+-  struct { int64_t fixed; } collect;
++  struct { long propagations; } transred, vivify;
++  struct { long fixed, subsumephases, marked; } elim;
++  struct { long propagations, reductions; } probe;
++  struct { long conflicts; } reduce, rephase;
++  struct { long marked; } ternary;
++  struct { long fixed; } collect;
+   Last ();
+ };
+ 
+ struct Inc {
+-  int64_t flush;           // flushing interval in terms of conflicts
+-  int64_t stabilize;       // stabilization interval increment
+-  int64_t conflicts;       // next conflict limit if non-negative
+-  int64_t decisions;       // next decision limit if non-negative
+-  int64_t preprocessing;   // next preprocessing limit if non-negative
+-  int64_t localsearch;     // next local search limit if non-negative
++  long flush;           // flushing interval in terms of conflicts
++  long stabilize;       // stabilization interval increment
++  long conflicts;       // next conflict limit if non-negative
++  long decisions;       // next decision limit if non-negative
++  long preprocessing;   // next preprocessing limit if non-negative
++  long localsearch;     // next local search limit if non-negative
+   Inc ();
+ };
+ 
+diff -Naur solvers/cadical/logging.cpp solvers/cdc/logging.cpp
+--- solvers/cadical/logging.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/logging.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -52,7 +52,7 @@
+   if (c) {
+     if (c->redundant) printf (" glue %d redundant", c->glue);
+     else printf (" irredundant");
+-    printf (" size %d clause[%" PRId64 "]", c->size, c->id);
++    printf (" size %d clause[%ld]", c->size, c->id);
+     if (c->moved) printf (" ... (moved)");
+     else {
+       if (internal->opts.logsort) {
+diff -Naur solvers/cadical/make-build-header.sh solvers/cdc/make-build-header.sh
+--- solvers/cadical/make-build-header.sh	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/make-build-header.sh	2019-07-11 20:27:30.000000000 +1000
+@@ -19,17 +19,9 @@
+ }
+ 
+ #--------------------------------------------------------------------------#
+-
+-[ ! -f VERSION -a ! -f ../VERSION ] && \
+-die "needs to be called from build sub-directory"
+-
+-[ -f makefile ] || \
+-warning "could not find 'makefile'"
+-
+-#--------------------------------------------------------------------------#
+ # The version.
+ #
+-VERSION="`cat ../VERSION`"
++VERSION="`cat VERSION`"
+ if [ x"$VERSION" = x ]
+ then
+   warning "could not determine 'VERSION'"
+@@ -40,7 +32,7 @@
+ #--------------------------------------------------------------------------#
+ # The unique GIT hash.
+ #
+-IDENTIFIER="`../scripts/get-git-id.sh`"
++IDENTIFIER="`./get-git-id.sh`"
+ if [ x"$IDENTIFIER" = x ]
+ then
+   warning "could not determine 'IDENTIFIER' (git id)"
+@@ -51,9 +43,15 @@
+ #--------------------------------------------------------------------------#
+ # C++ compiler 'CXX' used in 'makefile'.
+ #
+-COMPILER="`sed -e '/^CXX=/!d' -e 's,^CXX=,,' makefile 2>/dev/null`"
+-case x"$COMPILER" in 
+-  xg++* | xclang++*)
++if [[ "$OSTYPE" == "darwin"* ]]; then
++  SEDMAC=-E
++else
++  SEDMAC=
++fi
++
++  COMPILER="`sed $SEDMAC -e '/^CXX[ \t]+:=/!d' -e 's,^CXX[ \t]+:= ,,' Makefile 2>/dev/null`"
++case x"$COMPILER" in
++  xc++* | xg++* | xclang++*)
+     COMPILER="`$COMPILER --version 2>/dev/null|head -1`";;
+   *) COMPILER="";;
+ esac
+@@ -67,7 +65,7 @@
+ #--------------------------------------------------------------------------#
+ # C++ compiler flags 'CXXFLAGS' used in 'makefile'.
+ #
+-FLAGS="`sed -e '/^CXXFLAGS=/!d' -e 's,^CXXFLAGS=,,' makefile 2>/dev/null`"
++FLAGS="`sed $SEDMAC -e '/^CXXFLAGS[ \t]+:=/!d' -e 's,^CXXFLAGS[ \t]+:= ,,' Makefile 2>/dev/null`"
+ if [ x"$FLAGS" = x ]
+ then
+   warning "could not determine 'FLAGS' ('CXXFLAGS')"
+diff -Naur solvers/cadical/message.cpp solvers/cdc/message.cpp
+--- solvers/cadical/message.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/message.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -107,14 +107,14 @@
+ }
+ 
+ void Internal::phase (const char * phase,
+-                      int64_t count, const char * fmt, ...) {
++                      long count, const char * fmt, ...) {
+ #ifdef LOGGING
+   if (!opts.log)
+ #endif
+   if (opts.quiet ||
+       (!force_phase_messages && opts.verbose < 2)) return;
+   print_prefix ();
+-  printf ("[%s-%" PRId64 "] ", phase, count);
++  printf ("[%s-%ld] ", phase, count);
+   va_list ap;
+   va_start (ap, fmt);
+   vprintf (fmt, ap);
+diff -Naur solvers/cadical/minimize.cpp solvers/cdc/minimize.cpp
+--- solvers/cadical/minimize.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/minimize.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -48,7 +48,7 @@
+ struct minimize_trail_positive_rank {
+   Internal * internal;
+   minimize_trail_positive_rank (Internal * s) : internal (s) { }
+-  int operator () (const int & a) const {
++  size_t operator () (const int & a) const {
+     assert (internal->val (a));
+     return internal->var (a).trail;
+   }
+@@ -71,8 +71,7 @@
+   // Sort the literals heuristically along assignment order with the hope to
+   // hit the recursion limit 'opts.minimizedepth' less frequently.
+   //
+-  MSORT (opts.radixsortlim,
+-    clause.begin (), clause.end (),
++  MSORT (clause.begin (), clause.end (),
+     minimize_trail_positive_rank (this), minimize_trail_smaller (this));
+ 
+   assert (minimized.empty ());
+@@ -81,7 +80,7 @@
+   for (; i != end; i++)
+     if (minimize_literal (-*i)) stats.minimized++;
+     else flags (*j++ = *i).keep = true;
+-  LOG ("minimized %zd literals", (size_t)(clause.end () - j));
++  LOG ("minimized %d literals", (long)(clause.end () - j));
+   if (j != end) clause.resize (j - clause.begin ());
+   clear_minimized_literals ();
+   STOP (minimize);
+diff -Naur solvers/cadical/mobical.cpp solvers/cdc/mobical.cpp
+--- solvers/cadical/mobical.cpp	1970-01-01 10:00:00.000000000 +1000
++++ solvers/cdc/mobical.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -0,0 +1,3016 @@
++/*------------------------------------------------------------------------*/
++/* Copyright (C) 2018-2019, Armin Biere, Johannes Kepler University Linz  */
++/*------------------------------------------------------------------------*/
++
++// Model Based Tester for the CaDiCaL SAT Solver Library.
++
++namespace CaDiCaL {
++
++static const char * USAGE =
++"usage: mobical [ <option> ... ] [ <mode> ]\n"
++"\n"
++"where '<option>' can be one of the following:\n"
++"\n"
++"  --help    | -h    print this command line option summary and exit\n"
++"  --version         print CaDiCaL's three character version and exit\n"
++"  --build           print build configuration\n"
++"\n"
++"  -v                increase verbosity\n"
++"  --colors          force colors for both '<stdout>' and '<stderr>'\n"
++"  --no-colors       disable colors if '<stderr>' is connected to terminal\n"
++"  --no-terminal     assume '<stderr>' is not connected to terminal\n"
++"  --no-seeds        do not print seeds in random mode\n"
++"\n"
++"  -<n>              specify the number of solving phases explicitly\n"
++"  --time <seconds>  set time limit per trace (none=0, default=%d)\n"
++"  --space <MB>      set space limit (none=0, default=%d)\n"
++"\n"
++"  --do-not-ignore-resource-limits  consider out-of-time or memory as error\n"
++"\n"
++"  --small           generate small formulas only\n"
++"  --medium          generate medium sized formulas only\n"
++"  --big             generate big formulas only\n"
++"\n"
++"Then '<mode>' is one of these\n"
++"\n"
++"  <seed>            generate and execute trace for given 64-bit seed\n"
++"  <seed>  <output>  generate trace, shrink and write it to file\n"
++"  <input> <output>  read trace, shrink and write it to output file\n"
++"  <input>           read and replay the specified input trace\n"
++"\n"
++"The output trace is not shrunken if it is not failing.  However,\n"
++"before it is written it is executed, unless '--do-not-execute'\n"
++"is specified:\n"
++"\n"
++"  --do-not-execute  just write to '<output>' without execution\n"
++"\n"
++"In order to check memory issues or collect coverage you can force\n"
++"execution within the main process, which however also means that\n"
++"the model based tester aborts as soon a test fails\n"
++"\n"
++"  --do-not-fork     execute all tests in main process directly\n"
++"\n"
++"In order to replay a trace which violates an API contract use\n"
++"\n"
++"  --do-not-enforce-contracts\n"
++"\n"
++"To read from '<stdin>' use '-' as '<input>' and also '-' instead of\n"
++"'<output>' to write to '<stdout>'.\n"
++"\n"
++#ifdef LOGGING
++"As the library is compiled with logging support ('-DLOGGING')\n"
++"one can force to add the 'set log 1' call to the trace with\n"
++"\n"
++"  --log | -l        force low-level logging for detailed debugging\n"
++"\n"
++#endif
++"Implicitly add 'dump' and 'stats' calls to traces:\n"
++"\n"
++"  --dump  | -d      force dumping the CNF before every 'solve'\n"
++"  --stats | -s      force printing statistics after every 'solve'\n"
++"\n"
++"Otherwise if no '<mode>' is specified the default is to generate\n"
++"random traces internally until the execution of a trace fails, which\n"
++"means it produces a non-zero exit code.  Then the trace is rerun and\n"
++"shrunken through delta-debugging to produce a smaller trace.  The\n"
++"shrunken failing trace is written as 'red-<seed>.trace' to the\n"
++"current working directory.\n"
++"\n"
++"The following options disable certain parts of the shrinking algorithm:\n"
++"\n"
++"  --do-not-shrink[-at-all]\n"
++"  --do-not-add-options[-before-shrinking]\n"
++"  --do-not-shrink-phases\n"
++"  --do-not-shrink-clauses\n"
++"  --do-not-shrink-literals\n"
++"  --do-not-shrink-basic[-calls]\n"
++"  --do-not-disable[-options]\n"
++"  --do-not-reduce[[-option]-values]\n"
++"  --do-not-shrink-variables\n"
++"  --do-not-shrink-options\n"
++"\n"
++"The standard mode of using the model based tester is to start it in\n"
++"random testing mode without '<input>', '<seed>' nor '<output>' option.\n"
++"If a failing trace is found it will be shrunken and the resulting trace\n"
++"written to the current working directory.  Then the model based tester\n"
++"can be interrupted and then called again with the produced failing trace\n"
++"as single argument.  This invocation will execute the trace within the\n"
++"same process and thus can directly be investigated with a symbolic\n"
++"debugger such as 'gdb' or maybe first checked for memory issues with\n"
++"'valgrind' or recompilation with memory checking '-fsanitize=address'.\n"
++;
++
++} // end of 'namespace CaDiCaL'.
++
++/*------------------------------------------------------------------------*/
++
++#include "internal.hpp"
++#include "signal.hpp"
++
++/*------------------------------------------------------------------------*/
++
++#include <cstdarg>
++#include <cstring>
++#include <fstream>
++#include <iomanip>
++#include <iostream>
++#include <sstream>
++#include <vector>
++
++/*------------------------------------------------------------------------*/
++
++extern "C" {
++#include <unistd.h>
++}
++
++/*------------------------------------------------------------------------*/
++namespace CaDiCaL {     // All except 'main' below.
++/*------------------------------------------------------------------------*/
++
++using namespace std;
++
++class Reader;
++class Trace;
++
++#define DEFAULT_TIME_LIMIT 10
++#define DEFAULT_SPACE_LIMIT 1024
++
++/*------------------------------------------------------------------------*/
++
++// Options to generate traces.
++
++enum Size { NOSIZE = 0, SMALL = 10, MEDIUM = 30, BIG = 50 };
++
++struct Force {
++  Size size;
++  int phases;
++  Force () : size (NOSIZE), phases (-1) { }
++};
++
++// Options to shrink traces.
++
++struct DoNot
++{
++  bool add;             // add all options before shrinking             'a'
++  struct {
++    bool atall;         // do not shrink anything                       's'
++    bool phases;        // shrink complete incremental solving phases   'p'
++    bool clauses;       // shrink full clauses                          'c'
++    bool literals;      // shrink literals which shrinks                'l'
++    bool basic;         // shrink other basic calls                     'b'
++    bool options;       // shrink option calls                          'o'
++  } shrink;
++  bool disable;         // try to eagerly disable all options           'd'
++  bool map;             // do not map variable indices                  'm'
++  bool reduce;          // reduce option values                         'r'
++  bool execute;         // do not execute trace
++  bool fork;            // do not fork sub-process
++  bool enforce;         // do not enforce contracts on read trace
++  bool seeds;
++  bool ignore_resource_limits;
++
++  DoNot ()
++  {
++    add = false;
++    shrink.atall = false;
++    shrink.phases = false;
++    shrink.clauses = false;
++    shrink.literals = false;
++    shrink.basic = false;
++    shrink.options = false;
++    disable = false;
++    map = false;
++    reduce =  false;
++    seeds = false;
++    ignore_resource_limits = false;
++    execute = false;
++  }
++};
++
++/*------------------------------------------------------------------------*/
++
++struct Shared {
++  long solved;
++  long incremental;
++  long unsat;
++  long sat;
++  long memout;
++  long timeout;
++};
++
++// This is the class for the Mobical application.
++
++class Mobical : public Handler {
++
++  /*----------------------------------------------------------------------*/
++
++  friend struct FailedCall;
++  friend class Reader;
++  friend class Trace;
++  friend struct ValCall;
++  friend struct MeltCall;
++
++  /*----------------------------------------------------------------------*/
++
++  // We have the following modes, where 'RANDOM' mode can not be combined
++  // with any other mode and 'OUTPUT' mode requires that 'SEED' or 'INPUT'
++  // mode is set too, but it is not possible to combine 'SEED' and 'INPUT'.
++
++  enum { RANDOM = 1, SEED = 2, INPUT = 4, OUTPUT = 8 };
++
++  int mode;             // No 'Mode mode' due to 'mode |= ...' below.
++
++  void check_mode_valid ();
++
++  /*----------------------------------------------------------------------*/
++
++  // Global options (set by parsing command line options in 'main').
++
++  DoNot donot;
++  Force force;
++  bool verbose;
++#ifdef LOGGING
++  bool add_set_log_to_true;
++#endif
++  bool add_dump_before_solve;
++  bool add_stats_after_solve;
++
++  /*----------------------------------------------------------------------*/
++
++  bool shrinking;       // In the middle of shrinking.
++  bool running;         // In the middle of running.
++
++  long time_limit;      // in seconds, none if zero
++  long space_limit;     // in MB, none if zero
++
++  Terminal & terminal;
++
++  void header ();               // Print right part of header.
++
++  /*----------------------------------------------------------------------*/
++
++  bool is_unsigned_str (const char *);
++  uint64_t parse_seed (const char *);
++
++  /*----------------------------------------------------------------------*/
++
++  const char * prefix_string () {
++    if (!terminal.colors ()) return "m ";
++    else return "\033[34mm \033[0m";
++  }
++
++  void prefix () { cerr << prefix_string () << flush; }
++
++  void error_prefix () {
++    fflush (stderr);
++    fflush (stdout);
++    terminal.bold ();
++    fputs ("mobical: ", stderr);
++    terminal.normal ();
++  }
++
++  void hline ();                // print horizontal line
++  void empty_line ();           // print empty line
++
++  /*----------------------------------------------------------------------*/
++
++  void summarize (Trace & trace, bool bright = false);
++  void progress (Trace & trace) { notify (trace, -1); }
++
++  string notified;
++
++#ifndef QUIET
++  int progress_counter;
++  double last_progress_time;
++#endif
++
++  void notify (Trace & trace, signed char ch = 0);
++
++  /*----------------------------------------------------------------------*/
++
++  Shared * shared;              // shared among parent and child processes
++
++  long traces;
++  long spurious;
++
++  void print_statistics ();
++
++  /*----------------------------------------------------------------------*/
++
++  void die (const char * fmt, ...);
++  void warning (const char * fmt, ...);
++
++public:
++
++  Mobical ();
++  ~Mobical ();
++
++  void catch_signal (int);      // Implement 'Handler'.
++
++  int main (int, char**);
++};
++
++/*------------------------------------------------------------------------*/
++
++CaDiCaL::Mobical mobical;
++
++/*------------------------------------------------------------------------*/
++
++// The mode invariant of the last comment can be checked with this code:
++
++void Mobical::check_mode_valid () {
++#ifndef NDEBUG
++  assert (mode & (RANDOM | SEED | INPUT | OUTPUT));
++  if (mode & RANDOM) assert (!(mode & SEED));
++  if (mode & RANDOM) assert (!(mode & INPUT));
++  if (mode & RANDOM) assert (!(mode & OUTPUT));
++  if (mode & OUTPUT) assert (mode & (SEED | INPUT));
++  assert (!((mode & SEED) && (mode & INPUT)));
++#endif
++}
++
++/* As a formula this is
++
++  (RANDOM | SEED | INPUT | OUTPUT) &
++  (RANDOM -> !SEED)
++  (RANDOM -> !INPUT) &
++  (RANDOM -> !OUTPUT) &
++  (OUTPUT -> SEED | INPUT) &
++  !(SEED & INPUT)
++
++It has exactly the following 5 out of 16 models
++
++  RANDOM !SEED !INPUT !OUTPUT
++  !RANDOM SEED !INPUT !OUTPUT
++  !RANDOM SEED !INPUT OUTPUT
++  !RANDOM !SEED INPUT OUTPUT
++  !RANDOM !SEED INPUT !OUTPUT
++*/
++
++/*------------------------------------------------------------------------*/
++
++void Mobical::die (const char * fmt, ...) {
++  error_prefix ();
++  terminal.red (true);
++  fputs ("error: ", stderr);
++  terminal.normal ();
++  va_list ap;
++  va_start (ap, fmt);
++  vfprintf (stderr, fmt, ap);
++  va_end (ap);
++  fputc ('\n', stderr);
++  fflush (stderr);
++  terminal.reset ();
++  exit (1);
++}
++
++void Mobical::warning (const char * fmt, ...) {
++  error_prefix ();
++  terminal.yellow ();
++  fputs ("warning: ", stderr);
++  terminal.normal ();
++  va_list ap;
++  va_start (ap, fmt);
++  vfprintf (stderr, fmt, ap);
++  va_end (ap);
++  fputc ('\n', stderr);
++  fflush (stderr);
++}
++
++/*------------------------------------------------------------------------*/
++
++// Abstraction of individual API calls.  The call sequences are assumed to
++// have the following structure
++//
++//   INIT
++//   (SET|ALWAYS)*
++//   ( (ADD|ASSUME|ALWAYS)* [ (SOLVE|SIMPLIFY) (VAL|FAILED|ALWAYS ] )* )*
++//   [ RESET ]
++//
++// where 'ALWAYS' calls as defined below do not change the state.  With
++// the other short-cuts below we can abstract this to
++//
++//   CONFIG* (BEFORE* [ (SOLVE|SIMPLIFY) AFTER* ] )* [ RESET ]
++//
++// If traces are read then they are checked to have this structure.  We also
++// check that 'ADD' sequences always terminate with adding a zero literal
++// before another call is made ('ASSUME | ALWAYS | SOLVE | SIMPLIFY').
++//
++// Furthermore the execution engine (both for read and generated traces)
++// makes sure that additional contract requirements are always met.  For
++// instance 'val' is only executed if the solver is in the 'SATISFIABLE'
++// state, and similar for 'failed', 'melt' etc.
++//
++// If the user wants to understand why a trace obtained through
++// 'CADICAL_API_TRACE' is violating an API contract, then these checks
++// are problematic and can be disabled by using the command line option
++// '--do-not-enforce-contracts'.
++//
++// Note that our model based tester is actually more restrictive and does
++// produce all these possible call sequences.  For instance it first adds
++// all clauses before making assumptions and also does not mix in these
++// 'ALWAYS' calls in all possible ways.
++
++struct Call {
++
++  enum Type {
++
++    INIT        = (1<<0),
++    SET         = (1<<1),
++
++    VARS        = (1<<2),
++    ACTIVE      = (1<<3),
++    REDUNDANT   = (1<<4),
++    IRREDUNDANT = (1<<5),
++    RESERVE     = (1<<6),
++
++    ADD         = (1<<7),
++    ASSUME      = (1<<8),
++
++    SOLVE       = (1<<9),
++    SIMPLIFY    = (1<<10),
++
++    VAL         = (1<<11),
++    FAILED      = (1<<12),
++    FIXED       = (1<<13),
++
++    FREEZE      = (1<<14),
++    FROZEN      = (1<<15),
++    MELT        = (1<<16),
++
++    LIMIT       = (1<<17),
++    OPTIMIZE    = (1<<18),
++
++    DUMP        = (1<<19),
++    STATS       = (1<<20),
++
++    ALWAYS      =
++      VARS | ACTIVE | REDUNDANT | IRREDUNDANT | FREEZE | FROZEN  |
++      MELT | LIMIT  | OPTIMIZE  | DUMP        | STATS  | RESERVE | FIXED,
++
++    CONFIG      = INIT | SET    | ALWAYS,
++    BEFORE      = ADD  | ASSUME | ALWAYS,
++    AFTER       = VAL  | FAILED | ALWAYS,
++
++    RESET       = (1<<21)
++  };
++
++  Type type;            // Explicit typing.
++
++  int arg;              // Argument if necessary.
++  long res;             // Compute result if any.
++  char * name;          // Option name for 'set'.
++  int val;              // Option value for 'set'.
++
++  Call (Type t, int a = 0, int r = 0, const char * o = 0, int v = 0) :
++    type (t), arg (a), res (r), name (o ? strdup (o) : 0), val (v) { }
++
++  virtual ~Call () { if (name) free (name); }
++
++  virtual void execute (Solver * &) = 0;
++  virtual void print (ostream & o) = 0;
++  virtual const char * keyword ()  = 0;
++  virtual Call * copy () = 0;
++};
++
++/*------------------------------------------------------------------------*/
++
++// The model of valid API sequences is rather implicit.  First it is encoded
++// in the random generator, by for instance adding options with 'set' only
++// right after initialization through 'init', which is also enforced during
++// parsing traces, but also in guards for executing certain API calls,
++// marked 'CONTRACT' below.  For instance 'val' is only allowed if the
++// solver is in the 'SATISFIED' state.
++
++struct InitCall : public Call {
++  InitCall () : Call (INIT) { }
++  void execute (Solver * & s) { s = new Solver (); }
++  void print (ostream & o) { o << "init" << endl; }
++  Call * copy () { return new InitCall (); }
++  const char * keyword () { return "init"; }
++};
++
++struct VarsCall : public Call {
++  VarsCall () : Call (VARS) { }
++  void execute (Solver * & s) { res = s->vars (); }
++  void print (ostream & o) { o << "vars" << endl; }
++  Call * copy () { return new VarsCall (); }
++  const char * keyword () { return "vars"; }
++};
++
++struct ActiveCall : public Call {
++  ActiveCall () : Call (ACTIVE) { }
++  void execute (Solver * & s) { res = s->active (); }
++  void print (ostream & o) { o << "active" << endl; }
++  Call * copy () { return new ActiveCall (); }
++  const char * keyword () { return "active"; }
++};
++
++struct RedundantCall : public Call {
++  RedundantCall () : Call (REDUNDANT) { }
++  void execute (Solver * & s) { res = s->redundant (); }
++  void print (ostream & o) { o << "redundant" << endl; }
++  Call * copy () { return new RedundantCall (); }
++  const char * keyword () { return "redundant"; }
++};
++
++struct IrredundantCall : public Call {
++  IrredundantCall () : Call (IRREDUNDANT) { }
++  void execute (Solver * & s) { res = s->irredundant (); }
++  void print (ostream & o) { o << "irredundant" << endl; }
++  Call * copy () { return new IrredundantCall (); }
++  const char * keyword () { return "irredundant"; }
++};
++
++struct ReserveCall : public Call {
++  ReserveCall (int max_var) : Call (RESERVE, max_var) { }
++  void execute (Solver * & s) { s->reserve (arg); }
++  void print (ostream & o) { o << "reserve " << arg << endl; }
++  Call * copy () { return new ReserveCall (arg); }
++  const char * keyword () { return "reserve"; }
++};
++
++struct SetCall : public Call {
++  SetCall (const char * o, int v) : Call (SET, 0, 0, o, v) { }
++  void execute (Solver * & s) { s->set (name, val); }
++  void print (ostream & o) { o << "set " << name << ' ' << val << endl; }
++  Call * copy () { return new SetCall (name, val); }
++  const char * keyword () { return "set"; }
++};
++
++struct LimitCall : public Call {
++  LimitCall (const char * o, int v) : Call (LIMIT, 0, 0, o, v) { }
++  void execute (Solver * & s) { s->limit (name, val); }
++  void print (ostream & o) { o << "limit " << name << ' ' << val << endl; }
++  Call * copy () { return new LimitCall (name, val); }
++  const char * keyword () { return "limit"; }
++};
++
++struct OptimizeCall : public Call {
++  OptimizeCall (int v) : Call (OPTIMIZE, 0, 0, 0, v) { }
++  void execute (Solver * & s) { s->optimize (val); }
++  void print (ostream & o) { o << "optimize " << val << endl; }
++  Call * copy () { return new OptimizeCall (val); }
++  const char * keyword () { return "optimize"; }
++};
++
++struct ResetCall : public Call {
++  ResetCall () : Call (RESET) { }
++  void execute (Solver * & s) { delete s; s = 0; }
++  void print (ostream & o) { o << "reset" << endl; }
++  Call * copy () { return new ResetCall (); }
++  const char * keyword () { return "reset"; }
++};
++
++struct AddCall : public Call {
++  AddCall (int l) : Call (ADD, l) { }
++  void execute (Solver * & s) { s->add (arg); }
++  void print (ostream & o) { o << "add " << arg << endl; }
++  Call * copy () { return new AddCall (arg); }
++  const char * keyword () { return "add"; }
++};
++
++struct AssumeCall : public Call {
++  AssumeCall (int l) : Call (ASSUME, l) { }
++  void execute (Solver * & s) { s->assume (arg); }
++  void print (ostream & o) { o << "assume " << arg << endl; }
++  Call * copy () { return new AssumeCall (arg); }
++  const char * keyword () { return "assume"; }
++};
++
++struct SolveCall : public Call {
++  SolveCall (int r = 0) : Call (SOLVE, 0, r) { }
++  void execute (Solver * & s) { res = s->solve (); }
++  void print (ostream & o) { o << "solve " << res << endl; }
++  Call * copy () { return new SolveCall (res); }
++  const char * keyword () { return "solve"; }
++};
++
++struct SimplifyCall : public Call {
++  SimplifyCall (int rounds, int r = 0) : Call (SIMPLIFY, rounds, r) { }
++  void execute (Solver * & s) { res = s->simplify (arg); }
++  void print (ostream & o) { o << "solve " << arg << " " << res << endl; }
++  Call * copy () { return new SimplifyCall (arg, res); }
++  const char * keyword () { return "simplify"; }
++};
++
++struct ValCall : public Call {
++  ValCall (int l, int r = 0) : Call (VAL, l, r) { }
++  void execute (Solver * & s) {
++    if (mobical.donot.enforce) res = s->val (arg);
++    else if (s->state () == SATISFIED) res = s->val (arg);
++    else res = 0;
++  }
++  void print (ostream & o) { o << "val " << arg << ' ' << res << endl; }
++  Call * copy () { return new ValCall (arg, res); }
++  const char * keyword () { return "val"; }
++};
++
++struct FixedCall : public Call {
++  FixedCall (int l, int r = 0) : Call (FIXED, l, r) { }
++  void execute (Solver * & s) { res = s->fixed (arg); }
++  void print (ostream & o) { o << "fixed " << arg << ' ' << res << endl; }
++  Call * copy () { return new FixedCall (arg, res); }
++  const char * keyword () { return "fixed"; }
++};
++
++struct FailedCall : public Call {
++  FailedCall (int l, int r = 0) : Call (FAILED, l, r) { }
++  void execute (Solver * & s) {
++    if (mobical.donot.enforce) res = s->failed (arg);
++    else if (s->state () == UNSATISFIED) res = s->failed (arg);
++    else res = 0;
++  }
++  void print (ostream & o) { o << "failed " << arg << ' ' << res << endl; }
++  Call * copy () { return new FailedCall (arg, res); }
++  const char * keyword () { return "failed"; }
++};
++
++struct FreezeCall : public Call {
++  FreezeCall (int l) : Call (FREEZE, l) { }
++  void execute (Solver * & s) { s->freeze (arg); }
++  void print (ostream & o) { o << "freeze " << arg << endl; }
++  Call * copy () { return new FreezeCall (arg); }
++  const char * keyword () { return "freeze"; }
++};
++
++struct MeltCall : public Call {
++  MeltCall (int l) : Call (MELT, l) { }
++  void execute (Solver * & s) {
++    if (mobical.donot.enforce || s->frozen (arg))
++      s->melt (arg);
++  }
++  void print (ostream & o) { o << "melt " << arg << endl; }
++  Call * copy () { return new MeltCall (arg); }
++  const char * keyword () { return "melt"; }
++};
++
++struct FrozenCall : public Call {
++  FrozenCall (int l, int r = 0) : Call (FROZEN, l, r) { }
++  void execute (Solver * & s) { res = s->frozen (arg); }
++  void print (ostream & o) { o << "frozen " << arg << ' ' << res << endl; }
++  Call * copy () { return new FrozenCall (arg, res); }
++  const char * keyword () { return "frozen"; }
++};
++
++struct DumpCall : public Call {
++  DumpCall () : Call (DUMP) { }
++  void execute (Solver * & s) { s->dump_cnf (); }
++  void print (ostream & o) { o << "dump" << endl; }
++  Call * copy () { return new DumpCall (); }
++  const char * keyword () { return "dump"; }
++};
++
++struct StatsCall : public Call {
++  StatsCall () : Call (STATS) { }
++  void execute (Solver * & s) { s->statistics (); }
++  void print (ostream & o) { o << "stats" << endl; }
++  Call * copy () { return new StatsCall (); }
++  const char * keyword () { return "stats"; }
++};
++
++/*------------------------------------------------------------------------*/
++
++class Trace {
++
++  long id;
++  uint64_t seed;
++
++  Solver * solver;
++  vector<Call*> calls;
++
++  friend class Reader;
++
++public:
++
++  static long generated;
++  static long executed;
++  static long failed;
++  static long ok;
++
++#define SIGNALS \
++  SIGNAL(SIGINT) \
++  SIGNAL(SIGSEGV) \
++  SIGNAL(SIGABRT) \
++  SIGNAL(SIGTERM) \
++  SIGNAL(SIGBUS) \
++
++#define SIGNAL(SIG) \
++  static void (*old_ ## SIG ## _handler) (int);
++  SIGNALS
++#undef SIGNAL
++  static void child_signal_handler (int);
++  static void init_child_signal_handlers ();
++  static void reset_child_signal_handlers ();
++
++  Trace (long i = 0, uint64_t s = 0) : id (i), seed (s), solver (0) { }
++
++  void clear () {
++    while (!calls.empty ()) {
++      Call * c = calls.back ();
++      delete c;
++      calls.pop_back ();
++    }
++    if (solver) delete solver;
++    solver = 0;
++  }
++
++  ~Trace () { clear (); }
++
++  void push_back (Call * c) { calls.push_back (c); }
++
++  void print (ostream & o) {
++    for (size_t i = 0; i < calls.size (); i++)
++      calls[i]->print (o << i << ' ');
++  }
++
++  void execute () {
++    executed++;
++    bool first = true;
++    for (size_t i = 0; i < calls.size (); i++) {
++      Call * c = calls[i];
++      if (mobical.shared &&
++          (c->type == Call::SOLVE || c->type == Call::SIMPLIFY)) {
++        mobical.shared->solved++;
++        if (first) first = false;
++        else mobical.shared->incremental++;
++        c->execute (solver);
++        if (c->res == 10) mobical.shared->sat++;
++        if (c->res == 20) mobical.shared->unsat++;
++      } else c->execute (solver);
++    }
++  }
++
++  int vars () {
++    int res = 0;
++    for (size_t i = 0; i < calls.size (); i++) {
++      Call * c = calls[i];
++      int tmp = abs (c->arg);
++      if (tmp > res) res = tmp;
++    }
++    return res;
++  }
++
++  long clauses () {
++    long res = 0;
++    for (size_t i = 0; i < calls.size (); i++) {
++      Call * c = calls[i];
++      if (c->type == Call::ADD && !c->arg) res++;
++    }
++    return res;
++  }
++
++  long literals () {
++    long res = 0;
++    for (size_t i = 0; i < calls.size (); i++) {
++      Call * c = calls[i];
++      if (c->type == Call::ADD && c->arg) res++;
++    }
++    return res;
++  }
++
++  long phases () {
++    long res = 0;
++    bool last = true;
++    for (size_t i = 0; i < calls.size (); i++) {
++      Call * c = calls[i];
++      if (last &&
++          c->type != Call::VAL &&
++          c->type != Call::FAILED &&
++          c->type != Call::FROZEN &&
++          c->type != Call::RESET) res++, last = false;
++      if (c->type == Call::SOLVE ||
++          c->type == Call::SIMPLIFY) last = true;
++    }
++    return res;
++  }
++
++  size_t size () { return calls.size (); }
++  Call * operator[] (size_t i) { return calls[i]; }
++
++  void generate (uint64_t id, uint64_t seed);
++
++  int fork_and_execute ();
++  void shrink (int expected);
++
++  void write_prefixed_seed (const char * prefix);
++  void write_path (const char * path);
++
++  static bool ignored_option (const char * name);
++  bool ignore_option (const char *, int max_var);
++  long option_high_value (const char *, long def, long lo, long hi);
++
++private:
++
++  void notify (char ch = 0) { mobical.notify (*this, ch); }
++  void progress () { mobical.progress (*this); }
++
++  struct Segment {
++    size_t lo, hi;
++    Segment (size_t l, size_t h) : lo (l), hi (h)
++      { assert (0 < l), assert (l < h); }
++  };
++
++  typedef vector<Segment> Segments;
++  bool shrink_segments (Segments &, int expected);
++
++  void add_options (int expected);
++  bool shrink_phases (int expected);
++  bool shrink_clauses (int expected);
++  bool shrink_literals (int expected);
++  bool shrink_basic (int expected);
++  bool shrink_disable (int expected);
++  bool reduce_values (int expected);
++  void map_variables (int expected);
++  void shrink_options (int expected);
++
++  size_t first_option ();
++  size_t last_option ();
++
++  Call * find_option_by_prefix (const char * name);
++  Call * find_option_by_name (const char * name);
++
++  void generate_options (Random &, Size);
++  void generate_queries (Random &);
++  void generate_reserve (Random &, int vars);
++  void generate_clause (Random &, int minvars, int maxvars, int uniform);
++  void generate_assume (Random &, int vars);
++  void generate_values (Random &, int vars);
++  void generate_frozen (Random &, int vars);
++  void generate_failed (Random &, int vars);
++  void generate_freeze (Random &, int vars);
++  void generate_melt (Random &);
++
++  void generate_limits (Random &);
++};
++
++/*------------------------------------------------------------------------*/
++
++class Reader {
++
++  Mobical & mobical;
++  Trace & trace;
++
++  const char * path;
++  FILE * file;
++  int lineno;
++  bool close;
++
++  int next () { return getc (file); }
++
++  void error (const char * fmt, ...);
++
++public:
++
++  Reader (Mobical & m, Trace & t, const char * p)
++  :
++    mobical (m), trace (t), lineno (1)
++  {
++    assert (p);
++    if (!strcmp (p, "-")) path = "<stdin>", file = stdin, close = false;
++    else if (!(file = fopen (p, "r")))
++      mobical.die ("can not read '%s'", p);
++    else path = p, close = true;
++  }
++
++  ~Reader () { if (close) fclose (file); }
++
++  void parse ();
++};
++
++/*------------------------------------------------------------------------*/
++
++static bool has_prefix (const char * str, const char * prefix) {
++  for (const char * p = str, * q = prefix; *q; p++, q++)
++    if (*p != *q)
++      return false;
++  return true;
++}
++
++static bool disabled_if_not_simplifying (const char * name) {
++  if (has_prefix (name, "block")) return true;
++  if (has_prefix (name, "compact")) return true;
++  if (has_prefix (name, "decompose")) return true;
++  if (has_prefix (name, "elim")) return true;
++  if (has_prefix (name, "inprocessing")) return true;
++  if (has_prefix (name, "probe")) return true;
++  if (has_prefix (name, "preprocessing")) return true;
++  if (has_prefix (name, "subsume")) return true;
++  if (has_prefix (name, "transred")) return true;
++  if (has_prefix (name, "vivify")) return true;
++  return false;
++}
++
++size_t Trace::first_option () {
++  size_t res;
++  for (res = 0; res < size (); res++)
++    if (calls[res]->type == Call::SET) return res;
++  return res;
++}
++
++size_t Trace::last_option () {
++  size_t res;
++  for (res = 0; res < size (); res++) {
++    Call * c = calls[res];
++    if (c->type == Call::INIT) continue;
++    if (c->type == Call::SET) continue;
++    break;
++  }
++  return res;
++}
++
++Call * Trace::find_option_by_prefix (const char * name) {
++  size_t last = last_option ();
++  Call * res = 0;
++  for (size_t i = first_option (); i < last; i++) {
++    Call * c = calls[i];
++    if (res && strlen (res->name) < strlen (c->name)) continue;
++    if (has_prefix (name, c->name)) res = c;
++  }
++  return res;
++}
++
++Call * Trace::find_option_by_name (const char * name) {
++  size_t last = last_option ();
++  Call * res = 0;
++  for (size_t i = first_option (); i < last; i++) {
++    Call * c = calls[i];
++    if (!strcmp (c->name, name)) res = c;
++  }
++  return res;
++}
++
++// Some options are never part of generated traces.
++//
++bool Trace::ignored_option (const char * name) {
++
++  if (!strcmp (name, "checkfrozen")) return true;
++
++  return false;
++}
++
++// Check whether the trace already contains an option which disables the
++// option 'name'.  Here we assume that an option disables another one if the
++// disabling one has as name proper prefix of the disabled one and the value
++// of the former is set to zero in the trace.  In addition we have to care
++// about all the inprocessing options, which are redundant if the 'simplify'
++// option is set to zero.
++//
++bool Trace::ignore_option (const char * name, int max_var) {
++
++  if (ignored_option (name)) return true;
++
++  // There are options which should be kept at their default value unless
++  // the formula is really small.  Otherwise the solver might run 'forever'.
++  //
++  if (!strcmp (name, "learn") && max_var > 5) return true;
++
++  if (max_var > SMALL) {
++    if (!strcmp (name, "reduce")) return true;
++  }
++
++  Call * c = find_option_by_name ("simplify");
++  if (c && !c->val && disabled_if_not_simplifying (name)) return true;
++
++  c = find_option_by_prefix (name);
++  assert (!c || has_prefix (name, c->name));
++  if (c && strlen (c->name) < strlen (name) && !c->val) return true;
++
++  return false;
++}
++
++// For incomplete solving phases such as 'walk' we do not want to increase
++// the option value above the default.
++//
++long Trace::option_high_value (const char * name,
++                               long def, long lo, long hi) {
++  assert (lo <= def), assert (def <= hi);
++  if (!strcmp (name, "walkmaxeff")) return def;
++  if (!strcmp (name, "walkmineff")) return def;
++  (void) lo;
++  return hi;
++}
++
++/*------------------------------------------------------------------------*/
++
++void Trace::generate_options (Random & random, Size size) {
++
++  // In 10% of the cases do not change any options.
++  //
++  if (random.generate_double () < 0.1) return;
++
++  // With 10% probability we disable simplification.  This option needs to
++  // be put out of sorting order, otherwise the tests in 'ignore_option' to
++  // ignore useless preprocessing options will not work.
++  //
++  if (random.generate_double () < 0.1)
++    push_back (new SetCall ("simplify", 0));
++
++  // In order to increase throughput we enable 'walk' in 5% tests, which
++  // means disabling it in 95% of the tests.
++  //
++  if (random.generate_double () < 0.95)
++    push_back (new SetCall ("walk", 0));
++
++  // Also for checking models and assumptions, but with 80% probability.
++  //
++  if (random.generate_double () < 0.8)
++    push_back (new SetCall ("check", 1));
++
++  // This is the fraction of options changed.
++  //
++  double fraction = random.generate_double ();
++
++  // Generate a list of options, different from default values.
++  //
++  for (Options::const_iterator it = Options::begin ();
++       it != Options::end ();
++       it++) {
++    const Option & o = *it;
++
++    // This should not be reachable unless the low and high value of an
++    // option in 'options.hpp' are the same.
++    //
++    if (o.lo == o.hi) continue;
++
++    // We keep choosing the value for 'simplify' and 'walk' out of the loop
++    // (see the arguments described above).
++    //
++    if (!strcmp (o.name, "simplify")) continue;
++    if (!strcmp (o.name, "walk")) continue;
++
++    // Probability to change an option is 'fraction'.
++    //
++    if (random.generate_double () < fraction) continue;
++
++    // Unless we have to ignore it.
++    //
++    if (ignore_option (o.name, size)) continue;
++
++    int val;
++    long hi = option_high_value (o.name, o.def, o.lo, o.hi);
++    if (o.lo < hi) {
++      bool uniform = random.generate_double () < 0.05;
++      if (uniform) {
++        do val = random.pick_int (o.lo, hi);
++        while (val == o.def);
++      } else {                            // log uniform
++        long range = hi - (long) o.lo;
++        int log;
++        assert (range <= INT_MAX);
++        for (log = 0; log < 30 && (1<<log) < range; log++)
++          if (random.generate_bool ()) break;
++        if ((1<<log) < range) range = (1l<<log);
++        val = o.lo + random.pick_int (0, range);
++      }
++    } else val = o.lo;
++    push_back (new SetCall (o.name, val));
++  }
++
++#ifdef LOGGING
++  if (mobical.add_set_log_to_true)
++    push_back (new SetCall ("log", 1));
++#endif
++}
++
++/*------------------------------------------------------------------------*/
++
++void Trace::generate_queries (Random & random) {
++  if (random.generate_double () < 0.02) push_back (new VarsCall ());
++  if (random.generate_double () < 0.02) push_back (new ActiveCall ());
++  if (random.generate_double () < 0.02) push_back (new RedundantCall ());
++  if (random.generate_double () < 0.02) push_back (new IrredundantCall ());
++}
++
++/*------------------------------------------------------------------------*/
++
++void Trace::generate_reserve (Random & random, int max_var) {
++  if (random.generate_double () > 0.01) return;
++  int new_max_var = random.pick_int (0, 1.1*max_var);
++  push_back (new ReserveCall (new_max_var));
++}
++
++/*------------------------------------------------------------------------*/
++
++void Trace::generate_limits (Random & random) {
++  if (random.generate_double () < 0.3)
++    push_back (new LimitCall ("conflicts", random.pick_int (0, INT_MAX)));
++  if (random.generate_double () < 0.2)
++    push_back (new LimitCall ("decisions", random.pick_int (0, INT_MAX)));
++  if (random.generate_double () < 0.1)
++    push_back (new LimitCall ("preprocessing", random.pick_int (0, 10)));
++  if (random.generate_double () < 0.05)
++    push_back (new LimitCall ("localsearch", random.pick_int (0, 1)));
++  if (random.generate_double () < 0.02)
++    push_back (new OptimizeCall (random.pick_int (0, 9)));
++}
++
++/*------------------------------------------------------------------------*/
++
++static int pick_size (Random & random, int vars) {
++  int res;
++  double prop = random.generate_double ();
++       if (prop < 0.0001) res = 0;
++  else if (prop < 0.001) res = 1;
++  else if (prop < 0.01) res = 2;
++  else if (prop < 0.90) res = 3;
++  else if (prop < 0.95) res = 4;
++  else res = random.pick_int (5, 20);
++  if (res > vars) res = vars;
++  return res;
++}
++
++static int pick_literal (Random & random,
++                         int minvars, int maxvars,
++                         vector<int> & clause) {
++  assert (minvars <= maxvars);
++  int res = 0;
++  while (!res) {
++    int idx = random.pick_int (minvars, maxvars);
++    double prop = random.generate_double ();
++    if (prop > 0.001) {
++      bool duplicated = false;
++      for (size_t i = 0; !duplicated && i < clause.size (); i++)
++        duplicated = (abs (clause[i]) == idx);
++      if (duplicated) continue;
++    }
++    bool sign = random.generate_bool ();
++    res = sign ? -idx : idx;
++  }
++  return res;
++}
++
++void Trace::generate_clause (Random & random,
++                             int minvars, int maxvars,
++                             int uniform) {
++  assert (minvars <= maxvars);
++  int maxsize = maxvars - minvars + 1;
++  int size = uniform ? uniform : pick_size (random, maxsize);
++  vector<int> clause;
++  for (int i = 0; i < size; i++) {
++    int lit = pick_literal (random, minvars, maxvars, clause);
++    push_back (new AddCall (lit));
++    clause.push_back (lit);
++  }
++  push_back (new AddCall (0));
++}
++
++/*------------------------------------------------------------------------*/
++
++void Trace::generate_assume (Random & random, int vars) {
++  if (random.generate_double () < 0.15) return;
++  int count;
++  if (random.generate_bool ()) count = 1;
++  else count = random.pick_int (1, vars + 1);
++  const int max_vars = vars + 2;
++  bool * picked = new bool [max_vars + 1];
++  for (int i = 1; i <= max_vars; i++) picked[i] = false;
++  for (int i = 0; i < count; i++) {
++    int idx;
++    do idx = random.pick_int (1, max_vars); while (picked[idx]);
++    picked[idx] = 1;
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new AssumeCall (lit));
++  }
++  delete [] picked;
++  if (random.generate_double () < 0.1) {
++    int idx = random.pick_int (1, max_vars);
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new AssumeCall (lit));
++  }
++}
++
++void Trace::generate_values (Random & random, int vars) {
++  if (random.generate_double () < 0.1) return;
++  double fraction = random.generate_double ();
++  for (int idx = 1; idx <= vars; idx++) {
++    if (fraction < random.generate_double ()) continue;
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new ValCall (lit));
++  }
++  if (random.generate_double () < 0.1) {
++    int idx = random.pick_int (vars + 1, vars*1.5 + 1);
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new ValCall (lit));
++  }
++}
++
++void Trace::generate_failed (Random & random, int vars) {
++  if (random.generate_double () < 0.05) return;
++  double fraction = random.generate_double ();
++  for (int idx = 1; idx <= vars; idx++) {
++    if (fraction < random.generate_double ()) continue;
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new FailedCall (lit));
++  }
++  if (random.generate_double () < 0.05) {
++    int idx = random.pick_int (vars + 1, vars*1.5 + 1);
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new FailedCall (lit));
++  }
++}
++
++void Trace::generate_frozen (Random & random, int vars) {
++  if (random.generate_double () < 0.05) return;
++  double fraction = random.generate_double ();
++  for (int idx = 1; idx <= vars; idx++) {
++    if (fraction < random.generate_double ()) continue;
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new FrozenCall (lit));
++  }
++  if (random.generate_double () < 0.05) {
++    int idx = random.pick_int (vars + 1, vars*1.5 + 1);
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new FrozenCall (lit));
++  }
++}
++
++void Trace::generate_melt (Random & random) {
++  if (random.generate_bool ()) return;
++  int m = vars ();
++  long * frozen = new long [m + 1];
++  for (int i = 1; i <= m; i++) frozen[i] = 0;
++  for (size_t i = 0; i < size (); i++) {
++    Call * c = calls[i];
++    if (c->type == Call::MELT) {
++      int idx = abs (c->arg);
++      assert (idx), assert (idx <= m);
++      assert (frozen[idx] > 0);
++      frozen[idx]--;
++    } else if (c->type == Call::FREEZE) {
++      int idx = abs (c->arg);
++      assert (idx), assert (idx <= m);
++      frozen[idx]++;
++    }
++  }
++  vector<int> candidates;
++  for (int i = 1; i <= m; i++)
++    if (frozen[i])
++      candidates.push_back (i);
++  delete [] frozen;
++  double fraction = random.generate_double () * 0.4;
++  for (auto idx : candidates) {
++    if (random.generate_double () <= fraction) continue;
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new MeltCall (lit));
++  }
++}
++
++void Trace::generate_freeze (Random & random, int vars) {
++  if (random.generate_bool ()) return;
++  double fraction = random.generate_double () * 0.5;
++  for (int idx = 1; idx <= vars; idx++) {
++    if (random.generate_double () <= fraction) continue;
++    int lit = random.generate_bool () ? -idx : idx;
++    push_back (new FreezeCall (lit));
++  }
++}
++
++void Trace::generate (uint64_t i, uint64_t s) {
++
++  id = i;
++  seed = s;
++
++  push_back (new InitCall ());
++
++  Random random (seed);
++
++  Size size;
++
++  if (mobical.force.size) size = mobical.force.size;
++  else {
++    switch (random.pick_int (1, 3)) {
++      case 1 : size = SMALL; break;
++      case 2 : size = MEDIUM; break;
++      default : size = BIG; break;
++    }
++  }
++
++  generate_options (random, size);
++
++  int calls;
++  if (mobical.force.phases < 0) calls = random.pick_int (1, 4);
++  else                          calls = mobical.force.phases;
++
++  int minvars, maxvars = 0;
++
++  for (int call = 0; call < calls; call++) {
++
++    int range;
++    double ratio;
++    int uniform;
++
++         if (size == SMALL)  range = random.pick_int (1, SMALL);
++    else if (size == MEDIUM) range = random.pick_int (SMALL+1, MEDIUM);
++    else                     range = random.pick_int (MEDIUM+1, BIG);
++
++    if (random.generate_bool ()) uniform = 0;
++    else if (size == SMALL)      uniform = random.pick_int (3, 7);
++    else if (size == MEDIUM)     uniform = random.pick_int (3, 4);
++    else                         uniform = random.pick_int (3, 3);
++
++    switch (uniform) {
++      default: ratio = 4.267; break;
++      case 4:  ratio = 9.931; break;
++      case 5:  ratio = 21.117; break;
++      case 6:  ratio = 43.37; break;
++      case 7:  ratio = 87.79; break;
++    }
++
++    int clauses = range * ratio;
++
++    minvars = random.pick_int (1, maxvars + 1);
++    maxvars = minvars + range;
++
++    for (int j = 0; j < clauses; j++)
++      generate_queries (random),
++      generate_reserve (random, maxvars),
++      generate_clause (random, minvars, maxvars, uniform);
++
++    generate_assume (random, maxvars);
++    generate_melt (random);
++    generate_freeze (random, maxvars);
++    generate_limits (random);
++
++    if (mobical.add_dump_before_solve) push_back (new DumpCall ());
++    push_back (new SolveCall ());
++    if (mobical.add_stats_after_solve) push_back (new StatsCall ());
++
++    generate_values (random, maxvars);
++    generate_failed (random, maxvars);
++    generate_frozen (random, maxvars);
++  }
++
++  push_back (new ResetCall ());
++}
++
++/*------------------------------------------------------------------------*/
++
++void Mobical::hline () {
++  prefix ();
++  terminal.normal ();
++  cerr << setfill ('-') << setw (76) << "" << setfill (' ') << endl;
++  terminal.normal ();
++}
++
++void Mobical::empty_line () { cerr << prefix_string () << endl; }
++
++static int rounded_percent (double a, double b) {
++  return 0.5 + percent (a, b);
++}
++
++void Mobical::print_statistics () {
++  hline ();
++
++  prefix ();
++  cerr << "generated " << Trace::generated << " traces: ";
++  if (Trace::ok > 0) terminal.green (true);
++  cerr << Trace::ok << " ok "
++       << rounded_percent (Trace::ok, Trace::generated) << "%";
++  if (Trace::ok > 0) terminal.normal ();
++  cerr << ", ";
++  if (Trace::failed > 0) terminal.red (true);
++  cerr << Trace::failed << " failed "
++       << rounded_percent (Trace::failed, Trace::generated) << "%";
++  if (Trace::failed > 0) terminal.normal ();
++  cerr << ", " << Trace::executed << " executed"
++       << endl << flush;
++
++  if (shared) {
++    prefix ();
++    cerr << "solved " << shared->solved << ": "
++         << terr.blue_code ()
++         << shared->sat << " sat "
++         << rounded_percent (shared->sat, shared->solved) << "%"
++         << terr.normal_code ()
++         << ", "
++         << terr.magenta_code ()
++         << shared->unsat << " unsat "
++         << rounded_percent (shared->unsat, shared->solved) << "%"
++         << terr.normal_code ()
++         << ", " << shared->incremental << " incremental "
++         << rounded_percent (shared->incremental, shared->solved) << "%"
++         << endl << flush;
++    if (shared->memout || shared->timeout) {
++      prefix ();
++      cerr << "out-of-time " << shared->timeout << ", "
++           << "out-of-memory " << shared->memout
++           << endl << flush;
++    }
++  }
++
++  if (spurious) {
++    prefix ();
++    cerr << "generated " << spurious << " spurious traces "
++         << rounded_percent (spurious, traces) << "%"
++         << endl << flush;
++  }
++}
++
++/*------------------------------------------------------------------------*/
++
++extern "C" {
++#include <fcntl.h>
++#include <sys/stat.h>
++#include <sys/types.h>
++#include <sys/wait.h>
++#include <sys/resource.h>
++#include <sys/time.h>
++}
++
++long Trace::generated;
++long Trace::executed;
++long Trace::failed;
++long Trace::ok;
++
++#define SIGNAL(SIG) \
++void (*Trace::old_ ## SIG ## _handler) (int);
++SIGNALS
++#undef SIGNAL
++
++void Trace::reset_child_signal_handlers () {
++#define SIGNAL(SIG) \
++  signal (SIG, old_ ## SIG ## _handler);
++  SIGNALS
++#undef SIGNAL
++}
++
++void Trace::child_signal_handler (int sig) {
++  struct rusage u;
++  if (!getrusage (RUSAGE_SELF, &u)) {
++    if ((long) u.ru_maxrss >> 10 >= mobical.space_limit) {
++      if (mobical.shared) mobical.shared->memout++;
++      // Since there is no memout signal we just misuse SIXCPU to notify the
++      // calling process that this is a out-of-resource situation.
++      sig = SIGXCPU;
++    } else {
++      double t = u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec +
++                 u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec;
++      if (t >= mobical.time_limit) {
++        if (mobical.shared) mobical.shared->timeout++;
++        sig = SIGXCPU;
++      }
++    }
++  }
++  reset_child_signal_handlers ();
++  raise (sig);
++}
++
++void Trace::init_child_signal_handlers () {
++#define SIGNAL(SIG) \
++  old_ ## SIG ## _handler = signal (SIG, child_signal_handler);
++  SIGNALS
++#undef SIGNAL
++}
++
++int Trace::fork_and_execute () {
++
++  cerr << flush;
++  pid_t child = mobical.donot.fork ? 0 : fork ();
++  int res = 0;
++
++  if (child) {
++
++    executed++;
++
++    int status, other = wait (&status);
++    if (other != child) res = 0;
++    else if (WIFEXITED (status)) res = WEXITSTATUS (status);
++    else if (!WIFSIGNALED (status)) res = 0;
++    else if (mobical.donot.ignore_resource_limits) res = 1;
++    else res = (WTERMSIG (status) != SIGXCPU);
++
++  } else {
++
++    if (!mobical.donot.fork && mobical.time_limit) {
++      struct rlimit rlim;
++      if (!getrlimit (RLIMIT_CPU, &rlim)) {
++        rlim.rlim_cur = mobical.time_limit;
++        setrlimit (RLIMIT_CPU, &rlim);
++      }
++    }
++
++    if (!mobical.donot.fork && mobical.space_limit) {
++      struct rlimit rlim;
++      if (!getrlimit (RLIMIT_AS, &rlim)) {
++        rlim.rlim_cur = mobical.space_limit * (1l << 20);
++        setrlimit (RLIMIT_AS, &rlim);
++      }
++    }
++
++    init_child_signal_handlers ();
++    dup2 (1, 3);
++    dup2 (2, 4);
++    int null = open ("/dev/null", O_WRONLY);
++    assert (null);
++    dup2 (null, 1);
++    dup2 (null, 2);
++    execute ();
++    close (1);
++    close (2);
++    close (null);
++    dup2 (3, 1);
++    dup2 (4, 2);
++    close (3);
++    close (4);
++    reset_child_signal_handlers ();
++
++    if (!mobical.donot.fork) exit (0);
++  }
++
++  return res;
++}
++
++/*------------------------------------------------------------------------*/
++
++// Delta-debugging algorithm on segments.
++
++bool Trace::shrink_segments (Trace::Segments & segments, int expected) {
++  size_t n = segments.size ();
++  if (!n) return false;
++  size_t granularity = n;
++  bool * removed = new bool[n];
++  bool * saved = new bool[n];
++  bool * ignore = new bool[size ()];
++  for (size_t i = 0; i < n; i++) removed[i] = false;
++  bool res = false;
++  Trace shrunken;
++  for (;;) {
++    for (size_t l = 0, r; l < n; l = r) {
++      r = l + granularity;
++      if (r > n) r = n;
++      size_t flipped = 0;
++      for (size_t i = 0; i < n; i++) saved[i] = false;
++      for (size_t i = l; i < r; i++)
++        if (!(saved[i] = removed[i]))
++          removed[i] = true, flipped++;
++      if (!flipped) continue;
++      for (size_t i = 0; i < size (); i++) ignore[i] = false;
++      for (size_t i = 0; i < n; i++) {
++        if (!removed[i]) continue;
++        Segment & s = segments[i];
++        for (size_t j = s.lo; j < s.hi; j++)
++          ignore[j] = true;
++      }
++      Trace tmp;
++      tmp.clear ();
++      for (size_t i = 0; i < size (); i++)
++        if (!ignore[i])
++          tmp.push_back (calls[i]->copy ());
++      progress ();
++      if (tmp.fork_and_execute () != expected) {        // failed
++        for (size_t i = l; i < r; i++)
++          removed[i] = saved[i];
++      } else {
++        shrunken.clear ();
++        for (size_t i = 0; i < tmp.size (); i++)
++          shrunken.push_back (tmp[i]->copy ());
++        res = true;                     // succeeded to shrink
++      }
++    }
++    if (granularity == 1) break;
++    granularity = (granularity + 1) / 2;
++    if (shrunken.size ()) shrunken.clear ();
++  }
++  if (res) {
++    for (size_t i = 0; i < size (); i++) ignore[i] = false;
++    for (size_t i = 0; i < n; i++) {
++      if (!removed[i]) continue;
++      Segment & s = segments[i];
++      for (size_t j = s.lo; j < s.hi; j++)
++        ignore[j] = true;
++    }
++    size_t j = 0;
++    for (size_t i = 0; i < size (); i++) {
++      Call * c = calls[i];
++      if (ignore[i]) delete c;
++      else calls[j++] = c;
++    }
++    calls.resize (j);
++    notify ();
++  }
++  delete [] ignore;
++  delete [] removed;
++  delete [] saved;
++  return res;
++}
++
++/*------------------------------------------------------------------------*/
++
++void Mobical::summarize (Trace & trace, bool bright) {
++  if (bright) terminal.cyan (bright); else terminal.blue ();
++  cerr << right << setw (5) << trace.size ();
++  terminal.normal ();
++  cerr << ' ';
++  terminal.magenta (bright);
++  cerr << ' '  << right << setw (3) << trace.vars ();
++  terminal.yellow (bright);
++  cerr << ' '  <<  left << setw (4) << trace.clauses ();
++  terminal.normal ();
++  cerr << ' ';
++  if (bright) terminal.cyan (bright); else terminal.blue ();
++  cerr << setw (2) << right << trace.phases ();
++  terminal.normal ();
++}
++
++void Mobical::notify (Trace & trace, signed char ch) {
++  bool first = notified.empty ();
++#ifdef QUIET
++  if (ch < 0) return;
++  if (ch > 0) notified.push_back (ch);
++#else
++  if (ch < 0 && (!terminal || verbose)) return;
++  double t = absolute_real_time ();
++  if (ch > 0) notified.push_back (ch), progress_counter = 1;
++  else if (ch < 0) {
++    if (t < last_progress_time + 0.3) return;
++    progress_counter++;
++  }
++#endif
++  if (!first || !(mode & OUTPUT))
++    terminal.erase_line_if_connected_otherwise_new_line ();
++  prefix ();
++  if (traces) cerr << ' ' << left << setw (12) << traces;
++  else cerr << left << setw (13) << "reduce:";
++  terminal.yellow ();
++
++  if (!notified.empty ()) {
++    for (size_t i = 0; i + 1 < notified.size (); i++)
++      cerr << notified[i];
++#ifndef QUIET
++    if (progress_counter & 1) terminal.inverse ();
++#else
++    terminal.inverse ();
++#endif
++    cerr << notified.back ();
++    terminal.normal ();
++  }
++
++  if (notified.size () < 45) cerr << setw (45 - notified.size ()) << " ";
++  cerr << flush;
++  summarize (trace);
++  if (verbose) cerr << endl;
++  cerr << flush;
++#ifndef QUIET
++  last_progress_time = t;
++#endif
++}
++
++/*------------------------------------------------------------------------*/
++
++static bool config_type (Call::Type t) {
++  return (((int) t & (int) Call::CONFIG)) != 0;
++}
++
++static bool before_type (Call::Type t) {
++  return (((int) t & (int) Call::BEFORE)) != 0;
++}
++
++static bool after_type (Call::Type t) {
++  return (((int) t & (int) Call::AFTER)) != 0;
++}
++
++// Explicit grammar aware three-level hierarchical delta-debugging.
++// First level is in term of incremental solving phases where one phase
++// consists of maximal prefixes of intervals of calls of type
++// '(BEFORE*|SOLVE|SIMPLIFY|AFTER*)' or single non-configuration calls.
++//
++bool Trace::shrink_phases (int expected) {
++  if (mobical.donot.shrink.phases) return false;
++  notify ('p');
++  size_t l;
++  for (l = 1; l < size () && config_type (calls[l]->type); l++)
++    ;
++  Segments segments;
++  size_t r;
++  for (; l < size (); l = r) {
++    for (r = l; r < size () && before_type (calls[r]->type); r++)
++      ;
++    if (r < size () &&
++      (calls[r]->type == Call::SOLVE ||
++       calls[r]->type == Call::SIMPLIFY)) r++;
++    for (;r < size () && after_type (calls[r]->type); r++)
++      ;
++    if (l < r) segments.push_back (Segment (l, r));
++    else {
++      assert (l == r);
++      if (!config_type (calls[r]->type))
++        segments.push_back (Segment (r, r + 1));
++      ++r;
++    }
++  }
++  return shrink_segments (segments, expected);
++}
++
++// The second level ties to remove clauses.
++//
++bool Trace::shrink_clauses (int expected) {
++  if (mobical.donot.shrink.clauses) return false;
++  notify ('c');
++  Segments segments;
++  for (size_t r = size (), l; r > 1; r = l) {
++    Call * c = calls[l = r - 1];
++    while (l > 0 && (c->type != Call::ADD || c->arg))
++      c = calls[--l];
++    if (!l) break;
++    r = l + 1;
++    while ((c = calls[--l])->type == Call::ADD && c->arg)
++      ;
++    segments.push_back (Segment (++l, r));
++  }
++  return shrink_segments (segments, expected);
++}
++
++// The third level tries to remove individual literals.
++//
++bool Trace::shrink_literals (int expected) {
++  if (mobical.donot.shrink.literals) return false;
++  notify ('l');
++  Segments segments;
++  for (size_t l = size ()-1; l > 0; l--) {
++    Call * c = calls[l];
++    if (c->type == Call::ADD && c->arg)
++      segments.push_back (Segment (l, l+1));
++  }
++  return shrink_segments (segments, expected);
++}
++
++static bool is_basic (Call * c) {
++  switch (c->type) {
++    case Call::ASSUME:
++    case Call::SOLVE:
++    case Call::SIMPLIFY:
++    case Call::VARS:
++    case Call::ACTIVE:
++    case Call::REDUNDANT:
++    case Call::IRREDUNDANT:
++    case Call::RESERVE:
++    case Call::VAL:
++    case Call::FIXED:
++    case Call::FAILED:
++    case Call::FROZEN:
++    case Call::FREEZE:
++    case Call::MELT:
++    case Call::LIMIT:
++    case Call::OPTIMIZE:
++      return true;
++    default:
++      return false;
++  }
++}
++
++bool Trace::shrink_basic (int expected) {
++  if (mobical.donot.shrink.basic) return false;
++  notify ('b');
++  Segments segments;
++  for (size_t l = size ()-1; l > 0; l--) {
++    Call * c = calls[l];
++    if (!is_basic (c)) continue;
++    segments.push_back (Segment (l, l+1));
++  }
++  return shrink_segments (segments, expected);
++}
++
++// We first add all non present possible options with their default value.
++
++void Trace::add_options (int expected) {
++  if (mobical.donot.add) return;
++  const int max_var = vars ();
++  notify ('a');
++  assert (size ());
++  assert (calls[0]->type == Call::INIT);
++  Trace extended;
++  extended.push_back (calls[0]->copy ());
++  size_t i = 1;
++  Call * c;
++  while (i < size () && (c = calls[i])->type == Call::SET)
++    extended.push_back (c->copy ()), i++;
++  for (Options::const_iterator it = Options::begin ();
++       it != Options::end ();
++       it++) {
++    const Option & o = *it;
++    if (find_option_by_name (o.name)) continue;
++    if (ignore_option (o.name, max_var)) continue;
++    if (extended.ignore_option (o.name, max_var)) continue;
++    extended.push_back (new SetCall (o.name, o.def));
++  }
++  while (i < size ())
++    extended.push_back (calls[i++]->copy ());
++  progress ();
++  if (extended.fork_and_execute () != expected) return;
++  clear ();
++  for (i = 0; i < extended.size (); i++)
++    push_back (extended[i]->copy ());
++  notify ();
++}
++
++// Try to set as many options to their lower limit, which also tries to
++// disable as many boolean options.
++
++bool Trace::shrink_disable (int expected) {
++
++  if (mobical.donot.disable) return false;
++  const int max_var = vars ();
++
++  notify ('d');
++  size_t last = last_option ();
++  vector<size_t> candidates;
++  vector<int> lower, saved;
++  for (size_t i = first_option (); i < last; i++) {
++    Call * c = calls[i];
++    assert (c->type == Call::SET);
++    if (ignore_option (c->name, max_var)) continue;
++    Option * o = Options::has (c->name);
++    if (!o) continue;
++    if (c->val == o->lo) continue;
++    candidates.push_back (i);
++    lower.push_back (o->lo);
++    saved.push_back (c->val);
++  }
++  if (candidates.empty ()) return false;
++  size_t granularity = candidates.size ();
++  bool res = false;
++  for (;;) {
++    size_t n = candidates.size ();
++    for (size_t i = 0; i < n; i += granularity) {
++      bool reduce = false;
++      for (size_t j = i; j < n && j < i + granularity; j++) {
++        size_t k = candidates[j];
++        Call * c = calls[k];
++        assert (c->type == Call::SET);
++        saved[j] = c->val;
++        int new_val = lower[j];
++        if (c->val == new_val) continue;
++        c->val = new_val;
++        reduce = true;
++      }
++      if (!reduce) continue;
++      progress ();
++      if (fork_and_execute () == expected) res = true;
++      else {
++        for (size_t j = i; j < n && j < i + granularity; j++) {
++          size_t k = candidates[j];
++          Call * c = calls[k];
++          assert (c->type == Call::SET);
++          c->val = saved[j];
++        }
++      }
++    }
++    if (granularity == 1) break;
++    granularity = (granularity + 1)/2;
++  }
++  notify ();
++  return res;
++}
++
++// Try to shrink the option values.
++
++bool Trace::reduce_values (int expected) {
++
++  if (mobical.donot.reduce) return false;
++
++  notify ('r');
++
++  assert (size ());
++  assert (calls[0]->type == Call::INIT);
++
++  bool changed = false, res = false;
++  do {
++    if (changed) res = true;
++    changed = false;
++    for (size_t i = 0; i < size (); i++) {
++      Call * c = calls[i];
++
++      int lo, hi;
++
++      if (c->type == Call::SET) {
++        Option * o = Options::has (c->name);
++        if (!o) continue;
++        lo = o->lo, hi = o->hi;
++      } else if (c->type == Call::LIMIT) {
++        if (!strcmp (c->name, "conflicts") ||
++            !strcmp (c->name, "decisions"))
++          lo = -1, hi = INT_MAX;
++        else if (!strcmp (c->name, "preprocessing"))
++          lo = 0, hi = INT_MAX;
++        else if (!strcmp (c->name, "localsearch"))
++          lo = 0, hi = c->val;
++        else continue;
++      } else if (c->type == Call::OPTIMIZE) {
++        lo = 0, hi = 9;
++      } else continue;
++
++      assert (lo <= hi);
++      if (c->val == lo) continue;
++
++      // First try to reach eagerly the low value
++      // (includes the case that current value is too low).
++      //
++      int old_val = c->val;
++      c->val = lo;
++      progress ();
++      if (fork_and_execute () == expected) {
++        assert (c->val != old_val);
++        changed = true;
++        continue;
++      }
++      c->val = old_val;
++
++      // Then try to limit to the high value if current value too large.
++      //
++      if (c->val > hi) {
++        int old_val = c->val;
++        c->val = hi;
++        progress ();
++        if (fork_and_execute () == expected) {
++          assert (c->val != old_val);
++          changed = true;
++        } else { c->val = old_val; continue; }
++      }
++
++      // Now we do a delta-debugging inspired binary search for the smallest
++      // value for which the execution produces a non-zero exit code.  It
++      // kind of assumes monotonicity and if this is not the case might not
++      // yield the smallest value, but remains logarithmic.
++      //
++      long granularity = ((old_val - (long) lo) + 1l) / 2;
++      assert (granularity > 0);
++      for (long new_val = c->val - granularity;
++           new_val > lo;
++           new_val -= granularity) {
++        old_val = c->val;
++        assert (new_val != old_val);
++        assert (lo < new_val);
++        assert (new_val <= hi);
++        c->val = new_val;
++        progress ();
++        if (fork_and_execute () == expected) {
++          assert (c->val != old_val);
++          changed = true;
++        } else c->val = old_val;
++      }
++    }
++  } while (changed);
++
++  notify ();
++
++  return res;
++}
++
++static bool has_lit_arg_type (Call * c) {
++  switch (c->type) {
++    case Call::ADD:
++    case Call::ASSUME:
++    case Call::FREEZE:
++    case Call::MELT:
++    case Call::FROZEN:
++    case Call::VAL:
++    case Call::FIXED:
++    case Call::FAILED:
++    case Call::RESERVE:
++      return true;
++    default:
++      return false;
++  }
++}
++
++// Try to map variables to a contiguous initial range.
++
++void Trace::map_variables (int expected) {
++  if (mobical.donot.map) return;
++  for (int with_gaps = 0; with_gaps <= 1; with_gaps++) {
++    notify ('m');
++    vector<int> variables;
++    for (size_t i = 0; i < size (); i++) {
++      Call * c = calls[i];
++      if (!has_lit_arg_type (c)) continue;
++      if (!c->arg) continue;
++      if (c->arg == INT_MIN) continue;
++      int idx = abs (c->arg);
++      while (variables.size () <= (size_t) idx)
++        variables.push_back (0);
++      variables[idx]++;
++    }
++    int gaps = 0, max_idx = 0;
++    bool skipped = false;
++    for (int i = 1; (size_t) i < variables.size (); i++) {
++      if (!variables[i]) {
++        if (with_gaps && !skipped) max_idx++, skipped = true;
++        gaps++;
++      } else {
++        variables[i] = ++max_idx;
++        skipped = false;
++      }
++    }
++    if (!gaps) { notify (); return; }
++    Trace mapped;
++    for (size_t i = 0; i < size (); i++) {
++      Call * c = calls[i];
++      if (!c->arg || c->arg == INT_MIN)
++        mapped.push_back (c->copy ());
++      else if (has_lit_arg_type (c)) {
++        int new_lit = variables[abs (c->arg)];
++        assert (0 < new_lit), assert (new_lit <= max_idx);
++        if (c->arg < 0) new_lit = -new_lit;
++        Call * d = c->copy ();
++        d->arg = new_lit;
++        mapped.push_back (d);
++      } else mapped.push_back (c->copy ());
++    }
++    progress ();
++    if (mapped.fork_and_execute () == expected) {
++      clear ();
++      for (size_t i = 0; i < mapped.size (); i++)
++        push_back (mapped[i]->copy ());
++      notify ();
++      with_gaps = 2;
++    }
++    notify ();
++  }
++}
++
++// Finally remove option calls.
++
++void Trace::shrink_options (int expected) {
++
++  if (mobical.donot.shrink.options) return;
++
++  notify ('o');
++  Segments segments;
++  for (size_t i = 0; i < size (); i++) {
++    Call * c = calls[i];
++    if (c->type != Call::SET) continue;
++    segments.push_back (Segment (i, i+1));
++  }
++
++  (void) shrink_segments (segments, expected);
++}
++
++void Trace::shrink (int expected) {
++
++  enum Shrinking {
++    NONE = 0,
++    PHASES,
++    CLAUSES,
++    LITERALS,
++    BASIC,
++    DISABLE,
++    VALUES
++  };
++
++  mobical.shrinking = true;
++  mobical.notified.clear ();
++  assert (!mobical.donot.shrink.atall);
++  if (!size () || calls[0]->type != Call::INIT) return;
++  add_options (expected);
++  Shrinking l = NONE;
++  bool s;
++  do {
++    s = false;
++    if (l != PHASES && shrink_phases (expected))     s = true, l = PHASES;
++    if (l != CLAUSES && shrink_clauses (expected))   s = true, l = CLAUSES;
++    if (l != LITERALS && shrink_literals (expected)) s = true, l = LITERALS;
++    if (l != BASIC && shrink_basic (expected))       s = true, l = BASIC;
++    if (l != DISABLE && shrink_disable (expected))   s = true, l = DISABLE;
++    if (l != VALUES && reduce_values (expected))     s = true, l = VALUES;
++  } while (s);
++  map_variables (expected);
++  shrink_options (expected);
++  cerr << flush;
++  mobical.shrinking = false;
++}
++
++void Trace::write_path (const char * path) {
++  if (!strcmp (path, "-")) print (cout);
++  else {
++    ofstream os (path);
++    if (!os.is_open ())
++      mobical.die ("can not write '%s'", path);
++    print (os);
++  }
++}
++
++void Trace::write_prefixed_seed (const char * prefix) {
++  ostringstream ss;
++  ss << prefix << '-'
++     << setfill ('0') << right << setw (20) << seed
++     << ".trace" << flush;
++  ofstream os (ss.str ().c_str ());
++  if (!os.is_open ())
++    mobical.die ("can not write '%s'", ss.str ().c_str ());
++  print (os);
++  cerr << ss.str ();
++}
++
++/*------------------------------------------------------------------------*/
++
++void Reader::error (const char * fmt, ...) {
++  mobical.error_prefix ();
++  mobical.terminal.red (true);
++  fputs ("parse error:", stderr);
++  mobical.terminal.normal ();
++  fprintf (stderr, " %s:%d: ", path, lineno);
++  va_list ap;
++  va_start (ap, fmt);
++  vfprintf (stderr, fmt, ap);
++  va_end (ap);
++  fputc ('\n', stderr);
++  mobical.terminal.reset ();
++  exit (1);
++}
++
++static bool is_valid_char (int ch) {
++  if (ch == ' ') return true;
++  if (ch == '-') return true;
++  if ('a' <= ch && ch <= 'z') return true;
++  if ('0' <= ch && ch <= '9') return true;
++  return false;
++}
++
++void Reader::parse () {
++  int ch, lit = 0, val = 0, state = 0, adding = 0, solved = 0;
++  const bool enforce = !mobical.donot.enforce;
++  Call * before_trigger = 0;
++  char line[80];
++  while ((ch = next ()) != EOF) {
++    size_t n = 0;
++    while (ch != '\n') {
++      if (n + 2 >= sizeof line) error ("line too large");
++      if (!is_valid_char (ch)) {
++        if (isprint (ch)) error ("invalid character '%c'", ch);
++        else error ("invalid character code 0x%02x", ch);
++      }
++      line[n++] = ch;
++      if ((ch = next ()) == EOF) error ("unexpected end-of-file");
++    }
++    assert (n < sizeof line);
++    line[n] = 0;
++    char * p = line;
++    if (isdigit (ch = *p)) {
++      while (isdigit (ch = *++p))
++        ;
++      if (!ch) error ("incomplete line with only line number");
++      if (ch != ' ') error ("expected space after line number");
++      p++;
++    }
++    const char * keyword = p;
++    if ((ch = *p) < 'a' || 'z' < ch)
++      error ("expected keyword to start with lower case letter");
++    while (p < line + n && (ch = *++p) && 'a' <= ch && ch <= 'z')
++      ;
++    const char * first = 0, * second = 0;
++    if ((ch = *p) == ' ') {
++      *p++ = 0;
++      first = p;
++      ch = *p;
++      if (!ch) error ("first argument missing after trailing space");
++      if (ch == ' ') error ("space in place of first argument");
++      while ((ch = *++p) && ch != ' ')
++        ;
++      if (ch == ' ') {
++        *p++ = 0;
++        second = p;
++        ch = *p;
++        if (!ch) error ("second argument missing after trailing space");
++        if (ch == ' ') error ("space in place of second argument");
++        while ((ch = *++p) && ch != ' ')
++          ;
++        if (ch == ' ') {
++          *p = 0;
++          error ("unexpected space after second argument '%s'", second);
++        }
++      }
++    } else if (ch) error ("unexpected character '%c' in keyword", ch);
++    assert (!ch);
++    Call * c = 0;
++    if (!strcmp (keyword, "init")) {
++      if (first) error ("unexpected argument '%s' after 'init'", first);
++      c = new InitCall ();
++    } else if (!strcmp (keyword, "set")) {
++      if (!first) error ("first argument to 'set' missing");
++      if (enforce && !Solver::is_valid_option ((first))) {
++#ifndef LOGGING
++        if (!strcmp (first, "log"))
++          mobical.warning (
++            "non-existing option name 'log' "
++            "(compiled without '-DLOGGING')");
++        else
++#endif
++        error ("non-existing option name '%s'", first);
++      }
++      if (!second) error ("second argument to 'set' missing");
++      if (!parse_int_str (second, val))
++        error ("invalid second argument '%s' to 'set'", second);
++      c = new SetCall (first, val);
++    } else if (!strcmp (keyword, "limit")) {
++      if (!first) error ("first argument to 'limit' missing");
++      if (!second) error ("second argument to 'limit' missing");
++      if (!parse_int_str (second, val))
++        error ("invalid second argument '%s' to 'limit'", second);
++      c = new LimitCall (first, val);
++    } else if (!strcmp (keyword, "optimize")) {
++      if (!first) error ("argument to 'optimize' missing");
++      if (!parse_int_str (first, val) || val < 0 || val > 9)
++        error ("invalid argument '%s' to 'optimize'", first);
++      c = new OptimizeCall (val);
++    } else if (!strcmp (keyword, "vars")) {
++      if (first) error ("unexpected argument '%s' after 'vars'", first);
++      c = new VarsCall ();
++    } else if (!strcmp (keyword, "active")) {
++      if (first) error ("unexpected argument '%s' after 'active'", first);
++      c = new ActiveCall ();
++    } else if (!strcmp (keyword, "redundant")) {
++      if (first)
++        error ("unexpected argument '%s' after 'redundant'", first);
++      c = new RedundantCall ();
++    } else if (!strcmp (keyword, "irredundant")) {
++      if (first)
++        error ("unexpected argument '%s' after 'irredundant'", first);
++      c = new IrredundantCall ();
++    } else if (!strcmp (keyword, "reserve")) {
++      if (!first) error ("argument to 'reserve' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid argument '%s' to 'reserve'", first);
++      if (second) error ("additional argument '%s' to 'reserve'", second);
++      c = new ReserveCall (lit);
++    } else if (!strcmp (keyword, "add")) {
++      if (!first) error ("argument to 'add' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid argument '%s' to 'add'", first);
++      if (second) error ("additional argument '%s' to 'add'", second);
++      if (enforce && lit == INT_MIN)
++        error ("invalid literal '%d' as argument to 'add'", lit);
++      adding = lit;
++      c = new AddCall (lit);
++    } else if (!strcmp (keyword, "assume")) {
++      if (!first) error ("argument to 'assume' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid argument '%s' to 'assume'", first);
++      if (second)
++        error ("additional argument '%s' to 'assume'", second);
++      if (enforce && (!lit || lit == INT_MIN))
++        error ("invalid literal '%d' as argument to 'assume'", lit);
++      c = new AssumeCall (lit);
++    } else if (!strcmp (keyword, "solve")) {
++      if (first && !parse_int_str (first, lit))
++        error ("invalid argument '%s' to 'solve'", first);
++      if (first && lit != 0 && lit != 10 && lit != 20)
++        error ("invalid result argument '%d' to 'solve'", lit);
++      assert (!second);
++      if (first) c = new SolveCall (lit);
++      else       c = new SolveCall ();
++      solved++;
++    } else if (!strcmp (keyword, "simplify")) {
++      if (!first)
++        error ("argument to 'simplify' missing");
++      int rounds;
++      if (!parse_int_str (first, rounds) || rounds < 0)
++        error ("invalid argument '%s' to 'simplify'", first);
++      int tmp;
++      if (second && !parse_int_str (second, tmp))
++        error ("invalid second argument '%s' to 'simplify'", second);
++      if (second && tmp != 0 && tmp != 10 && tmp != 20)
++        error ("invalid second argument '%d' to 'solve'", tmp);
++      if (second) c = new SimplifyCall (rounds, tmp);
++      else        c = new SimplifyCall (rounds);
++      solved++;
++    } else if (!strcmp (keyword, "val")) {
++      if (!first) error ("first argument to 'val' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid first argument '%s' to 'val'", first);
++      if (enforce && (!lit || lit == INT_MIN))
++        error ("invalid literal '%d' as argument to 'val'", lit);
++      if (second && !parse_int_str (second, val))
++        error ("invalid second argument '%s' to 'val'", second);
++      if (second && val != -1 && val != 0 && val != -1)
++        error ("invalid result argument '%d' to 'val", val);
++      if (second) c = new ValCall (lit, val);
++      else        c = new ValCall (lit);
++    } else if (!strcmp (keyword, "fixed")) {
++      if (!first) error ("first argument to 'fixed' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid first argument '%s' to 'fixed'", first);
++      if (enforce && (!lit || lit == INT_MIN))
++        error ("invalid literal '%d' as argument to 'fixed'", lit);
++      if (second && !parse_int_str (second, val))
++        error ("invalid second argument '%s' to 'fixed'", second);
++      if (second && val != -1 && val != 0 && val != -1)
++        error ("invalid result argument '%d' to 'fixed", val);
++      if (second) c = new FixedCall (lit, val);
++      else        c = new FixedCall (lit);
++    } else if (!strcmp (keyword, "failed")) {
++      if (!first) error ("first argument to 'failed' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid first argument '%s' to 'failed'", first);
++      if (enforce && (!lit || lit == INT_MIN))
++        error ("invalid literal '%d 'as argument to 'failed'", lit);
++      if (second && !parse_int_str (second, val))
++        error ("invalid second argument '%s' to 'failed'", second);
++      if (second && val != 0 && val != -1)
++        error ("invalid result argument '%d' to 'failed", val);
++      if (second) c = new FailedCall (lit, val);
++      else        c = new FailedCall (lit);
++    } else if (!strcmp (keyword, "freeze")) {
++      if (!first) error ("argument to 'freeze' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid argument '%s' to 'freeze'", first);
++      if (enforce && (!lit || lit == INT_MIN))
++        error ("invalid literal %d as argument to 'freeze'", lit);
++      if (second)
++        error ("additional argument '%s' to 'freeze'", second);
++      c = new FreezeCall (lit);
++    } else if (!strcmp (keyword, "melt")) {
++      if (!first) error ("argument to 'melt' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid argument '%s' to 'melt'", first);
++      if (enforce && (!lit || lit == INT_MIN))
++        error ("invalid literal '%d' as argument to 'melt'", lit);
++      if (second) error ("additional argument '%s' to 'melt'", second);
++      c = new MeltCall (lit);
++    } else if (!strcmp (keyword, "frozen")) {
++      if (!first) error ("first argument to 'frozen' missing");
++      if (!parse_int_str (first, lit))
++        error ("invalid first argument '%s' to 'frozen'", first);
++      if (second && !parse_int_str (second, val))
++        error ("invalid second argument '%s' to 'frozen'", second);
++      if (second && val != 0 && val != 1)
++        error ("invalid result argument '%d' to 'frozen'", val);
++      if (second) c = new FrozenCall (lit, val);
++      else        c = new FrozenCall (lit);
++    } else if (!strcmp (keyword, "dump")) {
++      if (first)
++        error ("additional argument '%s' to 'dump'", first);
++      c = new DumpCall ();
++    } else if (!strcmp (keyword, "stats")) {
++      if (first)
++        error ("additional argument '%s' to 'stats'", first);
++      c = new StatsCall ();
++    } else if (!strcmp (keyword, "reset")) {
++      if (first)
++        error ("additional argument '%s' to 'reset'", first);
++      c = new ResetCall ();
++    } else error ("invalid keyword '%s'", keyword);
++
++    // This checks the legal structure of traces described above.
++    //
++    if (enforce) {
++
++      if (!state && c->type != Call::INIT)
++        error ("first call has to be an 'init' call");
++
++      if (state == Call::RESET)
++        error ("'%s' after 'reset'", c->keyword ());
++
++      if (adding && c->type != Call::ADD && c->type != Call::RESET)
++        error ("'%s' after 'add %d' without 'add 0'",
++          c->keyword (), adding);
++
++      int new_state = state;
++
++      switch (c->type) {
++
++        case Call::INIT:
++          if (state) error ("invalid second 'init' call");
++          new_state = Call::CONFIG;
++          break;
++
++        case Call::SET:
++          if (!solved && state == Call::BEFORE) {
++            assert (before_trigger);
++            error ("'set' can only be called after 'init' before '%s %d'",
++              before_trigger->keyword (), before_trigger->arg);
++          } else if (state != Call::CONFIG)
++            error ("'set' can only be called right after 'init'");
++          assert (new_state == Call::CONFIG);
++          break;
++
++        case Call::ADD:
++        case Call::ASSUME:
++          if (state != Call::BEFORE) before_trigger = c;
++          new_state = Call::BEFORE;
++          break;
++
++        case Call::VAL:
++        case Call::FAILED:
++          if (!solved && (state == Call::CONFIG || state == Call::BEFORE))
++            error ("'%s' can only be called after 'solve'", c->keyword ());
++          if (solved && state == Call::BEFORE) {
++            assert (before_trigger);
++            error ("'%s' only valid after last 'solve' and before '%s %d'",
++              c->keyword (),
++              before_trigger->keyword (), before_trigger->arg);
++          }
++          assert (state == Call::SOLVE ||
++                  state == Call::SIMPLIFY ||
++                  state == Call::AFTER);
++          new_state = Call::AFTER;
++          break;
++
++        case Call::SOLVE:
++        case Call::SIMPLIFY:
++        case Call::RESET:
++           new_state = c->type;
++           break;
++
++        default:
++          break;
++      }
++
++      state = new_state;
++    }
++
++#ifdef LOGGING
++    if (trace.size () == 1 && mobical.add_set_log_to_true)
++      trace.push_back (new SetCall ("log", 1));
++#endif
++
++    if (c && mobical.add_dump_before_solve &&
++        (c->type == Call::SOLVE || c->type == Call::SIMPLIFY))
++      trace.push_back (new DumpCall ());
++
++    trace.push_back (c);
++
++    if (c && mobical.add_stats_after_solve &&
++        (c->type == Call::SOLVE || c->type == Call::SIMPLIFY))
++      trace.push_back (new StatsCall ());
++
++    lineno++;
++  }
++}
++
++/*------------------------------------------------------------------------*/
++
++bool Mobical::is_unsigned_str (const char * str) {
++  const char * p = str;
++  if (!*p) return false;
++  if (!isdigit (*p++)) return false;
++  while (isdigit (*p)) p++;
++  return !*p;
++}
++
++uint64_t Mobical::parse_seed (const char * str) {
++  const uint64_t max = ~ (uint64_t) 0;
++  uint64_t res = 0;
++  for (const char * p = str; *p; p++) {
++    if (max/10 < res)
++      die ("invalid seed '%s' (too many digits)", str);
++    res *= 10;
++    assert (isdigit (*p));
++    unsigned digit = *p - '0';
++    if (max - digit < res)
++      die ("invalid seed '%s' (too large)", str);
++    res += digit;
++  }
++  return res;
++}
++
++/*------------------------------------------------------------------------*/
++
++void Mobical::header () {
++  terminal.blue ();
++  cerr << "calls";
++  terminal.magenta ();
++  cerr << " vars";
++  terminal.yellow ();
++  cerr << " clauses";
++  terminal.normal ();
++}
++
++/*------------------------------------------------------------------------*/
++
++extern "C" {
++#include <sys/mman.h>
++}
++
++Mobical::Mobical ()
++:
++  mode (0),
++  verbose (false),
++#ifdef LOGGING
++  add_set_log_to_true (false),
++#endif
++  add_dump_before_solve (false),
++  add_stats_after_solve (false),
++  shrinking (false),
++  running (false),
++  time_limit (DEFAULT_TIME_LIMIT),
++  space_limit (DEFAULT_SPACE_LIMIT),
++  terminal (terr),
++#ifndef QUIET
++  progress_counter (0),
++  last_progress_time (0),
++#endif
++  traces (0),
++  spurious (0)
++{
++  const int prot = PROT_READ | PROT_WRITE;
++  const int flags = MAP_ANONYMOUS | MAP_SHARED;
++  shared = (Shared*) mmap (0, sizeof *shared, prot, flags, 0, 0);
++}
++
++Mobical::~Mobical () {
++  if (shared) munmap (shared, sizeof *shared);
++}
++
++void Mobical::catch_signal (int) {
++  if ((terminal && (mode & RANDOM)) || shrinking || running)
++    cerr << endl;
++  terminal.reset ();
++  if (Trace::executed && !Trace::failed && !Trace::ok)
++    assert (mode & (INPUT | SEED)), Trace::failed = 1;
++  print_statistics ();
++}
++
++/*------------------------------------------------------------------------*/
++
++int Mobical::main (int argc, char ** argv) {
++
++  // First parse command line options and determine mode.
++  //
++  const char * seed_str = 0;
++  const char * input_path = 0;
++  const char * output_path = 0;
++
++  long limit = -1;
++
++  // Error message in 'die' also uses colors.
++  //
++  for (int i = 1; i < argc; i++)
++    if (is_color_option (argv[i]))
++      tout.force_colors (), terr.force_colors ();
++    else if (is_no_color_option (argv[i]))
++      terminal.force_no_colors ();
++    else if (!strcmp (argv[i], "--no-terminal"))
++      terminal.disable ();
++
++  for (int i = 1; i < argc; i++) {
++    if (!strcmp (argv[i], "-h")) {
++       printf (USAGE, DEFAULT_TIME_LIMIT, DEFAULT_SPACE_LIMIT);
++       exit (0);
++    } else if (!strcmp (argv[i], "--version"))
++      puts (version ()), exit (0);
++    else if (!strcmp (argv[i], "--build")) {
++      tout.disable ();
++      Solver::build (stdout, "");
++      exit (0);
++    } else if (!strcmp (argv[i], "-v")) verbose = true;
++    else if (is_color_option (argv[i]))
++      ;
++    else if (is_no_color_option (argv[i]))
++      ;
++    else if (!strcmp (argv[i], "--no-terminal"))
++      assert (!terminal);
++    else if (!strcmp (argv[i], "--do-not-execute"))
++      donot.execute = true;
++    else if (!strcmp (argv[i], "--do-not-fork"))
++      donot.fork = true;
++    else if (!strcmp (argv[i], "--do-not-enforce-contracts"))
++      donot.enforce = true;
++    else if (!strcmp (argv[i], "--no-seeds"))
++      donot.seeds = true;
++    else if (!strcmp (argv[i], "--do-not-shrink") ||
++             !strcmp (argv[i], "--do-not-shrink-at-all"))
++      donot.shrink.atall = true;
++    else if (!strcmp (argv[i], "--do-not-add-options") ||
++             !strcmp (argv[i], "--do-not-add-options-before-shrinking"))
++      donot.add = true;
++    else if (!strcmp (argv[i], "--do-not-shrink-phases"))
++      donot.shrink.phases = true;
++    else if (!strcmp (argv[i], "--do-not-shrink-clauses"))
++      donot.shrink.clauses = true;
++    else if (!strcmp (argv[i], "--do-not-shrink-literals"))
++      donot.shrink.literals = true;
++    else if (!strcmp (argv[i], "--do-not-shrink-basic") ||
++             !strcmp (argv[i], "--do-not-shrink-basic-calls"))
++      donot.shrink.basic = true;
++    else if (!strcmp (argv[i], "--do-not-shrink-options"))
++      donot.shrink.options = true;
++    else if (!strcmp (argv[i], "--do-not-disable") ||
++             !strcmp (argv[i], "--do-not-disable-options"))
++      donot.disable = true;
++    else if (!strcmp (argv[i], "--do-not-shrink-variables"))
++      donot.map = true;
++    else if (!strcmp (argv[i], "--do-not-reduce") ||
++             !strcmp (argv[i], "--do-not-reduce-values") ||
++             !strcmp (argv[i], "--do-not-reduce-option-values"))
++      donot.reduce = true;
++    else if (!strcmp (argv[i], "--small")) force.size = SMALL;
++    else if (!strcmp (argv[i], "--medium")) force.size = MEDIUM;
++    else if (!strcmp (argv[i], "--big")) force.size = BIG;
++    else if (!strcmp (argv[i], "-l") || !strcmp (argv[i], "--log")) {
++#ifdef LOGGING
++      add_set_log_to_true = true;
++#else
++      die ("can not force logging with '%s' (compiled without '-DLOGGING')",
++        argv[i]);
++#endif
++    } else if (!strcmp (argv[i], "-d") || !strcmp (argv[i], "--dump")) {
++      add_dump_before_solve = true;
++    } else if (!strcmp (argv[i], "-s") || !strcmp (argv[i], "--stats")) {
++      add_stats_after_solve = true;
++    } else if (!strcmp (argv[i], "-L")) {
++      if (limit >= 0) die ("multiple '-L' options (try '-h')");
++      if (++i == argc) die ("argument to '-L' missing (try '-h')");
++      if (!is_unsigned_str (argv[i]) || (limit = atol (argv[i])) < 0)
++        die ("invalid argument '%s' to '-L' (try '-h')", argv[i]);
++    } else if (!strcmp (argv[i], "--time")) {
++      if (++i == argc) die ("argument to '--time' missing (try '-h')");
++      if (!is_unsigned_str (argv[i]) ||
++          (time_limit = atol (argv[i])) < 0 || time_limit > 1e9)
++        die ("invalid argument '%s' to '--time' (try '-h')", argv[i]);
++    } else if (!strcmp (argv[i], "--space")) {
++      if (++i == argc) die ("argument to '--space' missing (try '-h')");
++      if (!is_unsigned_str (argv[i]) ||
++          (space_limit = atol (argv[i])) < 0 || space_limit > 1e9)
++        die ("invalid argument '%s' to '--space' (try '-h')", argv[i]);
++    } else if (!strcmp (argv[i], "--do-not-ignore-resource-limits")) {
++      donot.ignore_resource_limits = true;
++    } else if (argv[i][0] == '-' && is_unsigned_str (argv[i] + 1)) {
++      force.phases = atoi (argv[i] + 1);
++      if (force.phases < 0)
++        die ("invalid number of phases '%s'", argv[i]);
++    } else if (argv[i][0] == '-' && argv[i][1])
++      die ("invalid option '%s' (try '-h')", argv[i]);
++    else if (is_unsigned_str (argv[i])) {
++      if (seed_str)
++        die ("can not handle multiple seeds '%s' and '%s' (try '-h')",
++          seed_str, argv[i]);
++      if (input_path)
++        die ("can not combine input trace '%s' and seed '%s' (try '-h')",
++          input_path, argv[i]);
++      seed_str = argv[i];
++    } else if (output_path) {
++      assert (input_path);
++      die ("too many trace files specified: '%s', '%s' and '%s' (try '-h')",
++        input_path, output_path, argv[i]);
++    } else if (input_path) {
++      if (seed_str)
++        die ("seed '%s' with two output files '%s' and '%s' ",
++          seed_str, input_path, argv[i]);
++      if (strcmp (input_path, "-") && !strcmp (input_path, argv[i]))
++        die ("input '%s' and output '%s' are the same",
++          input_path, argv[i]);
++      output_path = argv[i];
++    } else {
++      if (!seed_str && strcmp (argv[i], "-") && !File::exists (argv[i]))
++        die ("can not access input trace '%s' (try '-h')", argv[i]);
++      input_path = argv[i];
++    }
++  }
++
++  /*----------------------------------------------------------------------*/
++
++  // If a seed and a file (in that order) are specified the file is actually
++  // not an input file but an output file.  To streamline the code below
++  // swap input and output here.
++  //
++  if (input_path && seed_str) {
++    assert (!output_path);
++    output_path = input_path;
++    input_path = 0;
++  }
++
++  if (output_path && !File::writable (output_path))
++    die ("can not write output trace '%s' (try '-h')", output_path);
++
++  /*----------------------------------------------------------------------*/
++
++  // Check illegal combinations of options.
++
++  if (input_path && donot.seeds)
++    die ("can not use '--no-seeds' while specifying input '%s' explicitly",
++      input_path);
++
++  if (input_path && limit >= 0)
++    die ("can not combine '-L' and input '%s'", input_path);
++
++  if (output_path && limit >= 0)
++    die ("can not combine '-L' and output '%s'", output_path);
++
++  if (!output_path && donot.execute)
++    die ("can not use '--do-no-execute' without '<output>'");
++
++  if (!input_path && donot.enforce)
++    die ("can not use '--do-not-enforce-contracts' without '<input>'");
++
++  if (output_path && donot.enforce)
++    die ("can not use '--do-not-enforce-contracts' "
++      "with both '<input>' and '<output>'");
++
++  /*----------------------------------------------------------------------*/
++
++  // Set mode.
++
++  if (limit >= 0)               mode = RANDOM;
++  else {
++    if (seed_str || input_path) mode = 0;
++    else                        mode = RANDOM;
++    if (seed_str)               mode |= SEED;
++    if (input_path)             mode |= INPUT;
++    if (output_path)            mode |= OUTPUT;
++  }
++  check_mode_valid ();
++
++  /*----------------------------------------------------------------------*/
++
++  // Print banner.
++
++  prefix ();
++  terminal.magenta (1);
++  fputs ("Model Based Tester for the CaDiCaL SAT Solver Library\n", stderr);
++  terminal.normal ();
++  prefix ();
++  terminal.magenta (1);
++  fputs ("Copyright (c) 2018-2019 Armin Biere, JKU Linz\n", stderr);
++  terminal.normal ();
++  empty_line ();
++  Solver::build (stderr, prefix_string ());
++  terminal.normal ();
++  empty_line ();
++
++  /*----------------------------------------------------------------------*/
++
++  // Print resource limits (per executed trace).
++
++  prefix ();
++  if (mobical.donot.fork)
++    cerr << "not using any time limit due to '--do-not-fork'";
++  else if (time_limit == DEFAULT_TIME_LIMIT)
++    cerr << "using default time limit of "
++         << time_limit << " seconds";
++  else if (time_limit)
++    cerr << "using explicitly specified time limit of "
++         << time_limit << " seconds";
++  else
++    cerr << "explicitly using no time limit";
++  cerr << endl << flush;
++
++  prefix ();
++  if (mobical.donot.fork)
++    cerr << "not using any space limit due to '--do-not-fork'";
++  else if (space_limit == DEFAULT_SPACE_LIMIT)
++    cerr << "using default space limit of "
++         << space_limit << " MB";
++  else if (space_limit)
++    cerr << "using explicitly specified space limit of "
++         << space_limit << " MB";
++  else
++    cerr << "explicitly using no space limit";
++  cerr << endl << flush;
++
++  /*----------------------------------------------------------------------*/
++
++  // Report mode.
++
++  if (mode & RANDOM) {
++    prefix ();
++    if (limit >= 0)
++      cerr << "randomly generating " << limit << " traces" << endl;
++    else {
++      cerr << "randomly generating traces";
++      if (terminal) {
++        terminal.magenta ();
++        cerr << " (press ";
++        terminal.blue ();
++        cerr << "'<control-c>'";
++        terminal.magenta ();
++        cerr << " to stop)";
++        terminal.normal ();
++      }
++      cerr << endl;
++    }
++    empty_line ();
++  }
++  if (mode & SEED) {
++    assert (seed_str);
++    prefix ();
++    cerr << "generating single trace from seed '"
++         << seed_str << '\'' << endl;
++  }
++  if (mode & INPUT) {
++    assert (input_path);
++    prefix ();
++    cerr << "reading single trace from input '"
++         << input_path << '\'' << endl;
++  }
++  if (mode & OUTPUT) {
++    assert (output_path);
++    prefix ();
++    cerr << "writing "
++         << (donot.shrink.atall ? "original" : "shrunken")
++         << " trace to output '"
++         << output_path << '\'' << endl;
++  }
++  cerr << flush;
++
++  /*----------------------------------------------------------------------*/
++
++  Signal::set (this);
++
++  int res = 0;
++
++  if (mode & (SEED | INPUT)) {   // trace given through input or seed
++
++    prefix ();
++    cerr << right << setw (58) << "";
++    header ();
++    cerr << endl;
++    hline ();
++
++    Trace trace;
++
++    if (seed_str) {                                     // seed
++
++      prefix ();
++      cerr << left << setw (13) << "seed:";
++      assert (is_unsigned_str (seed_str));
++      uint64_t seed = parse_seed (seed_str);
++      terminal.green ();
++      cerr << setfill ('0') << right << setw (20) << seed;
++      terminal.normal ();
++      cerr << setfill (' ') << setw (24) << "";
++      Trace::generated++;
++
++      trace.generate (0, seed);
++
++    } else {                                            // input
++
++      Reader reader (*this, trace, input_path);
++      reader.parse ();
++
++      prefix ();
++      cerr << left << setw (13) << "input: ";
++      assert (input_path);
++      cerr << left << setw (44) << input_path;
++    }
++
++    cerr << ' ';
++    summarize (trace);
++    cerr << endl << flush;
++
++    if (output_path) {
++
++      if (!donot.execute) {
++
++        res = trace.fork_and_execute ();
++        if (res) {
++          res = trace.fork_and_execute ();
++          if (!res) spurious++;
++        }
++
++        if (res) {
++
++          terminal.cursor (false);
++
++          Trace::failed++;
++          trace.shrink (res);                           // shrink
++          if (!verbose && !terminal) cerr << endl;
++          else terminal.erase_line_if_connected_otherwise_new_line ();
++
++        } else Trace::ok++;
++      }
++
++      prefix ();
++      cerr << left << setw (13) << "output:";
++
++      trace.write_path (output_path);                   // output
++
++      if (res) terminal.red (true);
++      cerr << left << setw (44);
++      if (!strcmp (output_path, "-")) cerr << "<stdout>";
++      else                            cerr << output_path;
++      terminal.normal ();
++      cerr << ' ';
++      summarize (trace);
++      cerr << endl << flush;
++
++    } else {
++      trace.execute ();                         // execute
++      Trace::ok++;
++    }
++
++  } else {             // otherwise generate random traces forever
++
++    Random random;          // initialized by time and machine id
++
++    if (seed_str) {
++      uint64_t seed = parse_seed (seed_str);
++      terminal.green ();
++      random = Random (seed);
++    }
++
++    prefix ();
++    cerr << "start seed ";
++    terminal.green ();
++    cerr << random.seed ();
++    terminal.normal ();
++    cerr << endl;
++    empty_line ();
++
++    if (limit < 0) limit = LONG_MAX;
++
++    prefix ();
++    cerr << left << setw (14) << "count";
++    terminal.green ();
++    cerr << "seed";
++    terminal.black ();
++    cerr << '/';
++    terminal.red ();
++    cerr << "buggy";
++    terminal.black ();
++    cerr << '/';
++    terminal.yellow ();
++    cerr << "reducing";
++    terminal.black ();
++    cerr << '/';
++    terminal.red (true);
++    cerr << "reduced";
++    cerr << left << setw (17) << "";
++    header ();
++    cerr << endl;
++    hline ();
++
++    terminal.cursor (false);
++
++    for (traces = 1; traces <= limit ; traces++) {
++
++      if (!donot.seeds) {
++        prefix ();
++        cerr << ' ' << left << setw (15) << traces << ' ';
++        terminal.green ();
++        cerr << setfill ('0') << right << setw (20) << random.seed ();
++        terminal.normal ();
++        cerr << setfill (' ') << flush;
++      }
++
++      Trace trace;
++      Trace::generated++;
++      trace.generate (traces, random.seed ());          // generate
++
++      if (!donot.seeds) {
++        cerr << setw (21) << "";
++        summarize (trace);
++        terminal.erase_until_end_of_line ();
++        cerr << flush;
++      }
++
++      running = true;
++      res = trace.fork_and_execute ();                  // execute
++      if (res) {
++        res = trace.fork_and_execute ();
++        if (!res) spurious++;
++      }
++      if (res) Trace::failed++; else Trace::ok++;
++
++      if (!donot.seeds)
++        terminal.erase_line_if_connected_otherwise_new_line ();
++
++      if (res) {                                        // failed
++
++        prefix ();
++        cerr << ' ' << left << setw (11) << traces << ' ';
++        terminal.red ();
++        trace.write_prefixed_seed ("bug");              // output
++        terminal.normal ();
++        cerr << setw (15) << "";
++        summarize (trace);
++        if (terminal) cerr << endl << flush;
++        running = false;
++
++        if (!donot.shrink.atall) {
++          trace.shrink (res);                           // shrink
++          if (!terminal && !verbose) cerr << endl;
++          else terminal.erase_line_if_connected_otherwise_new_line ();
++        }
++
++        prefix ();
++        cerr << ' ' << left << setw (11) << traces << ' ';
++
++        terminal.red (true);
++        trace.write_prefixed_seed ("red");              // output
++        terminal.normal ();
++        cerr << setw (15) << "";
++        summarize (trace, true);
++        cerr << endl << flush;
++      }
++
++      random.next ();
++    }
++
++  }
++
++  Signal::reset ();
++
++  terminal.reset ();
++  print_statistics ();
++
++  return Trace::failed > 0;
++}
++
++/*------------------------------------------------------------------------*/
++} // End of 'namespace CaDiCaL'.
++/*------------------------------------------------------------------------*/
++
++int main (int argc, char ** argv) {
++  return CaDiCaL::mobical.main (argc, argv);
++}
+diff -Naur solvers/cadical/options.cpp solvers/cdc/options.cpp
+--- solvers/cadical/options.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/options.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -2,27 +2,6 @@
+ 
+ namespace CaDiCaL {
+ 
+-/*------------------------------------------------------------------------*/
+-
+-// By default, e.g., for library usage, the 'opts.report' value is zero
+-// ('false') but can be set to '1' by the stand alone solver.  Using here
+-// a static default value avoids that the stand alone solver reports that
+-// '--report=1' is different from the default in 'print ()' below.
+-//
+-int Options::report_default_value;
+-
+-/*------------------------------------------------------------------------*/
+-
+-// The order of initializations of static objects is undefined and thus we
+-// can not assume that this table is already initialized if a solver and
+-// thus the constructor of 'Options' is called.  Therefore we just have to
+-// reinitialize this table in every call to 'Options::Options'.  This does
+-// not produce a data race even for parallel initialization since the
+-// same values are written by all threads under the assumption that the
+-// 'report_default_value' is set before any solver is initialized.  We do
+-// have to perform this static initialization though, since 'has' is
+-// static and does not require that the 'Options' constructor was called.
+-
+ Option Options::table [] = {
+ #define OPTION(N,V,L,H,O,D) \
+   { #N, (int) V, (int) L, (int) H, (int) O, D },
+@@ -145,7 +124,7 @@
+ {
+   assert (number_of_options == sizeof Options::table / sizeof (Option));
+ 
+-  // First initialize them according to defaults in 'options.hpp'.
++  // First initialize them according to default in 'options.hpp'.
+   //
+   const char * prev = "";
+   size_t i = 0;
+@@ -163,15 +142,13 @@
+     assert (&val (i) == &N); \
+     /* The order of initializing static data is undefined and thus */ \
+     /* it might be the case that the 'table' is not initialized yet. */ \
+-    /* Thus this construction just reinitializes the table too even */ \
+-    /* though it might not be necessary. */ \
+     assert (!table[i].name || !strcmp (table[i].name, #N)); \
+-    table[i] = { #N, (int)(V), (int)(L), (int)(H), (int)(O), D }; \
+     prev = #N; \
+     i++; \
+   } while (0);
+   OPTIONS
+ # undef OPTION
++  (void) i;
+ 
+   // Check consistency in debugging mode.
+   //
+@@ -180,6 +157,19 @@
+   assert (!has ("aaaaa"));
+   assert (!has ("non-existing-option"));
+   assert (!has ("zzzzz"));
++# define OPTION(N,V,L,H,O,D) \
++  do {  \
++    Option * o = has (#N); \
++    assert (o); \
++    assert (!strcmp (o->name, #N)); \
++    assert (o->def == (int) V); \
++    assert (o->lo == (int) L); \
++    assert (o->hi == (int) H); \
++    assert (o->optimizable == (int) O); \
++    assert (o->val (this) == (int) V); \
++  } while (0);
++  OPTIONS
++# undef OPTION
+ #endif
+ 
+   // Now overwrite default options with environment values.
+@@ -296,7 +286,7 @@
+     val = max_val;
+   }
+ 
+-  int64_t factor;
++  long factor;
+   switch (val) {
+     default: factor = 1; break;
+     case 1: factor = 10; break;
+@@ -307,11 +297,11 @@
+ #define OPTION(N,V,L,H,O,D) \
+   do { \
+     if (!(O)) break; \
+-    int64_t new_val = factor * (int64_t) (V); \
++    long new_val = factor * (long) (V); \
+     if (new_val > (H)) new_val = (H); \
+     if (new_val == (int) (V)) break; \
+     LOG ("optimization mode '%d' for '%s' " \
+-      "gives '%" PRId64 "' instead of '%d", \
++      "gives '%ld' instead of '%d", \
+       val, #N, new_val, (int) (V)); \
+     assert (new_val <= INT_MAX); \
+     N = (int) new_val; \
+@@ -320,7 +310,7 @@
+   OPTIONS
+ #undef OPTION
+   if (increased)
+-    MSG ("optimization mode '-O%d' increased %d limits by '%" PRId64 "'",
++    MSG ("optimization mode '-O%d' increased %d limits by '%ld'",
+       val, increased, factor);
+ 
+   switch (val) {
+@@ -333,11 +323,11 @@
+ #define OPTION(N,V,L,H,O,D) \
+   do { \
+     if (!has_suffix (#N, "rounds")) break; \
+-    int64_t new_val = factor * (int64_t) (V); \
++    long new_val = factor * (long) (V); \
+     if (new_val > (H)) new_val = (H); \
+     if (new_val == (int) (V)) break; \
+     LOG ("optimization mode '%d' for '%s' " \
+-      "gives '%" PRId64 "' instead of '%d", \
++      "gives '%ld' instead of '%d", \
+       val, #N, new_val, (int) (V)); \
+     assert (new_val <= INT_MAX); \
+     N = (int) new_val; \
+@@ -346,7 +336,7 @@
+   OPTIONS
+ #undef OPTION
+   if (increased)
+-    MSG ("optimization mode '-O%d' increased %d limits by '%" PRId64 "'",
++    MSG ("optimization mode '-O%d' increased %d limits by '%ld'",
+       val, increased, factor);
+ }
+ 
+diff -Naur solvers/cadical/options.hpp solvers/cdc/options.hpp
+--- solvers/cadical/options.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/options.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -34,7 +34,7 @@
+ OPTION( checkfrozen,       0,  0,  1, 0, "check all frozen semantics") \
+ OPTION( checkproof,        1,  0,  1, 0, "check proof internally") \
+ OPTION( checkwitness,      1,  0,  1, 0, "check witness internally") \
+-OPTION( chrono,            1,  0,  2, 0, "chronological backtracking") \
++OPTION( chrono,            1,  0,  1, 0, "chronological backtracking") \
+ OPTION( chronoalways,      0,  0,  1, 0, "force always chronological") \
+ OPTION( chronolevelim,   1e2,  0,1e9, 0, "chronological level limit") \
+ OPTION( chronoreusetrail,  1,  0,  1, 0, "reuse trail chronologically") \
+@@ -101,7 +101,6 @@
+ OPTION( proberounds,       1,  1, 16, 0, "probing rounds" ) \
+ OPTION( profile,           2,  0,  4, 0, "profiling level") \
+ QUTOPT( quiet,             0,  0,  1, 0, "disable all messages") \
+-OPTION( radixsortlim,    800,  0,1e9, 0, "radix sort limit") \
+ OPTION( realtime,          0,  0,  1, 0, "real instead of process time") \
+ OPTION( reduce,            1,  0,  1, 0, "reduce useless clauses") \
+ OPTION( reduceint,       300, 10,1e6, 0, "reduce interval") \
+@@ -111,7 +110,7 @@
+ OPTION( reluctantmax,1048576,  0,1e9, 0, "reluctant doubling period") \
+ OPTION( rephase,           1,  0,  1, 0, "enable resetting phase") \
+ OPTION( rephaseint,      1e3,  1,1e9, 0, "rephase interval") \
+-OPTION( report,report_default_value,  0,  1, 0, "enable reporting") \
++OPTION( report,            1,  0,  1, 0, "enable reporting") \
+ OPTION( reportall,         0,  0,  1, 0, "report even if not successful") \
+ OPTION( reportsolve,       0,  0,  1, 0, "use solving not process time") \
+ OPTION( restart,           1,  0,  1, 0, "enable restarts") \
+@@ -234,12 +233,6 @@
+     int & val, const char * name, const int L, const int H);
+ 
+ public:
+-  
+-  // For library usage we disable reporting by default while for the stand
+-  // alone SAT solver we enable it by default.  This default value has to
+-  // be set before the constructor of 'Options' is called.
+-  //
+-  static int report_default_value;
+ 
+   Options (Internal *);
+ 
+diff -Naur solvers/cadical/probe.cpp solvers/cdc/probe.cpp
+--- solvers/cadical/probe.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/probe.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -232,7 +232,7 @@
+   require_mode (PROBE);
+   assert (!unsat);
+   START (propagate);
+-  int64_t before = propagated2 = propagated;
++  long before = propagated2 = propagated;
+   while (!conflict) {
+     if (propagated2 != trail.size ()) probe_propagate2 ();
+     else if (propagated != trail.size ()) {
+@@ -290,7 +290,7 @@
+       }
+     } else break;
+   }
+-  int64_t delta = propagated2 - before;
++  long delta = propagated2 - before;
+   stats.propagations.probe += delta;
+   if (conflict) LOG (conflict, "conflict");
+   STOP (propagate);
+@@ -434,7 +434,7 @@
+     //
+     if (propfixed (probe) >= stats.all.fixed) continue;
+ 
+-    LOG ("scheduling probe %d negated occs %" PRId64 "", probe, noccs (-probe));
++    LOG ("scheduling probe %d negated occs %ld", probe, noccs (-probe));
+     probes.push_back (probe);
+   }
+ 
+@@ -444,7 +444,7 @@
+   shrink_vector (probes);
+ 
+   PHASE ("probe-round", stats.probingrounds,
+-    "scheduled %" PRId64 " literals %.0f%%",
++    "scheduled %ld literals %.0f%%",
+     probes.size (), percent (probes.size (), 2*max_var));
+ }
+ 
+@@ -474,7 +474,7 @@
+     if (have_pos_bin_occs) lit = -lit;
+     assert (!noccs (lit)), assert (noccs (-lit) > 0);
+     if (propfixed (lit) >= stats.all.fixed) continue;
+-    LOG ("keeping probe %d negated occs %" PRId64 "", lit, noccs (-lit));
++    LOG ("keeping probe %d negated occs %ld", lit, noccs (-lit));
+     *j++ = lit;
+   }
+   size_t remain = j - probes.begin ();
+@@ -540,7 +540,7 @@
+   // (say %5) of probing propagations in each probing with a lower bound of
+   // 'opts.probmineff'.
+   //
+-  int64_t delta = stats.propagations.search;
++  long delta = stats.propagations.search;
+   delta -= last.probe.propagations;
+   delta *= 1e-3 * opts.probereleff;
+   if (delta < opts.probemineff) delta = opts.probemineff;
+@@ -548,15 +548,15 @@
+   delta += 2l * active ();
+ 
+   PHASE ("probe-round", stats.probingrounds,
+-    "probing limit of %" PRId64 " propagations ", delta);
++    "probing limit of %ld propagations ", delta);
+ 
+-  int64_t limit = stats.propagations.probe + delta;
++  long limit = stats.propagations.probe + delta;
+ 
+   int old_failed = stats.failed;
+ #ifndef QUIET
+-  int64_t old_probed = stats.probed;
++  long old_probed = stats.probed;
+ #endif
+-  int64_t old_hbrs = stats.hbrs;
++  long old_hbrs = stats.hbrs;
+ 
+   if (!probes.empty ()) flush_probes ();
+ 
+@@ -584,7 +584,7 @@
+ 
+   if (unsat) LOG ("probing derived empty clause");
+   else if (propagated < trail.size ()) {
+-    LOG ("probing produced %" PRId64 " units", trail.size () - propagated);
++    LOG ("probing produced %ld units", trail.size () - propagated);
+     if (!propagate ()) {
+       LOG ("propagating units after probing results in empty clause");
+       learn_empty_clause ();
+@@ -593,16 +593,16 @@
+ 
+   int failed = stats.failed - old_failed;
+ #ifndef QUIET
+-  int64_t probed = stats.probed - old_probed;
++  long probed = stats.probed - old_probed;
+ #endif
+-  int64_t hbrs = stats.hbrs - old_hbrs;
++  long hbrs = stats.hbrs - old_hbrs;
+ 
+   PHASE ("probe-round", stats.probingrounds,
+-    "probed %" PRId64 " and found %d failed literals", probed, failed);
++    "probed %ld and found %d failed literals", probed, failed);
+ 
+   if (hbrs)
+     PHASE ("probe-round", stats.probingrounds,
+-      "found %" PRId64 " hyper binary resolvents", hbrs);
++      "found %ld hyper binary resolvents", hbrs);
+ 
+   STOP_SIMPLIFIER (probe, PROBE);
+ 
+@@ -643,11 +643,11 @@
+ 
+   if (!update_limits) return;
+ 
+-  int64_t delta = opts.probeint * (stats.probingphases + 1);
++  long delta = opts.probeint * (stats.probingphases + 1);
+   lim.probe = stats.conflicts + delta;
+ 
+   PHASE ("probe-phase", stats.probingphases,
+-    "new limit at %" PRId64 " conflicts after %" PRId64 " conflicts",
++    "new limit at %ld conflicts after %ld conflicts",
+     lim.probe, delta);
+ 
+   last.probe.reductions = stats.reductions;
+diff -Naur solvers/cadical/propagate.cpp solvers/cdc/propagate.cpp
+--- solvers/cadical/propagate.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/propagate.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -142,7 +142,7 @@
+   // Updating statistics counter in the propagation loops is costly so we
+   // delay until propagation ran to completion.
+   //
+-  int64_t before = propagated;
++  long before = propagated;
+ 
+   while (!conflict && propagated != trail.size ()) {
+ 
+@@ -284,8 +284,8 @@
+             // chronological backtracking but in our experience, this code
+             // first does not really seem to be necessary for correctness,
+             // and further does not improve running time either.
+-	    //
+-            if (opts.chrono > 1) {
++
++            if (opts.chrono) {
+ 
+               const int other_level = var (other).level;
+ 
+diff -Naur solvers/cadical/queue.cpp solvers/cdc/queue.cpp
+--- solvers/cadical/queue.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/queue.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -77,7 +77,7 @@
+   queue.first = queue.last = 0;
+   for (const int idx : shuffle)
+     queue.enqueue (links, idx);
+-  int64_t bumped = queue.bumped;
++  long bumped = queue.bumped;
+   for (int idx = queue.last; idx; idx = links[idx].prev)
+     btab[idx] = bumped--;
+   queue.unassigned = queue.last;
+diff -Naur solvers/cadical/queue.hpp solvers/cdc/queue.hpp
+--- solvers/cadical/queue.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/queue.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -24,7 +24,7 @@
+ 
+   int first, last;    // anchors (head/tail) for doubly linked list
+   int unassigned;     // all variables after this one are assigned
+-  int64_t bumped;     // see 'Internal.update_queue_unassigned'
++  long bumped;        // see 'Internal.update_queue_unassigned'
+ 
+   Queue () : first (0), last (0), unassigned (0), bumped (0) { }
+ 
+diff -Naur solvers/cadical/radix.hpp solvers/cdc/radix.hpp
+--- solvers/cadical/radix.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/radix.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -29,8 +29,7 @@
+ // then as second parameter a function class (similar to the second 'less
+ // than' parameter of 'sort') which can obtain a 'rank' from each element,
+ // on which they are compared.  The 'rank' should be able to turn an element
+-// into a number.  The type of these ranks is determined automatically but
+-// should be 'unsigned'.
++// into a number which can be automatically converted to 'size_t'.
+ 
+ struct pointer_rank {
+   size_t operator () (void * ptr) { return (size_t) ptr; }
+@@ -46,14 +45,13 @@
+ 
+   const size_t l = 8;           // Radix 8, thus byte-wise.
+   const size_t w = (1<<l);      // So many buckets.
+-
+-  const unsigned mask = w - 1;  // Fast mod 'w'.
++  const size_t mask = w - 1;    // Fast mod 'w'.
+ 
+ // Uncomment the following define for large values of 'w' in order to keep
+ // the large bucket array 'count' on the heap instead of the stack.
+ //
+ // #define CADICAL_RADIX_BUCKETS_ON_THE_HEAP
+-//
++
+ #ifdef CADICAL_RADIX_BUCKETS_ON_THE_HEAP
+   size_t * count = new size_t[w];       // Put buckets on the heap.
+ #else
+@@ -64,16 +62,16 @@
+   bool initialized = false;
+   vector<T> v;
+ 
+-  for (size_t i = 0; i < 8 * sizeof (rank (*first)); i += l) {
++  for (size_t i = 0; i < 8 * sizeof (size_t); i += l) {
+ 
+     memset (count, 0, w * sizeof *count);
+ 
+     const I end = c + n;
+     size_t upper = 0, lower = ~upper;
+     for (I p = c; p != end; p++) {
+-      const auto r = rank (*p);
+-      const auto s = r >> i;
+-      const auto m = s & mask;
++      const size_t r = rank (*p);
++      const size_t s = r >> i;
++      const size_t m = s & mask;
+       lower &= s, upper |= s;
+       count[m]++;
+     }
+@@ -88,18 +86,18 @@
+     }
+ 
+     if (!initialized) {
+-      assert (&*c == &*a);	// MS VC++
+-      v.resize (n);
++      assert (c == a);
++      v.reserve (n);
+       b = v.begin ();
+       initialized = true;
+     }
+ 
+-    I d = (&*c == &*a) ? b : a;	// MS VC++
++    I d = (c == a) ? b : a;
+ 
+     for (I p = c; p != end; p++) {
+-      const auto r = rank (*p);
+-      const auto s = r >> i;
+-      const auto m = s & mask;
++      const size_t r = rank (*p);
++      const size_t s = r >> i;
++      const size_t m = s & mask;
+       d[count[m]++] = *p;
+     }
+     c = d;
+@@ -130,15 +128,12 @@
+ // use it everywhere instead of 'rsort' since it requires a fourth
+ // parameter, which is awkward, particular in those situation where we
+ // expect large arrays to be sorted anyhow (such as during sorting the
+-// clauses in an arena or the probes during probing).  The first argument
+-// is the limit up to which we use the standard sort.  Above the limit we
+-// use radix sort.  As usual we do not want to hard code it here (default
+-// is '800') in order to make fuzzing and delta debugging more effective.
++// clauses in arena or the probes during probing).
+ 
+-#define MSORT(LIMIT,FIRST,LAST,RANK,LESS) \
++#define MSORT(FIRST,LAST,RANK,LESS) \
+ do { \
+   const size_t N = LAST - FIRST; \
+-  if (N <= (size_t) (LIMIT)) sort (FIRST, LAST, LESS); \
++  if (N <= 800) sort (FIRST, LAST, LESS); \
+   else rsort (FIRST, LAST, RANK); \
+ } while (0)
+ 
+diff -Naur solvers/cadical/random.hpp solvers/cdc/random.hpp
+--- solvers/cadical/random.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/random.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -1,5 +1,22 @@
+ /*------------------------------------------------------------------------*/
+ 
++// Since 'cstdint' and 'stdint.h' only became available with C11 we
++// provide a work-around which tries to figure out proper 64 bit values
++// during configuration and otherwise uses the types below.
++
++#if !defined (NSTDINT) && !defined(uint64_t) && !defined(uint32_t)
++#include <cstdint>
++#else
++#ifndef uint64_t
++typedef size_t uint64_t;
++#endif
++#ifndef uint32_t
++typedef unsigned uint32_t;
++#endif
++#endif // end of '#if !define(NSTDINT) ...'
++
++/*------------------------------------------------------------------------*/
++
+ // Random number generator.
+ 
+ namespace CaDiCaL {
+diff -Naur solvers/cadical/reduce.cpp solvers/cdc/reduce.cpp
+--- solvers/cadical/reduce.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/reduce.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -195,22 +195,22 @@
+   if (level) unprotect_reasons ();
+ 
+   {
+-    int64_t delta = opts.reduceint * (stats.reductions + 1);
++    long delta = opts.reduceint * (stats.reductions + 1);
+     if (irredundant () > 1e5) {
+       delta *= log (irredundant ()/1e4) / log (10);
+       if (delta < 1) delta = 1;
+     }
+     lim.reduce = stats.conflicts + delta;
+     PHASE ("reduce", stats.reductions,
+-      "new reduce limit %" PRId64 " after %" PRId64 " conflicts",
++      "new reduce limit %ld after %ld conflicts",
+       lim.reduce, delta);
+   }
+ 
+   if (flush) {
+-    PHASE ("flush", stats.flush.count, "new flush increment %" PRId64 "", inc.flush);
++    PHASE ("flush", stats.flush.count, "new flush increment %ld", inc.flush);
+     inc.flush *= opts.flushfactor;
+     lim.flush = stats.conflicts + inc.flush;
+-    PHASE ("flush", stats.flush.count, "new flush limit %" PRId64 "", lim.flush);
++    PHASE ("flush", stats.flush.count, "new flush limit %ld", lim.flush);
+   }
+ 
+   last.reduce.conflicts = stats.conflicts;
+diff -Naur solvers/cadical/reluctant.hpp solvers/cdc/reluctant.hpp
+--- solvers/cadical/reluctant.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/reluctant.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -20,15 +20,15 @@
+ 
+ class Reluctant {
+ 
+-  uint64_t u, v, limit;
+-  uint64_t period, countdown;
++  unsigned long u, v, limit;
++  unsigned long period, countdown;
+   bool trigger, limited;
+ 
+ public:
+ 
+   Reluctant () : period (0), trigger (false) { }
+ 
+-  void enable (int p, int64_t l) {
++  void enable (int p, long l) {
+     assert (p > 0);
+     u = v = 1;
+     period = countdown = p;
+diff -Naur solvers/cadical/rephase.cpp solvers/cdc/rephase.cpp
+--- solvers/cadical/rephase.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/rephase.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -104,7 +104,7 @@
+ 
+   stats.rephased.total++;
+   PHASE ("rephase", stats.rephased.total,
+-    "reached rephase limit %" PRId64 " after %" PRId64 " conflicts",
++    "reached rephase limit %ld after %ld conflicts",
+     lim.rephase, stats.conflicts);
+ 
+   // Report current 'target' and 'best' and then set 'rephased' below, which
+@@ -207,11 +207,11 @@
+   }
+   assert (type);
+ 
+-  int64_t delta = opts.rephaseint * (stats.rephased.total + 1);
++  long delta = opts.rephaseint * (stats.rephased.total + 1);
+   lim.rephase = stats.conflicts + delta;
+ 
+   PHASE ("rephase", stats.rephased.total,
+-    "new rephase limit %" PRId64 " after %" PRId64 " conflicts",
++    "new rephase limit %ld after %ld conflicts",
+     lim.rephase, delta);
+ 
+   // This will trigger to report the effect of this new set of phases at the
+diff -Naur solvers/cadical/resources.cpp solvers/cdc/resources.cpp
+--- solvers/cadical/resources.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/resources.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -63,11 +63,11 @@
+ 
+ size_t current_resident_set_size () {
+   char path[40];
+-  sprintf (path, "/proc/%" PRId64 "/statm", (int64_t) getpid ());
++  sprintf (path, "/proc/%ld/statm", (long) getpid ());
+   FILE * file = fopen (path, "r");
+   if (!file) return 0;
+-  int64_t dummy, rss;
+-  int scanned = fscanf (file, "%" PRId64 " %" PRId64 "", &dummy, &rss);
++  long dummy, rss;
++  int scanned = fscanf (file, "%ld %ld", &dummy, &rss);
+   fclose (file);
+   return scanned == 2 ? rss * sysconf (_SC_PAGESIZE) : 0;
+ }
+diff -Naur solvers/cadical/restart.cpp solvers/cdc/restart.cpp
+--- solvers/cadical/restart.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/restart.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -25,7 +25,7 @@
+     stable = !stable;
+     if (stable) stats.stabphases++;
+     PHASE ("stabilizing", stats.stabphases,
+-      "reached stabilization limit %" PRId64 " after %" PRId64 " conflicts",
++      "reached stabilization limit %ld after %ld conflicts",
+       lim.stabilize, stats.conflicts);
+     inc.stabilize *= opts.stabilizefactor*1e-2;
+     if (inc.stabilize > opts.stabilizemaxint)
+@@ -35,7 +35,7 @@
+       lim.stabilize = stats.conflicts + 1;
+     swap_averages ();
+     PHASE ("stabilizing", stats.stabphases,
+-      "new stabilization limit %" PRId64 " at conflicts interval %" PRId64 "",
++      "new stabilization limit %ld at conflicts interval %ld",
+       lim.stabilize, inc.stabilize);
+     report (stable ? '[' : '{');
+     if (stable) START (stable);
+@@ -78,7 +78,7 @@
+            score_smaller (this)(decision, abs (control[res+1].decision)))
+       res++;
+   } else {
+-    int64_t limit = bumped (decision);
++    long limit = bumped (decision);
+     while (res < level && bumped (control[res+1].decision) > limit)
+       res++;
+   }
+@@ -96,11 +96,11 @@
+   stats.restarts++;
+   stats.restartlevels += level;
+   if (stable) stats.restartstable++;
+-  LOG ("restart %" PRId64 "", stats.restarts);
++  LOG ("restart %ld", stats.restarts);
+   backtrack (reuse_trail ());
+ 
+   lim.restart = stats.conflicts + opts.restartint;
+-  LOG ("new restart limit at %" PRId64 " conflicts", lim.restart);
++  LOG ("new restart limit at %ld conflicts", lim.restart);
+ 
+   report ('R', 2);
+   STOP (restart);
+diff -Naur solvers/cadical/restore.cpp solvers/cdc/restore.cpp
+--- solvers/cadical/restore.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/restore.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -67,7 +67,7 @@
+   START (restore);
+   internal->stats.restorations++;
+ 
+-  struct { int64_t weakened, satisfied, restored, removed; } clauses;
++  struct { long weakened, satisfied, restored, removed; } clauses;
+   memset (&clauses, 0, sizeof clauses);
+ 
+   if (internal->opts.restoreall && tainted.empty ())
+@@ -164,24 +164,24 @@
+ #ifndef QUIET
+   if (clauses.satisfied)
+     PHASE ("restore", internal->stats.restorations,
+-      "removed %" PRId64 " satisfied %.0f%% of %" PRId64 " weakened clauses",
++      "removed %ld satisfied %.0f%% of %ld weakened clauses",
+       clauses.satisfied,
+       percent (clauses.satisfied, clauses.weakened),
+       clauses.weakened);
+   else
+     PHASE ("restore", internal->stats.restorations,
+-      "no satisfied clause removed out of %" PRId64 " weakened clauses",
++      "no satisfied clause removed out of %ld weakened clauses",
+       clauses.weakened);
+ 
+   if (clauses.restored)
+     PHASE ("restore", internal->stats.restorations,
+-      "restored %" PRId64 " clauses %.0f%% out of %" PRId64 " weakened clauses",
++      "restored %ld clauses %.0f%% out of %ld weakened clauses",
+       clauses.restored,
+       percent (clauses.restored, clauses.weakened),
+       clauses.weakened);
+   else
+     PHASE ("restore", internal->stats.restorations,
+-      "no clause restored out of %" PRId64 " weakened clauses",
++      "no clause restored out of %ld weakened clauses",
+       clauses.weakened);
+ #endif
+ 
+diff -Naur solvers/cadical/solver.cpp solvers/cdc/solver.cpp
+--- solvers/cadical/solver.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/solver.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -175,9 +175,9 @@
+ }
+ 
+ static void
+-log_api_call_returns (Internal * internal, const char * name, int64_t res) {
++log_api_call_returns (Internal * internal, const char * name, long res) {
+   char fmt[32];
+-  sprintf (fmt, "returns '%" PRId64 "'", res);
++  sprintf (fmt, "returns '%ld'", res);
+   log_api_call (internal, name, fmt);
+ }
+ 
+@@ -648,18 +648,18 @@
+   return res;
+ }
+ 
+-int64_t Solver::redundant () const {
++long Solver::redundant () const {
+   TRACE ("redundant");
+   REQUIRE_VALID_STATE ();
+-  int64_t res = internal->redundant ();
++  long res = internal->redundant ();
+   LOG_API_CALL_RETURNS ("redundant", res);
+   return res;
+ }
+ 
+-int64_t Solver::irredundant () const {
++long Solver::irredundant () const {
+   TRACE ("irredundant");
+   REQUIRE_VALID_STATE ();
+-  int64_t res = internal->irredundant ();
++  long res = internal->irredundant ();
+   LOG_API_CALL_RETURNS ("irredundant", res);
+   return res;
+ }
+@@ -910,7 +910,7 @@
+ class ClauseCounter : public ClauseIterator {
+ public:
+   int vars;
+-  int64_t clauses;
++  long clauses;
+   ClauseCounter () : vars (0), clauses (0) { }
+   bool clause (const vector<int> & c) {
+     for (const auto & lit : c) {
+@@ -941,7 +941,7 @@
+   REQUIRE_VALID_STATE ();
+   ClauseCounter counter;
+   (void) traverse_clauses (counter);
+-  LOG ("found maximal variable %d and %" PRId64 " clauses",
++  LOG ("found maximal variable %d and %ld clauses",
+     counter.vars, counter.clauses);
+ #ifndef QUIET
+   const double start = internal->time ();
+@@ -950,7 +950,7 @@
+   const char * res = 0;
+   if (file) {
+     int actual_max_vars = max (min_max_var, counter.vars);
+-    MSG ("writing %s'p cnf %d %" PRId64 "'%s header",
++    MSG ("writing %s'p cnf %d %d'%s header",
+       tout.green_code (), actual_max_vars, counter.clauses,
+       tout.normal_code ());
+     file->put ("p cnf ");
+@@ -968,7 +968,7 @@
+ #ifndef QUIET
+   if (!res) {
+     const double end = internal->time ();
+-    MSG ("wrote %" PRId64 " clauses in %.2f seconds %s time",
++    MSG ("wrote %d clauses in %.2f seconds %s time",
+       counter.clauses, end - start,
+       internal->opts.realtime ? "real" : "process");
+   }
+@@ -981,7 +981,7 @@
+ 
+ struct WitnessWriter : public WitnessIterator {
+   File * file;
+-  int64_t witnesses;
++  long witnesses;
+   WitnessWriter (File * f) : file (f), witnesses (0) { }
+   bool write (const vector<int> & a) {
+     for (const auto & lit : a) {
+@@ -1019,7 +1019,7 @@
+ #ifndef QUIET
+   if (!res) {
+     const double end = internal->time ();
+-    MSG ("wrote %" PRId64 " witnesses in %.2f seconds %s time",
++    MSG ("wrote %ld witnesses in %.2f seconds %s time",
+       writer.witnesses, end - start,
+       internal->opts.realtime ? "real" : "process");
+   }
+diff -Naur solvers/cadical/stats.cpp solvers/cdc/stats.cpp
+--- solvers/cadical/stats.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/stats.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -40,7 +40,7 @@
+ 
+   double t = internal->solve_time ();
+ 
+-  int64_t propagations = 0;
++  long propagations = 0;
+   propagations += stats.propagations.cover;
+   propagations += stats.propagations.probe;
+   propagations += stats.propagations.search;
+@@ -48,7 +48,7 @@
+   propagations += stats.propagations.vivify;
+   propagations += stats.propagations.walk;
+ 
+-  int64_t vivified = stats.vivifysubs + stats.vivifystrs;
++  long vivified = stats.vivifysubs + stats.vivifystrs;
+ 
+   size_t extendbytes = internal->external->extension.size ();
+   extendbytes *= sizeof (int);
+@@ -56,192 +56,192 @@
+   SECTION ("statistics");
+ 
+   if (all || stats.blocked) {
+-  PRT ("blocked:         %15" PRId64 "   %10.2f %%  of irredundant clauses", stats.blocked, percent (stats.blocked, stats.added.irredundant));
+-  PRT ("  blockings:     %15" PRId64 "   %10.2f    internal", stats.blockings, relative (stats.conflicts, stats.blockings));
+-  PRT ("  candidates:    %15" PRId64 "   %10.2f    per blocking ", stats.blockcands, relative (stats.blockcands, stats.blockings));
+-  PRT ("  blockres:      %15" PRId64 "   %10.2f    per candidate", stats.blockres, relative (stats.blockres, stats.blockcands));
+-  PRT ("  pure:          %15" PRId64 "   %10.2f %%  of all variables", stats.all.pure, percent (stats.all.pure, stats.vars));
+-  PRT ("  pureclauses:   %15" PRId64 "   %10.2f    per pure literal", stats.blockpured, relative (stats.blockpured, stats.all.pure));
++  PRT ("blocked:         %15ld   %10.2f %%  of irredundant clauses", stats.blocked, percent (stats.blocked, stats.added.irredundant));
++  PRT ("  blockings:     %15ld   %10.2f    internal", stats.blockings, relative (stats.conflicts, stats.blockings));
++  PRT ("  candidates:    %15ld   %10.2f    per blocking ", stats.blockcands, relative (stats.blockcands, stats.blockings));
++  PRT ("  blockres:      %15ld   %10.2f    per candidate", stats.blockres, relative (stats.blockres, stats.blockcands));
++  PRT ("  pure:          %15ld   %10.2f %%  of all variables", stats.all.pure, percent (stats.all.pure, stats.vars));
++  PRT ("  pureclauses:   %15ld   %10.2f    per pure literal", stats.blockpured, relative (stats.blockpured, stats.all.pure));
+   }
+   if (all || stats.backtracks)
+-  PRT ("backtracked:     %15" PRId64 "   %10.2f %%  of conflicts", stats.backtracks, percent (stats.backtracks, stats.conflicts));
++  PRT ("backtracked:     %15ld   %10.2f %%  of conflicts", stats.backtracks, percent (stats.backtracks, stats.conflicts));
+   if (all || stats.chrono)
+-  PRT ("chronological:   %15" PRId64 "   %10.2f %%  of backtracks", stats.chrono, percent (stats.chrono, stats.backtracks));
++  PRT ("chronological:   %15ld   %10.2f %%  of backtracks", stats.chrono, percent (stats.chrono, stats.backtracks));
+   if (all)
+-  PRT ("compacts:        %15" PRId64 "   %10.2f    interval", stats.compacts, relative (stats.conflicts, stats.compacts));
++  PRT ("compacts:        %15ld   %10.2f    interval", stats.compacts, relative (stats.conflicts, stats.compacts));
+   if (all || stats.conflicts) {
+-  PRT ("conflicts:       %15" PRId64 "   %10.2f    per second", stats.conflicts, relative (stats.conflicts, t));
++  PRT ("conflicts:       %15ld   %10.2f    per second", stats.conflicts, relative (stats.conflicts, t));
+   }
+   if (all || stats.cover.total) {
+-  PRT ("covered:         %15" PRId64 "   %10.2f %%  of irredundant clauses", stats.cover.total, percent (stats.cover.total, stats.added.irredundant));
+-  PRT ("  coverings:     %15" PRId64 "   %10.2f    interval", stats.cover.count, relative (stats.conflicts, stats.cover.count));
+-  PRT ("  asymmetric:    %15" PRId64 "   %10.2f %%  of covered clauses", stats.cover.asymmetric, percent (stats.cover.asymmetric, stats.cover.total));
+-  PRT ("  blocked:       %15" PRId64 "   %10.2f %%  of covered clauses", stats.cover.blocked, percent (stats.cover.blocked, stats.cover.total));
++  PRT ("covered:         %15ld   %10.2f %%  of irredundant clauses", stats.cover.total, percent (stats.cover.total, stats.added.irredundant));
++  PRT ("  coverings:     %15ld   %10.2f    interval", stats.cover.count, relative (stats.conflicts, stats.cover.count));
++  PRT ("  asymmetric:    %15ld   %10.2f %%  of covered clauses", stats.cover.asymmetric, percent (stats.cover.asymmetric, stats.cover.total));
++  PRT ("  blocked:       %15ld   %10.2f %%  of covered clauses", stats.cover.blocked, percent (stats.cover.blocked, stats.cover.total));
+   }
+   if (all || stats.decisions) {
+-  PRT ("decisions:       %15" PRId64 "   %10.2f    per second", stats.decisions, relative (stats.decisions, t));
+-  PRT ("  searched:      %15" PRId64 "   %10.2f    per decision", stats.searched, relative (stats.searched, stats.decisions));
++  PRT ("decisions:       %15ld   %10.2f    per second", stats.decisions, relative (stats.decisions, t));
++  PRT ("  searched:      %15ld   %10.2f    per decision", stats.searched, relative (stats.searched, stats.decisions));
+   }
+   if (all || stats.all.eliminated) {
+-  PRT ("eliminated:      %15" PRId64 "   %10.2f %%  of all variables", stats.all.eliminated, percent (stats.all.eliminated, stats.vars));
+-  PRT ("  elimphases:    %15" PRId64 "   %10.2f    interval", stats.elimphases, relative (stats.conflicts, stats.elimphases));
+-  PRT ("  elimrounds:    %15" PRId64 "   %10.2f    per phase", stats.elimrounds, relative (stats.elimrounds, stats.elimphases));
+-  PRT ("  elimtried:     %15" PRId64 "   %10.2f %%  eliminated", stats.elimtried, percent (stats.all.eliminated, stats.elimtried));
+-  PRT ("  elimgates:     %15" PRId64 "   %10.2f %%  gates per tried", stats.elimgates, percent (stats.elimgates, stats.elimtried));
+-  PRT ("  elimequivs:    %15" PRId64 "   %10.2f %%  equivalence gates", stats.elimequivs, percent (stats.elimequivs, stats.elimgates));
+-  PRT ("  elimands:      %15" PRId64 "   %10.2f %%  and gates", stats.elimands, percent (stats.elimands, stats.elimgates));
+-  PRT ("  elimites:      %15" PRId64 "   %10.2f %%  if-then-else gates", stats.elimites, percent (stats.elimites, stats.elimgates));
+-  PRT ("  elimxors:      %15" PRId64 "   %10.2f %%  xor gates", stats.elimxors, percent (stats.elimxors, stats.elimgates));
+-  PRT ("  elimsubst:     %15" PRId64 "   %10.2f %%  substituted", stats.elimsubst, percent (stats.elimsubst, stats.all.eliminated));
+-  PRT ("  elimres:       %15" PRId64 "   %10.2f    per eliminated", stats.elimres, relative (stats.elimres, stats.all.eliminated));
+-  PRT ("  elimrestried:  %15" PRId64 "   %10.2f %%  per resolution", stats.elimrestried, percent (stats.elimrestried, stats.elimres));
++  PRT ("eliminated:      %15ld   %10.2f %%  of all variables", stats.all.eliminated, percent (stats.all.eliminated, stats.vars));
++  PRT ("  elimphases:    %15ld   %10.2f    interval", stats.elimphases, relative (stats.conflicts, stats.elimphases));
++  PRT ("  elimrounds:    %15ld   %10.2f    per phase", stats.elimrounds, relative (stats.elimrounds, stats.elimphases));
++  PRT ("  elimtried:     %15ld   %10.2f %%  eliminated", stats.elimtried, percent (stats.all.eliminated, stats.elimtried));
++  PRT ("  elimgates:     %15ld   %10.2f %%  gates per tried", stats.elimgates, percent (stats.elimgates, stats.elimtried));
++  PRT ("  elimequivs:    %15ld   %10.2f %%  equivalence gates", stats.elimequivs, percent (stats.elimequivs, stats.elimgates));
++  PRT ("  elimands:      %15ld   %10.2f %%  and gates", stats.elimands, percent (stats.elimands, stats.elimgates));
++  PRT ("  elimites:      %15ld   %10.2f %%  if-then-else gates", stats.elimites, percent (stats.elimites, stats.elimgates));
++  PRT ("  elimxors:      %15ld   %10.2f %%  xor gates", stats.elimxors, percent (stats.elimxors, stats.elimgates));
++  PRT ("  elimsubst:     %15ld   %10.2f %%  substituted", stats.elimsubst, percent (stats.elimsubst, stats.all.eliminated));
++  PRT ("  elimres:       %15ld   %10.2f    per eliminated", stats.elimres, relative (stats.elimres, stats.all.eliminated));
++  PRT ("  elimrestried:  %15ld   %10.2f %%  per resolution", stats.elimrestried, percent (stats.elimrestried, stats.elimres));
+   }
+   if (all || stats.all.fixed) {
+-  PRT ("fixed:           %15" PRId64 "   %10.2f %%  of all variables", stats.all.fixed, percent (stats.all.fixed, stats.vars));
+-  PRT ("  failed:        %15" PRId64 "   %10.2f %%  of all variables", stats.failed, percent (stats.failed, stats.vars));
+-  PRT ("  probefailed:   %15" PRId64 "   %10.2f %%  per failed", stats.probefailed, percent (stats.probefailed, stats.failed));
+-  PRT ("  transredunits: %15" PRId64 "   %10.2f %%  per failed", stats.transredunits, percent (stats.transredunits, stats.failed));
+-  PRT ("  probingphases: %15" PRId64 "   %10.2f    interval", stats.probingphases, relative (stats.conflicts, stats.probingphases));
+-  PRT ("  probingrounds: %15" PRId64 "   %10.2f    per phase", stats.probingrounds, relative (stats.probingrounds, stats.probingphases));
+-  PRT ("  probed:        %15" PRId64 "   %10.2f    per failed", stats.probed, relative (stats.probed, stats.failed));
+-  PRT ("  hbrs:          %15" PRId64 "   %10.2f    per probed", stats.hbrs, relative (stats.hbrs, stats.probed));
+-  PRT ("  hbrsizes:      %15" PRId64 "   %10.2f    per hbr", stats.hbrsizes, relative (stats.hbrsizes, stats.hbrs));
+-  PRT ("  hbreds:        %15" PRId64 "   %10.2f %%  per hbr", stats.hbreds, percent (stats.hbreds, stats.hbrs));
+-  PRT ("  hbrsubs:       %15" PRId64 "   %10.2f %%  per hbr", stats.hbrsubs, percent (stats.hbrsubs, stats.hbrs));
++  PRT ("fixed:           %15ld   %10.2f %%  of all variables", stats.all.fixed, percent (stats.all.fixed, stats.vars));
++  PRT ("  failed:        %15ld   %10.2f %%  of all variables", stats.failed, percent (stats.failed, stats.vars));
++  PRT ("  probefailed:   %15ld   %10.2f %%  per failed", stats.probefailed, percent (stats.probefailed, stats.failed));
++  PRT ("  transredunits: %15ld   %10.2f %%  per failed", stats.transredunits, percent (stats.transredunits, stats.failed));
++  PRT ("  probingphases: %15ld   %10.2f    interval", stats.probingphases, relative (stats.conflicts, stats.probingphases));
++  PRT ("  probingrounds: %15ld   %10.2f    per phase", stats.probingrounds, relative (stats.probingrounds, stats.probingphases));
++  PRT ("  probed:        %15ld   %10.2f    per failed", stats.probed, relative (stats.probed, stats.failed));
++  PRT ("  hbrs:          %15ld   %10.2f    per probed", stats.hbrs, relative (stats.hbrs, stats.probed));
++  PRT ("  hbrsizes:      %15ld   %10.2f    per hbr", stats.hbrsizes, relative (stats.hbrsizes, stats.hbrs));
++  PRT ("  hbreds:        %15ld   %10.2f %%  per hbr", stats.hbreds, percent (stats.hbreds, stats.hbrs));
++  PRT ("  hbrsubs:       %15ld   %10.2f %%  per hbr", stats.hbrsubs, percent (stats.hbrsubs, stats.hbrs));
+   }
+-  PRT ("  units:         %15" PRId64 "   %10.2f    interval", stats.units, relative (stats.conflicts, stats.units));
+-  PRT ("  binaries:      %15" PRId64 "   %10.2f    interval", stats.binaries, relative (stats.conflicts, stats.binaries));
++  PRT ("  units:         %15ld   %10.2f    interval", stats.units, relative (stats.conflicts, stats.units));
++  PRT ("  binaries:      %15ld   %10.2f    interval", stats.binaries, relative (stats.conflicts, stats.binaries));
+   if (all || stats.flush.learned) {
+-  PRT ("flushed:         %15" PRId64 "   %10.2f %%  per conflict", stats.flush.learned, percent (stats.flush.learned, stats.conflicts));
+-  PRT ("  hyper:         %15" PRId64 "   %10.2f %%  per conflict", stats.flush.hyper, relative (stats.flush.hyper, stats.conflicts));
+-  PRT ("  flushings:     %15" PRId64 "   %10.2f    interval", stats.flush.count, relative (stats.conflicts, stats.flush.count));
++  PRT ("flushed:         %15ld   %10.2f %%  per conflict", stats.flush.learned, percent (stats.flush.learned, stats.conflicts));
++  PRT ("  hyper:         %15ld   %10.2f %%  per conflict", stats.flush.hyper, relative (stats.flush.hyper, stats.conflicts));
++  PRT ("  flushings:     %15ld   %10.2f    interval", stats.flush.count, relative (stats.conflicts, stats.flush.count));
+   }
+   if (all || stats.instantiated) {
+-  PRT ("instantiated:    %15" PRId64 "   %10.2f %%  of tried", stats.instantiated, percent (stats.instantiated, stats.instried));
+-  PRT ("x instrounds:    %15" PRId64 "   %10.2f %%  of elimrounds", stats.instrounds, percent (stats.instrounds, stats.elimrounds));
++  PRT ("instantiated:    %15ld   %10.2f %%  of tried", stats.instantiated, percent (stats.instantiated, stats.instried));
++  PRT ("x instrounds:    %15ld   %10.2f %%  of elimrounds", stats.instrounds, percent (stats.instrounds, stats.elimrounds));
+   }
+   if (all || stats.conflicts) {
+-  PRT ("learned:         %15" PRId64 "   %10.2f %%  per conflict", stats.learned.clauses, percent (stats.learned.clauses, stats.conflicts));
+-  PRT ("  bumped:        %15" PRId64 "   %10.2f    per learned", stats.bumped, relative (stats.bumped, stats.learned.clauses));
++  PRT ("learned:         %15ld   %10.2f %%  per conflict", stats.learned.clauses, percent (stats.learned.clauses, stats.conflicts));
++  PRT ("  bumped:        %15ld   %10.2f    per learned", stats.bumped, relative (stats.bumped, stats.learned.clauses));
+   }
+   if (all || stats.lucky.succeeded) {
+-  PRT ("lucky:           %15" PRId64 "   %10.2f %%  of tried", stats.lucky.succeeded, percent (stats.lucky.succeeded, stats.lucky.tried));
+-  PRT ("  constantzero   %15" PRId64 "   %10.2f %%  of tried", stats.lucky.constant.zero, percent (stats.lucky.constant.zero, stats.lucky.tried));
+-  PRT ("  constantone    %15" PRId64 "   %10.2f %%  of tried", stats.lucky.constant.one, percent (stats.lucky.constant.one, stats.lucky.tried));
+-  PRT ("  backwardone    %15" PRId64 "   %10.2f %%  of tried", stats.lucky.backward.one, percent (stats.lucky.backward.one, stats.lucky.tried));
+-  PRT ("  backwardzero   %15" PRId64 "   %10.2f %%  of tried", stats.lucky.backward.zero, percent (stats.lucky.backward.zero, stats.lucky.tried));
+-  PRT ("  forwardone     %15" PRId64 "   %10.2f %%  of tried", stats.lucky.forward.one, percent (stats.lucky.forward.one, stats.lucky.tried));
+-  PRT ("  forwardzero    %15" PRId64 "   %10.2f %%  of tried", stats.lucky.forward.zero, percent (stats.lucky.forward.zero, stats.lucky.tried));
+-  PRT ("  positivehorn   %15" PRId64 "   %10.2f %%  of tried", stats.lucky.horn.positive, percent (stats.lucky.horn.positive, stats.lucky.tried));
+-  PRT ("  negativehorn   %15" PRId64 "   %10.2f %%  of tried", stats.lucky.horn.negative, percent (stats.lucky.horn.negative, stats.lucky.tried));
++  PRT ("lucky:           %15ld   %10.2f %%  of tried", stats.lucky.succeeded, percent (stats.lucky.succeeded, stats.lucky.tried));
++  PRT ("  constantzero   %15ld   %10.2f %%  of tried", stats.lucky.constant.zero, percent (stats.lucky.constant.zero, stats.lucky.tried));
++  PRT ("  constantone    %15ld   %10.2f %%  of tried", stats.lucky.constant.one, percent (stats.lucky.constant.one, stats.lucky.tried));
++  PRT ("  backwardone    %15ld   %10.2f %%  of tried", stats.lucky.backward.one, percent (stats.lucky.backward.one, stats.lucky.tried));
++  PRT ("  backwardzero   %15ld   %10.2f %%  of tried", stats.lucky.backward.zero, percent (stats.lucky.backward.zero, stats.lucky.tried));
++  PRT ("  forwardone     %15ld   %10.2f %%  of tried", stats.lucky.forward.one, percent (stats.lucky.forward.one, stats.lucky.tried));
++  PRT ("  forwardzero    %15ld   %10.2f %%  of tried", stats.lucky.forward.zero, percent (stats.lucky.forward.zero, stats.lucky.tried));
++  PRT ("  positivehorn   %15ld   %10.2f %%  of tried", stats.lucky.horn.positive, percent (stats.lucky.horn.positive, stats.lucky.tried));
++  PRT ("  negativehorn   %15ld   %10.2f %%  of tried", stats.lucky.horn.negative, percent (stats.lucky.horn.negative, stats.lucky.tried));
+   }
+-  PRT ("  extendbytes:   %15" PRId64 "   %10.2f    bytes and MB", extendbytes, extendbytes/(double)(1l<<20));
++  PRT ("  extendbytes:   %15ld   %10.2f    bytes and MB", extendbytes, extendbytes/(double)(1l<<20));
+   if (all || stats.learned.clauses)
+-  PRT ("minimized:       %15" PRId64 "   %10.2f %%  learned literals", stats.minimized, percent (stats.minimized, stats.learned.literals));
+-  PRT ("propagations:    %15" PRId64 "   %10.2f M  per second", propagations, relative (propagations/1e6, t));
+-  PRT ("  coverprops:    %15" PRId64 "   %10.2f %%  of propagations", stats.propagations.cover, percent (stats.propagations.cover, propagations));
+-  PRT ("  probeprops:    %15" PRId64 "   %10.2f %%  of propagations", stats.propagations.probe, percent (stats.propagations.probe, propagations));
+-  PRT ("  searchprops:   %15" PRId64 "   %10.2f %%  of propagations", stats.propagations.search, percent (stats.propagations.search, propagations));
+-  PRT ("  transredprops: %15" PRId64 "   %10.2f %%  of propagations", stats.propagations.transred, percent (stats.propagations.transred, propagations));
+-  PRT ("  vivifyprops:   %15" PRId64 "   %10.2f %%  of propagations", stats.propagations.vivify, percent (stats.propagations.vivify, propagations));
+-  PRT ("  walkprops:     %15" PRId64 "   %10.2f %%  of propagations", stats.propagations.walk, percent (stats.propagations.walk, propagations));
++  PRT ("minimized:       %15ld   %10.2f %%  learned literals", stats.minimized, percent (stats.minimized, stats.learned.literals));
++  PRT ("propagations:    %15ld   %10.2f M  per second", propagations, relative (propagations/1e6, t));
++  PRT ("  coverprops:    %15ld   %10.2f %%  of propagations", stats.propagations.cover, percent (stats.propagations.cover, propagations));
++  PRT ("  probeprops:    %15ld   %10.2f %%  of propagations", stats.propagations.probe, percent (stats.propagations.probe, propagations));
++  PRT ("  searchprops:   %15ld   %10.2f %%  of propagations", stats.propagations.search, percent (stats.propagations.search, propagations));
++  PRT ("  transredprops: %15ld   %10.2f %%  of propagations", stats.propagations.transred, percent (stats.propagations.transred, propagations));
++  PRT ("  vivifyprops:   %15ld   %10.2f %%  of propagations", stats.propagations.vivify, percent (stats.propagations.vivify, propagations));
++  PRT ("  walkprops:     %15ld   %10.2f %%  of propagations", stats.propagations.walk, percent (stats.propagations.walk, propagations));
+   if (all || stats.reactivated) {
+-  PRT ("reactivated:     %15" PRId64 "   %10.2f %%  of all variables", stats.reactivated, percent (stats.reactivated, stats.vars));
++  PRT ("reactivated:     %15ld   %10.2f %%  of all variables", stats.reactivated, percent (stats.reactivated, stats.vars));
+   }
+   if (all || stats.reduced) {
+-  PRT ("reduced:         %15" PRId64 "   %10.2f %%  per conflict", stats.reduced, percent (stats.reduced, stats.conflicts));
+-  PRT ("  reductions:    %15" PRId64 "   %10.2f    interval", stats.reductions, relative (stats.conflicts, stats.reductions));
+-  PRT ("  collections:   %15" PRId64 "   %10.2f    interval", stats.collections, relative (stats.conflicts, stats.collections));
++  PRT ("reduced:         %15ld   %10.2f %%  per conflict", stats.reduced, percent (stats.reduced, stats.conflicts));
++  PRT ("  reductions:    %15ld   %10.2f    interval", stats.reductions, relative (stats.conflicts, stats.reductions));
++  PRT ("  collections:   %15ld   %10.2f    interval", stats.collections, relative (stats.conflicts, stats.collections));
+   }
+   if (all || stats.rephased.total) {
+-  PRT ("rephased:        %15" PRId64 "   %10.2f    interval", stats.rephased.total, relative (stats.conflicts, stats.rephased.total));
+-  PRT ("  rephasedbest:  %15" PRId64 "   %10.2f %%  rephased best", stats.rephased.best, percent (stats.rephased.best, stats.rephased.total));
+-  PRT ("  rephasedflip:  %15" PRId64 "   %10.2f %%  rephased flipping", stats.rephased.flipped, percent (stats.rephased.flipped, stats.rephased.total));
+-  PRT ("  rephasedinv:   %15" PRId64 "   %10.2f %%  rephased inverted", stats.rephased.inverted, percent (stats.rephased.inverted, stats.rephased.total));
+-  PRT ("  rephasedorig:  %15" PRId64 "   %10.2f %%  rephased original", stats.rephased.original, percent (stats.rephased.original, stats.rephased.total));
+-  PRT ("  rephasedrand:  %15" PRId64 "   %10.2f %%  rephased random", stats.rephased.random, percent (stats.rephased.random, stats.rephased.total));
+-  PRT ("  rephasedwalk:  %15" PRId64 "   %10.2f %%  rephased walk", stats.rephased.walk, percent (stats.rephased.walk, stats.rephased.total));
++  PRT ("rephased:        %15ld   %10.2f    interval", stats.rephased.total, relative (stats.conflicts, stats.rephased.total));
++  PRT ("  rephasedbest:  %15ld   %10.2f %%  rephased best", stats.rephased.best, percent (stats.rephased.best, stats.rephased.total));
++  PRT ("  rephasedflip:  %15ld   %10.2f %%  rephased flipping", stats.rephased.flipped, percent (stats.rephased.flipped, stats.rephased.total));
++  PRT ("  rephasedinv:   %15ld   %10.2f %%  rephased inverted", stats.rephased.inverted, percent (stats.rephased.inverted, stats.rephased.total));
++  PRT ("  rephasedorig:  %15ld   %10.2f %%  rephased original", stats.rephased.original, percent (stats.rephased.original, stats.rephased.total));
++  PRT ("  rephasedrand:  %15ld   %10.2f %%  rephased random", stats.rephased.random, percent (stats.rephased.random, stats.rephased.total));
++  PRT ("  rephasedwalk:  %15ld   %10.2f %%  rephased walk", stats.rephased.walk, percent (stats.rephased.walk, stats.rephased.total));
+   }
+   if (all)
+-  PRT ("rescored:        %15" PRId64 "   %10.2f    interval", stats.rescored, relative (stats.conflicts, stats.rescored));
++  PRT ("rescored:        %15ld   %10.2f    interval", stats.rescored, relative (stats.conflicts, stats.rescored));
+   if (all || stats.restarts) {
+-  PRT ("restarts:        %15" PRId64 "   %10.2f    interval", stats.restarts, relative (stats.conflicts, stats.restarts));
+-  PRT ("  reused:        %15" PRId64 "   %10.2f %%  per restart", stats.reused, percent (stats.reused, stats.restarts));
+-  PRT ("  reusedlevels:  %15" PRId64 "   %10.2f %%  per restart levels", stats.reusedlevels, percent (stats.reusedlevels, stats.restartlevels));
++  PRT ("restarts:        %15ld   %10.2f    interval", stats.restarts, relative (stats.conflicts, stats.restarts));
++  PRT ("  reused:        %15ld   %10.2f %%  per restart", stats.reused, percent (stats.reused, stats.restarts));
++  PRT ("  reusedlevels:  %15ld   %10.2f %%  per restart levels", stats.reusedlevels, percent (stats.reusedlevels, stats.restartlevels));
+   }
+   if (all || stats.restored) {
+-  PRT ("restored:        %15" PRId64 "   %10.2f %%  per weakened", stats.restored, percent (stats.restored, stats.weakened));
+-  PRT ("  restorations:  %15" PRId64 "   %10.2f %%  per extension", stats.restorations, percent (stats.restorations, stats.extensions));
+-  PRT ("  literals:      %15" PRId64 "   %10.2f    per restored clause", stats.restoredlits, relative (stats.restoredlits, stats.restored));
++  PRT ("restored:        %15ld   %10.2f %%  per weakened", stats.restored, percent (stats.restored, stats.weakened));
++  PRT ("  restorations:  %15ld   %10.2f %%  per extension", stats.restorations, percent (stats.restorations, stats.extensions));
++  PRT ("  literals:      %15ld   %10.2f    per restored clause", stats.restoredlits, relative (stats.restoredlits, stats.restored));
+   }
+   if (all || stats.stabphases) {
+-  PRT ("stabilizing:     %15" PRId64 "   %10.2f %%  of conflicts", stats.stabphases, percent (stats.stabconflicts, stats.conflicts));
+-  PRT ("  restartstab:   %15" PRId64 "   %10.2f %%  of all restarts", stats.restartstable, percent (stats.restartstable, stats.restarts));
+-  PRT ("  reusedstab:    %15" PRId64 "   %10.2f %%  per stable restarts", stats.reusedstable, percent (stats.reusedstable, stats.restartstable));
++  PRT ("stabilizing:     %15ld   %10.2f %%  of conflicts", stats.stabphases, percent (stats.stabconflicts, stats.conflicts));
++  PRT ("  restartstab:   %15ld   %10.2f %%  of all restarts", stats.restartstable, percent (stats.restartstable, stats.restarts));
++  PRT ("  reusedstab:    %15ld   %10.2f %%  per stable restarts", stats.reusedstable, percent (stats.reusedstable, stats.restartstable));
+   }
+   if (all || stats.all.substituted) {
+-  PRT ("substituted:     %15" PRId64 "   %10.2f %%  of all variables", stats.all.substituted, percent (stats.all.substituted, stats.vars));
+-  PRT ("  decompositions:%15" PRId64 "   %10.2f    per phase", stats.decompositions, relative (stats.decompositions, stats.probingphases));
++  PRT ("substituted:     %15ld   %10.2f %%  of all variables", stats.all.substituted, percent (stats.all.substituted, stats.vars));
++  PRT ("  decompositions:  %13ld   %10.2f    per phase", stats.decompositions, relative (stats.decompositions, stats.probingphases));
+   }
+   if (all || stats.subsumed) {
+-  PRT ("subsumed:        %15" PRId64 "   %10.2f %%  of all clauses", stats.subsumed, percent (stats.subsumed, stats.added.total));
+-  PRT ("  subsumephases: %15" PRId64 "   %10.2f    interval", stats.subsumephases, relative (stats.conflicts, stats.subsumephases));
+-  PRT ("  subsumerounds: %15" PRId64 "   %10.2f    per phase", stats.subsumerounds, relative (stats.subsumerounds, stats.subsumephases));
+-  PRT ("  deduplicated:  %15" PRId64 "   %10.2f %%  per subsumed", stats.deduplicated, percent (stats.deduplicated, stats.subsumed));
+-  PRT ("  transreds:     %15" PRId64 "   %10.2f    interval", stats.transreds, relative (stats.conflicts, stats.transreds));
+-  PRT ("  transitive:    %15" PRId64 "   %10.2f %%  per subsumed", stats.transitive, percent (stats.transitive, stats.subsumed));
+-  PRT ("  subirr:        %15" PRId64 "   %10.2f %%  of subsumed", stats.subirr, percent (stats.subirr, stats.subsumed));
+-  PRT ("  subred:        %15" PRId64 "   %10.2f %%  of subsumed", stats.subred, percent (stats.subred, stats.subsumed));
+-  PRT ("  subtried:      %15" PRId64 "   %10.2f    tried per subsumed", stats.subtried, relative (stats.subtried, stats.subsumed));
+-  PRT ("  subchecks:     %15" PRId64 "   %10.2f    per tried", stats.subchecks, relative (stats.subchecks, stats.subtried));
+-  PRT ("  subchecks2:    %15" PRId64 "   %10.2f %%  per subcheck", stats.subchecks2, percent (stats.subchecks2, stats.subchecks));
+-  PRT ("  elimotfsub:    %15" PRId64 "   %10.2f %%  of subsumed", stats.elimotfsub, percent (stats.elimotfsub, stats.subsumed));
+-  PRT ("  elimbwsub:     %15" PRId64 "   %10.2f %%  of subsumed", stats.elimbwsub, percent (stats.elimbwsub, stats.subsumed));
+-  PRT ("  eagersub:      %15" PRId64 "   %10.2f %%  of subsumed", stats.eagersub, percent (stats.eagersub, stats.subsumed));
+-  PRT ("  eagertried:    %15" PRId64 "   %10.2f    tried per eagersub", stats.eagertried, relative (stats.eagertried, stats.eagersub));
++  PRT ("subsumed:        %15ld   %10.2f %%  of all clauses", stats.subsumed, percent (stats.subsumed, stats.added.total));
++  PRT ("  subsumephases: %15ld   %10.2f    interval", stats.subsumephases, relative (stats.conflicts, stats.subsumephases));
++  PRT ("  subsumerounds: %15ld   %10.2f    per phase", stats.subsumerounds, relative (stats.subsumerounds, stats.subsumephases));
++  PRT ("  deduplicated:  %15ld   %10.2f %%  per subsumed", stats.deduplicated, percent (stats.deduplicated, stats.subsumed));
++  PRT ("  transreductions:%14ld   %10.2f    interval", stats.transreds, relative (stats.conflicts, stats.transreds));
++  PRT ("  transitive:    %15ld   %10.2f %%  per subsumed", stats.transitive, percent (stats.transitive, stats.subsumed));
++  PRT ("  subirr:        %15ld   %10.2f %%  of subsumed", stats.subirr, percent (stats.subirr, stats.subsumed));
++  PRT ("  subred:        %15ld   %10.2f %%  of subsumed", stats.subred, percent (stats.subred, stats.subsumed));
++  PRT ("  subtried:      %15ld   %10.2f    tried per subsumed", stats.subtried, relative (stats.subtried, stats.subsumed));
++  PRT ("  subchecks:     %15ld   %10.2f    per tried", stats.subchecks, relative (stats.subchecks, stats.subtried));
++  PRT ("  subchecks2:    %15ld   %10.2f %%  per subcheck", stats.subchecks2, percent (stats.subchecks2, stats.subchecks));
++  PRT ("  elimotfsub:    %15ld   %10.2f %%  of subsumed", stats.elimotfsub, percent (stats.elimotfsub, stats.subsumed));
++  PRT ("  elimbwsub:     %15ld   %10.2f %%  of subsumed", stats.elimbwsub, percent (stats.elimbwsub, stats.subsumed));
++  PRT ("  eagersub:      %15ld   %10.2f %%  of subsumed", stats.eagersub, percent (stats.eagersub, stats.subsumed));
++  PRT ("  eagertried:    %15ld   %10.2f    tried per eagersub", stats.eagertried, relative (stats.eagertried, stats.eagersub));
+   }
+   if (all || stats.strengthened) {
+-  PRT ("strengthened:    %15" PRId64 "   %10.2f %%  of all clauses", stats.strengthened, percent (stats.strengthened, stats.added.total));
+-  PRT ("  elimotfstr:    %15" PRId64 "   %10.2f %%  of strengthened", stats.elimotfstr, percent (stats.elimotfstr, stats.strengthened));
+-  PRT ("  elimbwstr:     %15" PRId64 "   %10.2f %%  of strengthened", stats.elimbwstr, percent (stats.elimbwstr, stats.strengthened));
++  PRT ("strengthened:    %15ld   %10.2f %%  of all clauses", stats.strengthened, percent (stats.strengthened, stats.added.total));
++  PRT ("  elimotfstr:    %15ld   %10.2f %%  of strengthened", stats.elimotfstr, percent (stats.elimotfstr, stats.strengthened));
++  PRT ("  elimbwstr:     %15ld   %10.2f %%  of strengthened", stats.elimbwstr, percent (stats.elimbwstr, stats.strengthened));
+   }
+   if (all || stats.htrs) {
+-  PRT ("ternary:         %15" PRId64 "   %10.2f %%  of resolved", stats.htrs, percent (stats.htrs, stats.ternres));
+-  PRT ("  phases:        %15" PRId64 "   %10.2f    interval", stats.ternary, relative (stats.conflicts, stats.ternary));
+-  PRT ("  htr3:          %15" PRId64 "   %10.2f %%  ternary hyper ternres", stats.htrs3, percent (stats.htrs3, stats.htrs));
+-  PRT ("  htr2:          %15" PRId64 "   %10.2f %%  binary hyper ternres", stats.htrs2, percent (stats.htrs2, stats.htrs));
++  PRT ("ternary:         %15ld   %10.2f %%  of resolved", stats.htrs, percent (stats.htrs, stats.ternres));
++  PRT ("  phases:        %15ld   %10.2f    interval", stats.ternary, relative (stats.conflicts, stats.ternary));
++  PRT ("  htr3:          %15ld   %10.2f %%  ternary hyper ternres", stats.htrs3, percent (stats.htrs3, stats.htrs));
++  PRT ("  htr2:          %15ld   %10.2f %%  binary hyper ternres", stats.htrs2, percent (stats.htrs2, stats.htrs));
+   }
+   if (all || vivified) {
+-  PRT ("vivified:        %15" PRId64 "   %10.2f %%  of all clauses", vivified, percent (vivified, stats.added.total));
+-  PRT ("  vivifications: %15" PRId64 "   %10.2f    interval", stats.vivifications, relative (stats.conflicts, stats.vivifications));
+-  PRT ("  vivifychecks:  %15" PRId64 "   %10.2f %%  per conflict", stats.vivifychecks, percent (stats.vivifychecks, stats.conflicts));
+-  PRT ("  vivifysched:   %15" PRId64 "   %10.2f %%  checks per scheduled", stats.vivifysched, percent (stats.vivifychecks, stats.vivifysched));
+-  PRT ("  vivifyunits:   %15" PRId64 "   %10.2f %%  per vivify check", stats.vivifyunits, percent (stats.vivifyunits, stats.vivifychecks));
+-  PRT ("  vivifysubs:    %15" PRId64 "   %10.2f %%  per subsumed", stats.vivifysubs, percent (stats.vivifysubs, stats.subsumed));
+-  PRT ("  vivifystrs:    %15" PRId64 "   %10.2f %%  per strengthened", stats.vivifystrs, percent (stats.vivifystrs, stats.strengthened));
+-  PRT ("  vivifystrirr:  %15" PRId64 "   %10.2f %%  per vivifystrs", stats.vivifystrirr, percent (stats.vivifystrirr, stats.vivifystrs));
+-  PRT ("  vivifystred1:  %15" PRId64 "   %10.2f %%  per vivifystrs", stats.vivifystred1, percent (stats.vivifystred1, stats.vivifystrs));
+-  PRT ("  vivifystred2:  %15" PRId64 "   %10.2f %%  per vivifystrs", stats.vivifystred2, percent (stats.vivifystred2, stats.vivifystrs));
+-  PRT ("  vivifystred3:  %15" PRId64 "   %10.2f %%  per vivifystrs", stats.vivifystred3, percent (stats.vivifystred3, stats.vivifystrs));
+-  PRT ("  vivifydecs:    %15" PRId64 "   %10.2f    per checks", stats.vivifydecs, relative (stats.vivifydecs, stats.vivifychecks));
+-  PRT ("  vivifyreused:  %15" PRId64 "   %10.2f %%  per decision", stats.vivifyreused, percent (stats.vivifyreused, stats.vivifydecs));
++  PRT ("vivified:        %15ld   %10.2f %%  of all clauses", vivified, percent (vivified, stats.added.total));
++  PRT ("  vivifications: %15ld   %10.2f    interval", stats.vivifications, relative (stats.conflicts, stats.vivifications));
++  PRT ("  vivifychecks:  %15ld   %10.2f %%  per conflict", stats.vivifychecks, percent (stats.vivifychecks, stats.conflicts));
++  PRT ("  vivifysched:   %15ld   %10.2f %%  checks per scheduled", stats.vivifysched, percent (stats.vivifychecks, stats.vivifysched));
++  PRT ("  vivifyunits:   %15ld   %10.2f %%  per vivify check", stats.vivifyunits, percent (stats.vivifyunits, stats.vivifychecks));
++  PRT ("  vivifysubs:    %15ld   %10.2f %%  per subsumed", stats.vivifysubs, percent (stats.vivifysubs, stats.subsumed));
++  PRT ("  vivifystrs:    %15ld   %10.2f %%  per strengthened", stats.vivifystrs, percent (stats.vivifystrs, stats.strengthened));
++  PRT ("  vivifystrirr:  %15ld   %10.2f %%  per vivifystrs", stats.vivifystrirr, percent (stats.vivifystrirr, stats.vivifystrs));
++  PRT ("  vivifystred1:  %15ld   %10.2f %%  per vivifystrs", stats.vivifystred1, percent (stats.vivifystred1, stats.vivifystrs));
++  PRT ("  vivifystred2:  %15ld   %10.2f %%  per vivifystrs", stats.vivifystred2, percent (stats.vivifystred2, stats.vivifystrs));
++  PRT ("  vivifystred3:  %15ld   %10.2f %%  per vivifystrs", stats.vivifystred3, percent (stats.vivifystred3, stats.vivifystrs));
++  PRT ("  vivifydecs:    %15ld   %10.2f    per checks", stats.vivifydecs, relative (stats.vivifydecs, stats.vivifychecks));
++  PRT ("  vivifyreused:  %15ld   %10.2f %%  per decision", stats.vivifyreused, percent (stats.vivifyreused, stats.vivifydecs));
+   }
+   if (all || stats.walk.count) {
+-  PRT ("walked:          %15" PRId64 "   %10.2f    interval", stats.walk.count, relative (stats.conflicts, stats.walk.count));
++  PRT ("walked:          %15ld   %10.2f    interval", stats.walk.count, relative (stats.conflicts, stats.walk.count));
+ #ifndef QUIET
+   if (internal->profiles.walk.value > 0)
+-  PRT ("  flips:         %15" PRId64 "   %10.2f M  per second", stats.walk.flips, relative (1e-6*stats.walk.flips, internal->profiles.walk.value));
++  PRT ("  flips:         %15ld   %10.2f M  per second", stats.walk.flips, relative (1e-6*stats.walk.flips, internal->profiles.walk.value));
+   else
+ #endif
+-  PRT ("  flips:         %15" PRId64 "   %10.2f    per walk", stats.walk.flips, relative (stats.walk.flips, stats.walk.count));
++  PRT ("  flips:         %15ld   %10.2f    per walk", stats.walk.flips, relative (stats.walk.flips, stats.walk.count));
+   if (stats.walk.minimum < LONG_MAX)
+-  PRT ("  minimum:       %15" PRId64 "   %10.2f %%  clauses", stats.walk.minimum, percent (stats.walk.minimum, stats.added.irredundant));
+-  PRT ("  broken:        %15" PRId64 "   %10.2f    per flip", stats.walk.broken, relative (stats.walk.broken, stats.walk.flips));
++  PRT ("  minimum:       %15ld   %10.2f %%  clauses", stats.walk.minimum, percent (stats.walk.minimum, stats.added.irredundant));
++  PRT ("  broken:        %15ld   %10.2f    per flip", stats.walk.broken, relative (stats.walk.broken, stats.walk.flips));
+   }
+   if (all || stats.weakened) {
+-  PRT ("weakened:        %15" PRId64 "   %10.2f    average size", stats.weakened, relative (stats.weakenedlen, stats.weakened));
+-  PRT ("  extensions:    %15" PRId64 "   %10.2f    interval", stats.extensions, relative (stats.conflicts, stats.extensions));
+-  PRT ("  flipped:       %15" PRId64 "   %10.2f    per weakened", stats.extended, relative (stats.extended, stats.weakened));
++  PRT ("weakened:        %15ld   %10.2f    average size", stats.weakened, relative (stats.weakenedlen, stats.weakened));
++  PRT ("  extensions:    %15ld   %10.2f    interval", stats.extensions, relative (stats.conflicts, stats.extensions));
++  PRT ("  flipped:       %15ld   %10.2f    per weakened", stats.extended, relative (stats.extended, stats.weakened));
+   }
+ 
+   MSG ("");
+@@ -267,17 +267,17 @@
+ 
+   SECTION ("checker statistics");
+ 
+-  MSG ("checks:          %15" PRId64 "", stats.checks);
+-  MSG ("assumptions:     %15" PRId64 "   %10.2f    per check", stats.assumptions, relative (stats.assumptions, stats.checks));
+-  MSG ("propagations:    %15" PRId64 "   %10.2f    per check", stats.propagations, relative (stats.propagations, stats.checks));
+-  MSG ("original:        %15" PRId64 "   %10.2f %%  of all clauses", stats.original, percent (stats.original, stats.added));
+-  MSG ("derived:         %15" PRId64 "   %10.2f %%  of all clauses", stats.derived, percent (stats.derived, stats.added));
+-  MSG ("deleted:         %15" PRId64 "   %10.2f %%  of all clauses", stats.deleted, percent (stats.deleted, stats.added));
+-  MSG ("insertions:      %15" PRId64 "   %10.2f %%  of all clauses", stats.insertions, percent (stats.insertions, stats.added));
+-  MSG ("collections:     %15" PRId64 "   %10.2f    deleted per collection", stats.collections, relative (stats.collections, stats.deleted));
+-  MSG ("collisions:      %15" PRId64 "   %10.2f    per search", stats.collisions, relative (stats.collisions, stats.searches));
+-  MSG ("searches:        %15" PRId64 "", stats.searches);
+-  MSG ("units:           %15" PRId64 "", stats.units);
++  MSG ("checks:          %15ld", stats.checks);
++  MSG ("assumptions:     %15ld   %10.2f    per check", stats.assumptions, relative (stats.assumptions, stats.checks));
++  MSG ("propagations:    %15ld   %10.2f    per check", stats.propagations, relative (stats.propagations, stats.checks));
++  MSG ("original:        %15ld   %10.2f %%  of all clauses", stats.original, percent (stats.original, stats.added));
++  MSG ("derived:         %15ld   %10.2f %%  of all clauses", stats.derived, percent (stats.derived, stats.added));
++  MSG ("deleted:         %15ld   %10.2f %%  of all clauses", stats.deleted, percent (stats.deleted, stats.added));
++  MSG ("insertions:      %15ld   %10.2f %%  of all clauses", stats.insertions, percent (stats.insertions, stats.added));
++  MSG ("collections:     %15ld   %10.2f    deleted per collection", stats.collections, relative (stats.collections, stats.deleted));
++  MSG ("collisions:      %15ld   %10.2f    per search", stats.collisions, relative (stats.collisions, stats.searches));
++  MSG ("searches:        %15ld", stats.searches);
++  MSG ("units:           %15ld", stats.units);
+ }
+ 
+ }
+diff -Naur solvers/cadical/stats.hpp solvers/cdc/stats.hpp
+--- solvers/cadical/stats.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/stats.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -11,192 +11,191 @@
+ 
+   Internal * internal;
+ 
+-  int64_t vars;         // internal initialized variables
++  long vars;         // internal initialized variables
+ 
+-  int64_t conflicts;    // generated conflicts in 'propagate'
+-  int64_t decisions;    // number of decisions in 'decide'
++  long conflicts;    // generated conflicts in 'propagate'
++  long decisions;    // number of decisions in 'decide'
+ 
+   struct {
+-    int64_t cover;      // propagated during covered clause elimination
+-    int64_t instantiate;// propagated during variable instantiation
+-    int64_t probe;      // propagated during probing
+-    int64_t search;     // propagated literals during search
+-    int64_t transred;   // propagated during transitive reduction
+-    int64_t vivify;     // propagated during vivification
+-    int64_t walk;       // propagated during local search
++    long cover;      // propagated during covered clause elimination
++    long instantiate;// propagated during variable instantiation
++    long probe;      // propagated during probing
++    long search;     // propagated literals during search
++    long transred;   // propagated during transitive reduction
++    long vivify;     // propagated during vivification
++    long walk;       // propagated during local search
+   } propagations;
+ 
+   struct {
+-    int64_t block;      // block marked literals
+-    int64_t elim;       // elim marked variables
+-    int64_t subsume;    // subsume marked variables
+-    int64_t ternary;    // ternary marked variables
++    long block;      // block marked literals
++    long elim;       // elim marked variables
++    long subsume;    // subsume marked variables
++    long ternary;    // ternary marked variables
+   } mark;
+ 
+   struct {
+-    int64_t total;
+-    int64_t redundant;
+-    int64_t irredundant;
++    long total;
++    long redundant;
++    long irredundant;
+   } current, added;  // Clauses.
+ 
+   struct { double process, real; } time;
+ 
+   struct {
+-    int64_t count;      // number of covered clause elimination rounds
+-    int64_t asymmetric; // number of asymmetric tautologies in CCE
+-    int64_t blocked;    // number of blocked covered tautologies
+-    int64_t total;      // total number of eliminated clauses
++    long count;      // number of covered clause elimination rounds
++    long asymmetric; // number of asymmetric tautologies in CCE
++    long blocked;    // number of blocked covered tautologies
++    long total;      // total number of eliminated clauses
+   } cover;
+ 
+   struct {
+-    int64_t tried;
+-    int64_t succeeded;
+-    struct { int64_t one, zero; } constant, forward, backward;
+-    struct { int64_t positive, negative; } horn;
++    long tried;
++    long succeeded;
++    struct { long one, zero; } constant, forward, backward;
++    struct { long positive, negative; } horn;
+   } lucky;
+ 
+   struct {
+-    int64_t total;      // total number of happened rephases
+-    int64_t best;       // how often reset to best phases
+-    int64_t flipped;    // how often reset phases by flipping
+-    int64_t inverted;   // how often reset to inverted phases
+-    int64_t original;   // how often reset to original phases
+-    int64_t random;     // how often randomly reset phases
+-    int64_t walk;       // phases improved through random walked
++    long total;      // total number of happened rephases
++    long best;       // how often reset to best phases
++    long flipped;    // how often reset phases by flipping
++    long inverted;   // how often reset to inverted phases
++    long original;   // how often reset to original phases
++    long random;     // how often randomly reset phases
++    long walk;       // phases improved through random walked
+   } rephased;
+ 
+   struct {
+-    int64_t count;
+-    int64_t broken;
+-    int64_t flips;
+-    int64_t minimum;
++    long count;
++    long broken;
++    long flips;
++    long minimum;
+   } walk;
+ 
+   struct {
+-    int64_t count;      // flushings of learned clauses counter
+-    int64_t learned;    // flushed learned clauses
+-    int64_t hyper;      // flushed hyper binary/ternary clauses
++    long count;      // flushings of learned clauses counter
++    long learned;    // flushed learned clauses
++    long hyper;      // flushed hyper binary/ternary clauses
+   } flush;
+ 
+-  int64_t compacts;     // number of compactifications
+-  int64_t shuffled;     // shuffled queues and scores
+-  int64_t restarts;     // actual number of happened restarts
+-  int64_t restartlevels;// levels at restart
+-  int64_t restartstable;// actual number of happened restarts
+-  int64_t stabphases;   // number of stabilization phases
+-  int64_t stabconflicts;// number of search conflicts during stabilizing
+-  int64_t rescored;     // number of times scores were rescored
+-  int64_t reused;       // number of reused trails
+-  int64_t reusedlevels; // reused levels at restart
+-  int64_t reusedstable; // number of reused trails during stabilizing
+-  int64_t sections;     // 'section' counter
+-  int64_t chrono;       // chronological backtracks
+-  int64_t backtracks;   // number of backtracks
+-  int64_t bumped;       // seen and bumped variables in 'analyze'
+-  int64_t searched;     // searched decisions in 'decide'
+-  int64_t reductions;   // 'reduce' counter
+-  int64_t reduced;      // number of reduced clauses
+-  int64_t collected;    // number of collected bytes
+-  int64_t collections;  // number of garbage collections
+-  int64_t hbrs;         // hyper binary resolvents
+-  int64_t hbrsizes;     // sum of hyper resolved base clauses
+-  int64_t hbreds;       // redundant hyper binary resolvents
+-  int64_t hbrsubs;      // subsuming hyper binary resolvents
+-  int64_t instried;     // number of tried instantiations
+-  int64_t instantiated; // number of successful instantiations
+-  int64_t instrounds;   // number of instantiation rounds
+-  int64_t subsumed;     // number of subsumed clauses
+-  int64_t deduplicated; // number of removed duplicated binary clauses
+-  int64_t deduplications;//number of deduplication phases
+-  int64_t strengthened; // number of strengthened clauses
+-  int64_t elimotfstr;   // number of on-the-fly strengthened during elimination
+-  int64_t subirr;       // number of subsumed irredundant clauses
+-  int64_t subred;       // number of subsumed redundant clauses
+-  int64_t subtried;     // number of tried subsumptions
+-  int64_t subchecks;    // number of pair-wise subsumption checks
+-  int64_t subchecks2;   // same but restricted to binary clauses
+-  int64_t elimotfsub;   // number of on-the-fly subsumed during elimination
+-  int64_t subsumerounds;// number of subsumption rounds
+-  int64_t subsumephases;// number of scheduled subsumption phases
+-  int64_t eagertried;   // number of traversed eager subsumed candidates
+-  int64_t eagersub;     // number of eagerly subsumed recently learned clauses
+-  int64_t elimres;      // number of resolved clauses in BVE
+-  int64_t elimrestried; // number of tried resolved clauses in BVE
+-  int64_t elimrounds;   // number of elimination rounds
+-  int64_t elimphases;   // number of scheduled elimination phases
+-  int64_t elimcompleted;// number complete elimination procedures
+-  int64_t elimtried;    // number of variable elimination attempts
+-  int64_t elimsubst;    // number of eliminations through substitutions
+-  int64_t elimgates;    // number of gates found during elimination
+-  int64_t elimequivs;   // number of equivalences found during elimination
+-  int64_t elimands;     // number of AND gates found during elimination
+-  int64_t elimites;     // number of ITE gates found during elimination
+-  int64_t elimxors;     // number of XOR gates found during elimination
+-  int64_t elimbwsub;    // number of eager backward subsumed clauses
+-  int64_t elimbwstr;    // number of eager backward strengthened clauses
+-  int64_t ternary;      // number of ternary resolution phases
+-  int64_t ternres;      // number of ternary resolutions
+-  int64_t htrs;         // number of hyper ternary resolvents
+-  int64_t htrs2;        // number of binary hyper ternary resolvents
+-  int64_t htrs3;        // number of ternary hyper ternary resolvents
+-  int64_t decompositions; // number of SCC + ELS
+-  int64_t vivifications;  // number of vivifications
+-  int64_t vivifychecks; // checked clauses during vivification
+-  int64_t vivifydecs;   // vivification decisions
+-  int64_t vivifyreused; // reused vivification decisions
+-  int64_t vivifysched;  // scheduled clauses for vivification
+-  int64_t vivifysubs;   // subsumed clauses during vivification
+-  int64_t vivifystrs;   // strengthened clauses during vivification
+-  int64_t vivifystrirr; // strengthened irredundant clause
+-  int64_t vivifystred1; // strengthened redundant clause (1)
+-  int64_t vivifystred2; // strengthened redundant clause (2)
+-  int64_t vivifystred3; // strengthened redundant clause (3)
+-  int64_t vivifyunits;  // units during vivification
+-  int64_t transreds;
+-  int64_t transitive;
++  long compacts;     // number of compactifications
++  long shuffled;     // shuffled queues and scores
++  long restarts;     // actual number of happened restarts
++  long restartlevels;// levels at restart
++  long restartstable;// actual number of happened restarts
++  long stabphases;   // number of stabilization phases
++  long stabconflicts;// number of search conflicts during stabilizing
++  long rescored;     // number of times scores were rescored
++  long reused;       // number of reused trails
++  long reusedlevels; // reused levels at restart
++  long reusedstable; // number of reused trails during stabilizing
++  long sections;     // 'section' counter
++  long chrono;       // chronological backtracks
++  long backtracks;   // number of backtracks
++  long bumped;       // seen and bumped variables in 'analyze'
++  long searched;     // searched decisions in 'decide'
++  long reductions;   // 'reduce' counter
++  long reduced;      // number of reduced clauses
++  long collected;    // number of collected bytes
++  long collections;  // number of garbage collections
++  long hbrs;         // hyper binary resolvents
++  long hbrsizes;     // sum of hyper resolved base clauses
++  long hbreds;       // redundant hyper binary resolvents
++  long hbrsubs;      // subsuming hyper binary resolvents
++  long instried;     // number of tried instantiations
++  long instantiated; // number of successful instantiations
++  long instrounds;   // number of instantiation rounds
++  long subsumed;     // number of subsumed clauses
++  long deduplicated; // number of removed duplicated binary clauses
++  long deduplications;//number of deduplication phases
++  long strengthened; // number of strengthened clauses
++  long elimotfstr;   // number of on-the-fly strengthened during elimination
++  long subirr;       // number of subsumed irredundant clauses
++  long subred;       // number of subsumed redundant clauses
++  long subtried;     // number of tried subsumptions
++  long subchecks;    // number of pair-wise subsumption checks
++  long subchecks2;   // same but restricted to binary clauses
++  long elimotfsub;   // number of on-the-fly subsumed during elimination
++  long subsumerounds;// number of subsumption rounds
++  long subsumephases;// number of scheduled subsumption phases
++  long eagertried;   // number of traversed eager subsumed candidates
++  long eagersub;     // number of eagerly subsumed recently learned clauses
++  long elimres;      // number of resolved clauses in BVE
++  long elimrestried; // number of tried resolved clauses in BVE
++  long elimrounds;   // number of elimination rounds
++  long elimphases;   // number of scheduled elimination phases
++  long elimcompleted;// number complete elimination procedures
++  long elimtried;    // number of variable elimination attempts
++  long elimsubst;    // number of eliminations through substitutions
++  long elimgates;    // number of gates found during elimination
++  long elimequivs;   // number of equivalences found during elimination
++  long elimands;     // number of AND gates found during elimination
++  long elimites;     // number of ITE gates found during elimination
++  long elimxors;     // number of XOR gates found during elimination
++  long elimbwsub;    // number of eager backward subsumed clauses
++  long elimbwstr;    // number of eager backward strengthened clauses
++  long ternary;      // number of ternary resolution phases
++  long ternres;      // number of ternary resolutions
++  long htrs;         // number of hyper ternary resolvents
++  long htrs2;        // number of binary hyper ternary resolvents
++  long htrs3;        // number of ternary hyper ternary resolvents
++  long decompositions; // number of SCC + ELS
++  long vivifications;  // number of vivifications
++  long vivifychecks; // checked clauses during vivification
++  long vivifydecs;   // vivification decisions
++  long vivifyreused; // reused vivification decisions
++  long vivifysched;  // scheduled clauses for vivification
++  long vivifysubs;   // subsumed clauses during vivification
++  long vivifystrs;   // strengthened clauses during vivification
++  long vivifystrirr; // strengthened irredundant clause
++  long vivifystred1; // strengthened redundant clause (1)
++  long vivifystred2; // strengthened redundant clause (2)
++  long vivifystred3; // strengthened redundant clause (3)
++  long vivifyunits;  // units during vivification
++  long transreds;
++  long transitive;
+   struct {
+-    int64_t literals;
+-    int64_t clauses;
++    long literals;
++    long clauses;
+   } learned;
+-  int64_t minimized;    // minimized literals
+-  int64_t irrbytes;     // bytes of irredundant clauses
+-  int64_t garbage;      // bytes current irredundant garbage clauses
+-  int64_t units;        // learned unit clauses
+-  int64_t binaries;     // learned binary clauses
+-  int64_t probingphases;// number of scheduled probing phases
+-  int64_t probingrounds;// number of probing rounds
+-  int64_t probed;       // number of probed literals
+-  int64_t failed;       // number of failed literals
+-  int64_t hyperunary;   // hyper unary resolved unit clauses
+-  int64_t probefailed;  // failed literals from probing
+-  int64_t transredunits;// units derived in transitive reduction
+-  int64_t blockings;    // number of blocked clause eliminations
+-  int64_t blocked;      // number of actually blocked clauses
+-  int64_t blockres;     // number of resolutions during blocking
+-  int64_t blockcands;   // number of clause / pivot pairs tried
+-  int64_t blockpured;   // number of clauses blocked through pure literals
+-  int64_t blockpurelits;// number of pure literals
+-  int64_t extensions;   // number of extended witnesses
+-  int64_t extended;     // number of flipped literals during extension
+-  int64_t weakened;     // number of clauses pushed to extension stack
+-  int64_t weakenedlen;  // lengths of weakened clauses
+-  int64_t restorations; // number of restore calls
+-  int64_t restored;     // number of restored clauses
+-  int64_t reactivated;  // number of reactivated clauses
+-  int64_t restoredlits; // number of restored literals
+-
+-  int64_t preprocessings;
+-
+-  struct {
+-    int64_t fixed;       // number of top level assigned variables
+-    int64_t eliminated;  // number of eliminated variables
+-    int64_t substituted; // number of substituted variables
+-    int64_t pure;        // number of pure literals
++  long minimized;    // minimized literals
++  long irrbytes;     // bytes of irredundant clauses
++  long garbage;      // bytes current irredundant garbage clauses
++  long units;        // learned unit clauses
++  long binaries;     // learned binary clauses
++  long probingphases;// number of scheduled probing phases
++  long probingrounds;// number of probing rounds
++  long probed;       // number of probed literals
++  long failed;       // number of failed literals
++  long hyperunary;   // hyper unary resolved unit clauses
++  long probefailed;  // failed literals from probing
++  long transredunits;// units derived in transitive reduction
++  long blockings;    // number of blocked clause eliminations
++  long blocked;      // number of actually blocked clauses
++  long blockres;     // number of resolutions during blocking
++  long blockcands;   // number of clause / pivot pairs tried
++  long blockpured;   // number of clauses blocked through pure literals
++  long blockpurelits;// number of pure literals
++  long extensions;   // number of extended witnesses
++  long extended;     // number of flipped literals during extension
++  long weakened;     // number of clauses pushed to extension stack
++  long weakenedlen;  // lengths of weakened clauses
++  long restorations; // number of restore calls
++  long restored;     // number of restored clauses
++  long reactivated;  // number of reactivated clauses
++  long restoredlits; // number of restored literals
++
++  long preprocessings;
++  struct {
++    int fixed;       // number of top level assigned variables
++    int eliminated;  // number of eliminated variables
++    int substituted; // number of substituted variables
++    int pure;        // number of pure literals
+   } all, now;
+ 
+-  int64_t unused;        // number of unused variables
+-  int64_t active;        // number of active variables
+-  int64_t inactive;      // number of inactive variables
++  int unused;        // number of unused variables
++  int active;        // number of active variables
++  int inactive;      // number of inactive variables
+ 
+   Stats ();
+ 
+diff -Naur solvers/cadical/subsume.cpp solvers/cdc/subsume.cpp
+--- solvers/cadical/subsume.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/subsume.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -303,7 +303,7 @@
+     int u = internal->val (a), v = internal->val (b);
+     if (!u && v) return true;
+     if (u && !v) return false;
+-    int64_t m = internal->noccs (a), n = internal ->noccs (b);
++    long m = internal->noccs (a), n = internal ->noccs (b);
+     if (m < n) return true;
+     if (m > n) return false;
+     return abs (a) < abs (b);
+@@ -329,16 +329,16 @@
+   START_SIMPLIFIER (subsume, SUBSUME);
+   stats.subsumerounds++;
+ 
+-  int64_t check_limit;
++  long check_limit;
+   if (opts.subsumelimited) {
+-    int64_t delta = stats.propagations.search;
++    long delta = stats.propagations.search;
+     delta *= 1e-3 * opts.subsumereleff;
+     if (delta < opts.subsumemineff) delta = opts.subsumemineff;
+     if (delta > opts.subsumemaxeff) delta = opts.subsumemaxeff;
+-    delta = max (delta, (int64_t) 2l * active ());
++    delta = max (delta, 2l * active ());
+ 
+     PHASE ("subsume-round", stats.subsumerounds,
+-      "limit of %" PRId64 " subsumption checks", delta);
++      "limit of %ld subsumption checks", delta);
+ 
+     check_limit = stats.subchecks + delta;
+   } else {
+@@ -358,7 +358,7 @@
+ 
+   // Determine candidate clauses and sort them by size.
+   //
+-  int64_t left_over_from_last_subsumption_round = 0;
++  long left_over_from_last_subsumption_round = 0;
+ 
+   for (auto c : clauses) {
+ 
+@@ -407,10 +407,10 @@
+         cs.clause->subsume = true;
+ 
+ #ifndef QUIET
+-  int64_t scheduled = schedule.size ();
+-  int64_t total = stats.current.irredundant + stats.current.redundant;
++  long scheduled = schedule.size ();
++  long total = stats.current.irredundant + stats.current.redundant;
+   PHASE ("subsume-round", stats.subsumerounds,
+-    "scheduled %" PRId64 " clauses %.0f%% out of %" PRId64 " clauses",
++    "scheduled %ld clauses %.0f%% out of %ld clauses",
+     scheduled, percent (scheduled, total), total);
+ #endif
+ 
+@@ -421,7 +421,7 @@
+   // of its literals (with smallest number of occurrences at this point) in
+   // a one-watched scheme.
+ 
+-  int64_t subsumed = 0, strengthened = 0, checked = 0;
++  long subsumed = 0, strengthened = 0, checked = 0;
+ 
+   vector<Clause *> shrunken;
+   init_occs ();
+@@ -460,7 +460,7 @@
+     // occurrences computed before and stored in 'noccs'.
+     //
+     int minlit = 0;
+-    int64_t minoccs = 0;
++    long minoccs = 0;
+     size_t minsize = 0;
+     bool subsume = true;
+     bool binary = (c->size == 2 && !c->redundant);
+@@ -470,7 +470,7 @@
+       if (!flags (lit).subsume) subsume = false;
+       const size_t size = binary ? bins (lit).size () : occs (lit).size ();
+       if (minlit && minsize <= size) continue;
+-      const int64_t tmp = noccs (lit);
++      const long tmp = noccs (lit);
+       if (minlit && minsize == size && tmp <= minoccs) continue;
+       minlit = lit, minsize = size, minoccs = tmp;
+     }
+@@ -488,8 +488,8 @@
+       //
+       if (minsize > (size_t) opts.subsumeocclim) continue;
+ 
+-      LOG (c, "watching %d with %zd current and total %" PRId64 " occurrences",
+-        minlit, minsize, minoccs);
++      LOG (c, "watching %d with %ld current and total %ld occurrences",
++        minlit, (long) minsize, minoccs);
+ 
+       occs (minlit).push_back (c);
+ 
+@@ -511,8 +511,8 @@
+       if (minsize > (size_t) opts.subsumebinlim) continue;
+ 
+       LOG (c,
+-        "watching %d with %zd current binary and total %" PRId64 " occurrences",
+-        minlit, minsize, minoccs);
++        "watching %d with %ld current binary and total %ld occurrences",
++        minlit, (long) minsize, minoccs);
+ 
+       const int minlit_pos = (c->literals[1] == minlit);
+       const int other = c->literals[!minlit_pos];
+@@ -521,19 +521,19 @@
+   }
+ 
+   PHASE ("subsume-round", stats.subsumerounds,
+-    "subsumed %" PRId64 " and strengthened %" PRId64 " out of %" PRId64 " clauses %.0f%%",
++    "subsumed %ld and strengthened %ld out of %ld clauses %.0f%%",
+     subsumed, strengthened, scheduled,
+     percent (subsumed + strengthened, scheduled));
+ 
+-  const int64_t remain = schedule.size () - checked;
++  const long remain = schedule.size () - checked;
+   const bool completed = !remain;
+ 
+   if (completed)
+     PHASE ("subsume-round", stats.subsumerounds,
+-      "checked all %" PRId64 " scheduled clauses", checked);
++      "checked all %ld scheduled clauses", checked);
+   else
+     PHASE ("subsume-round", stats.subsumerounds,
+-      "checked %" PRId64 " clauses %.0f%% of scheduled (%zd remain)",
++      "checked %ld clauses %.0f%% of scheduled (%zd remain)",
+       checked, percent (checked, scheduled), remain);
+ 
+   // Release occurrence lists and schedule.
+@@ -588,7 +588,8 @@
+     }
+   }
+ 
+-  // Schedule 'vivification' in 'subsume' as well as 'transitive reduction'.
++  // Schedule 'vivification' in 'subsume' as well as 'transitive reduction'
++  // and 'covered clause elimination'.
+   //
+   if (opts.vivify) vivify ();
+   if (opts.transred) transred ();
+@@ -597,12 +598,11 @@
+ 
+   if (!update_limits) return;
+ 
+-  int64_t delta = scale (opts.subsumeint * (stats.subsumephases + 1));
++  long delta = scale (opts.subsumeint * (stats.subsumephases + 1));
+   lim.subsume = stats.conflicts + delta;
+ 
+   PHASE ("subsume-phase", stats.subsumephases,
+-    "new subsume limit %" PRId64 " after %" PRId64 " conflicts",
+-    lim.subsume, delta);
++    "new subsume limit %ld after %ld conflicts", lim.subsume, delta);
+ }
+ 
+ }
+diff -Naur solvers/cadical/ternary.cpp solvers/cdc/ternary.cpp
+--- solvers/cadical/ternary.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/ternary.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -128,7 +128,7 @@
+ // the effort spent in 'ternary' is that it should be similar to one
+ // propagation step during search.
+ 
+-void Internal::ternary_lit (int pivot, int64_t & steps, int64_t & htrs) {
++void Internal::ternary_lit (int pivot, long & steps, long & htrs) {
+   LOG ("starting hyper ternary resolutions on pivot %d", pivot);
+   for (const auto & c : occs (pivot)) {
+     if (htrs < 0) break;
+@@ -181,7 +181,7 @@
+ // Same as 'ternary_lit' but pick the phase of the variable based on the
+ // number of positive and negative occurrence.
+ 
+-void Internal::ternary_idx (int idx, int64_t & steps, int64_t & htrs) {
++void Internal::ternary_idx (int idx, long & steps, long & htrs) {
+   assert (0 < idx);
+   assert (idx <= max_var);
+   if (!active (idx)) return;
+@@ -209,11 +209,11 @@
+ // This function goes over each variable just once.
+ //
+ 
+-bool Internal::ternary_round (int64_t & steps_limit, int64_t & htrs_limit) {
++bool Internal::ternary_round (long & steps_limit, long & htrs_limit) {
+ 
+   assert (!unsat);
+ 
+-  int64_t bincon = 0, terncon = 0;
++  long bincon = 0, terncon = 0;
+ 
+   init_occs ();
+ 
+@@ -238,7 +238,7 @@
+   }
+ 
+   PHASE ("ternary", stats.ternary,
+-    "connected %" PRId64 " ternary %.0f%% and %" PRId64 " binary clauses %.0f%%",
++    "connected %ld ternary %.0f%% and %ld binary clauses %.0f%%",
+     terncon, percent (terncon, clauses.size ()),
+     bincon, percent (bincon, clauses.size ()));
+ 
+@@ -299,7 +299,7 @@
+   // all rounds of producing ternary resolvents on all marked variables in
+   // this call to the 'ternary' procedure.
+   //
+-  int64_t steps_limit = stats.propagations.search;
++  long steps_limit = stats.propagations.search;
+   steps_limit *= 1e-3 * opts.ternaryreleff;
+   if (steps_limit < opts.ternarymineff) steps_limit = opts.ternarymineff;
+   if (steps_limit > opts.ternarymaxeff) steps_limit = opts.ternarymaxeff;
+@@ -308,7 +308,7 @@
+   // substantially, particularly for random formulas.  Thus we limit the
+   // number of added clauses too (actually the number of 'htrs').
+   //
+-  int64_t htrs_limit = stats.current.redundant + stats.current.irredundant;
++  long htrs_limit = stats.current.redundant + stats.current.irredundant;
+   htrs_limit *= opts.ternarymaxadd;
+   htrs_limit /= 100;
+ 
+@@ -319,7 +319,7 @@
+   // it in the loop below.
+   //
+   PHASE ("ternary", stats.ternary,
+-    "will run a maximum of %d rounds limited to %" PRId64 " steps and %" PRId64 " clauses",
++    "will run a maximum of %d rounds limited to %ld steps and %ld clauses",
+     opts.ternaryrounds, steps_limit, htrs_limit);
+ 
+   bool resolved_binary_clause = false;
+@@ -338,7 +338,7 @@
+     int delta_htrs2 = stats.htrs2 - old_htrs2;
+     int delta_htrs3 = stats.htrs3 - old_htrs3;
+     PHASE ("ternary", stats.ternary,
+-      "derived %" PRId64 " ternary and %" PRId64 " binary resolvents",
++      "derived %ld ternary and %ld binary resolvents",
+       delta_htrs3, delta_htrs2);
+     report ('3', !opts.reportall && !(delta_htrs2 + delta_htrs2));
+     if (delta_htrs2) resolved_binary_clause = true;
+diff -Naur solvers/cadical/transred.cpp solvers/cdc/transred.cpp
+--- solvers/cadical/transred.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/transred.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -23,14 +23,14 @@
+   // Transitive reduction can not be run to completion for larger formulas
+   // with many binary clauses.  We bound it in the same way as 'probe_core'.
+   //
+-  int64_t limit = stats.propagations.search;
++  long limit = stats.propagations.search;
+   limit -= last.transred.propagations;
+   limit *= 1e-3 * opts.transredreleff;
+   if (limit < opts.transredmineff) limit = opts.transredmineff;
+   if (limit > opts.transredmaxeff) limit = opts.transredmaxeff;
+ 
+   PHASE ("transred", stats.transreds,
+-    "transitive reduction limit of %" PRId64 " propagations", limit);
++    "transitive reduction limit of %ld propagations", limit);
+ 
+   const auto end = clauses.end ();
+   auto i = clauses.begin ();
+@@ -68,7 +68,7 @@
+   //
+   vector<int> work;
+ 
+-  int64_t propagations = 0, units = 0, removed = 0;
++  long propagations = 0, units = 0, removed = 0;
+ 
+   while (!unsat && i != end && !terminating () && propagations < limit) {
+     Clause * c = *i++;
+@@ -182,7 +182,7 @@
+   erase_vector (work);
+ 
+   PHASE ("transred", stats.transreds,
+-    "removed %" PRId64 " transitive clauses, found %d units",
++    "removed %ld transitive clauses, found %d units",
+     removed, units);
+ 
+   STOP_SIMPLIFIER (transred, TRANSRED);
+diff -Naur solvers/cadical/util.hpp solvers/cdc/util.hpp
+--- solvers/cadical/util.hpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/util.hpp	2019-07-11 19:07:06.000000000 +1000
+@@ -25,8 +25,7 @@
+ 
+ inline bool is_power_of_two (unsigned n) { return n && !(n & (n-1)); }
+ 
+-inline bool
+-contained (int64_t c, int64_t l, int64_t u) { return l <= c && c <= u; }
++inline bool contained (long c, long l, long u) { return l <= c && c <= u; }
+ 
+ /*------------------------------------------------------------------------*/
+ 
+diff -Naur solvers/cadical/version.cpp solvers/cdc/version.cpp
+--- solvers/cadical/version.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/version.cpp	2020-07-04 15:25:53.000000000 +1000
+@@ -5,7 +5,7 @@
+ // defining '-DNBUILD'.  Then we try to guess part of the configuration.
+ 
+ #ifndef NBUILD
+-#include <build.hpp>
++#include "build.hpp"
+ #endif
+ 
+ /*------------------------------------------------------------------------*/
+@@ -17,7 +17,7 @@
+ // build process relies on 'VERSION' to be defined in 'build.hpp'.
+ 
+ #ifndef VERSION
+-#  define VERSION "1.0.3"
++#  define VERSION "1.0.2"
+ #endif
+ 
+ /*------------------------------------------------------------------------*/
+diff -Naur solvers/cadical/vivify.cpp solvers/cdc/vivify.cpp
+--- solvers/cadical/vivify.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/vivify.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -85,7 +85,7 @@
+   require_mode (VIVIFY);
+   assert (!unsat);
+   START (propagate);
+-  int64_t before = propagated2 = propagated;
++  long before = propagated2 = propagated;
+   for (;;) {
+     if (propagated2 != trail.size ()) {
+       const int lit = -trail[propagated2++];
+@@ -158,7 +158,7 @@
+       }
+     } else break;
+   }
+-  int64_t delta = propagated2 - before;
++  long delta = propagated2 - before;
+   stats.propagations.vivify += delta;
+   if (conflict) LOG (conflict, "conflict");
+   STOP (propagate);
+@@ -168,8 +168,8 @@
+ /*------------------------------------------------------------------------*/
+ 
+ // Check whether a literal occurs less often.  In the implementation below
+-// (search for 'int64_t score = ...' or '@4') we actually compute a
+-// weighted occurrence count similar to the Jeroslow Wang heuristic.
++// (search for 'long score = ...' or '@4') we actually compute a weighted
++// occurrence count similar to the Jeroslow Wang heuristic.
+ 
+ struct vivify_more_noccs {
+ 
+@@ -178,8 +178,8 @@
+   vivify_more_noccs (Internal * i) : internal (i) { }
+ 
+   bool operator () (int a, int b) {
+-    int64_t n = internal->noccs (a);
+-    int64_t m = internal->noccs (b);
++    long n = internal->noccs (a);
++    long m = internal->noccs (b);
+     if (n > m) return true;     // larger occurrences / score first
+     if (n < m) return false;    // smaller occurrences / score last
+     if (a == -b) return a > 0;  // positive literal first
+@@ -304,7 +304,7 @@
+   auto j = schedule.begin (), i = j;
+ 
+   Clause * prev = 0;
+-  int64_t subsumed = 0;
++  long subsumed = 0;
+   for (; i != end; i++) {
+     Clause * c = *j++ = *i;
+     if (!prev || c->size < prev->size) { prev = c; continue; }
+@@ -326,7 +326,7 @@
+ 
+   if (subsumed)
+     PHASE ("vivify", stats.vivifications,
+-       "flushed %" PRId64 " subsumed scheduled clauses", subsumed);
++       "flushed %ld subsumed scheduled clauses", subsumed);
+ 
+   stats.vivifysubs += subsumed;
+ 
+@@ -645,7 +645,7 @@
+     LOG ("reused %d decision levels from %d", level, orig_level);
+   }
+ 
+-  LOG (sorted, "sorted size %zd probing schedule", sorted.size ());
++  LOG (sorted, "sorted size %ld probing schedule", (long) sorted.size ());
+ 
+   // Make sure to ignore this clause during propagation.  This is not that
+   // easy for binary clauses (NO-BINARY), e.g., ignoring binary clauses,
+@@ -746,7 +746,7 @@
+ 
+       stats.vivifydecs++;
+       vivify_assume (-lit);
+-      LOG ("negated decision %d score %" PRId64 "", lit, noccs (lit));
++      LOG ("negated decision %d score %ld", lit, noccs (lit));
+ 
+       if (vivify_propagate ()) continue;        // hot-spot
+ 
+@@ -865,12 +865,12 @@
+ // tautologies (clauses subsumed through unit propagation), which in
+ // redundant mode is incorrect (due to propagating over redundant clauses).
+ 
+-void Internal::vivify_round (bool redundant_mode, int64_t propagation_limit) {
++void Internal::vivify_round (bool redundant_mode, long propagation_limit) {
+ 
+   if (unsat || terminating ()) return;
+ 
+   PHASE ("vivify", stats.vivifications,
+-    "starting %s vivification round propagation limit %" PRId64 "",
++    "starting %s vivification round propagation limit %ld",
+     redundant_mode ? "redundant" : "irredundant", propagation_limit);
+ 
+   // Disconnect all watches since we sort literals within clauses.
+@@ -897,7 +897,7 @@
+     // See the example above (search for '@1').
+     //
+     const int shift = 12 - c->size;
+-    const int64_t score = shift < 1 ? 1 : (1l << shift);           // @4
++    const long score = shift < 1 ? 1 : (1l << shift);           // @4
+ 
+     for (const auto lit : *c)
+       noccs (lit) += score;
+@@ -944,21 +944,21 @@
+   // Remember old values of counters to summarize after each round with
+   // verbose messages what happened in that round.
+   //
+-  int64_t checked      = stats.vivifychecks;
+-  int64_t subsumed     = stats.vivifysubs;
+-  int64_t strengthened = stats.vivifystrs;
+-  int64_t units        = stats.vivifyunits;
++  long checked      = stats.vivifychecks;
++  long subsumed     = stats.vivifysubs;
++  long strengthened = stats.vivifystrs;
++  long units        = stats.vivifyunits;
+ 
+-  int64_t scheduled = vivifier.schedule.size ();
++  long scheduled = vivifier.schedule.size ();
+   stats.vivifysched += scheduled;
+ 
+   PHASE ("vivify", stats.vivifications,
+-    "scheduled %" PRId64 " clauses to be vivified %.0f%%",
++    "scheduled %ld clauses to be vivified %.0f%%",
+     scheduled, percent (scheduled, stats.current.irredundant));
+ 
+   // Limit the number of propagations during vivification as in 'probe'.
+   //
+-  const int64_t limit = stats.propagations.vivify + propagation_limit;
++  const long limit = stats.propagations.vivify + propagation_limit;
+ 
+   connect_watches (!redundant_mode);       // watch all relevant clauses
+ 
+@@ -982,7 +982,7 @@
+ 
+     reset_noccs ();
+ 
+-    int64_t still_need_to_be_vivified = 0;
++    long still_need_to_be_vivified = 0;
+     for (const auto & c : vivifier.schedule)
+       if (c->vivify)
+         still_need_to_be_vivified++;
+@@ -991,7 +991,7 @@
+     //
+     if (still_need_to_be_vivified)
+       PHASE ("vivify", stats.vivifications,
+-        "still need to vivify %" PRId64 " clauses %.02f%% of %" PRId64 " scheduled",
++        "still need to vivify %ld clauses %.02f%% of %ld scheduled",
+         still_need_to_be_vivified,
+         percent (still_need_to_be_vivified, scheduled),
+         scheduled);
+@@ -1030,19 +1030,19 @@
+   units        = stats.vivifyunits  - units;
+ 
+   PHASE ("vivify", stats.vivifications,
+-    "checked %" PRId64 " clauses %.02f%% of %" PRId64 " scheduled",
++    "checked %ld clauses %.02f%% of %ld scheduled",
+     checked, percent (checked, scheduled), scheduled);
+   if (units)
+     PHASE ("vivify", stats.vivifications,
+-      "found %" PRId64 " units %.02f%% of %" PRId64 " checked",
++      "found %ld units %.02f%% of %ld checked",
+       units, percent (units, checked), checked);
+   if (subsumed)
+     PHASE ("vivify", stats.vivifications,
+-      "subsumed %" PRId64 " clauses %.02f%% of %" PRId64 " checked",
++      "subsumed %ld clauses %.02f%% of %ld checked",
+       subsumed, percent (subsumed, checked), checked);
+   if (strengthened)
+     PHASE ("vivify", stats.vivifications,
+-      "strengthened %" PRId64 " clauses %.02f%% of %" PRId64 " checked",
++      "strengthened %ld clauses %.02f%% of %ld checked",
+       strengthened, percent (strengthened, checked), checked);
+ 
+   stats.subsumed     += subsumed;
+@@ -1068,14 +1068,14 @@
+   START_SIMPLIFIER (vivify, VIVIFY);
+   stats.vivifications++;
+ 
+-  int64_t limit = stats.propagations.search;
++  long limit = stats.propagations.search;
+   limit -= last.vivify.propagations;
+   limit *= 1e-3 * opts.vivifyreleff;
+   if (limit < opts.vivifymineff) limit = opts.vivifymineff;
+   if (limit > opts.vivifymaxeff) limit = opts.vivifymaxeff;
+ 
+   PHASE ("vivify", stats.vivifications,
+-    "vivification limit of twice %" PRId64 " propagations", limit);
++    "vivification limit of twice %ld propagations", limit);
+ 
+   vivify_round (false, limit); // Vivify only irredundant clauses.
+ 
+diff -Naur solvers/cadical/walk.cpp solvers/cdc/walk.cpp
+--- solvers/cadical/walk.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/walk.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -11,8 +11,8 @@
+   Internal * internal;
+ 
+   Random random;                // local random number generator
+-  int64_t propagations;         // number of propagations
+-  int64_t limit;                // limit on number of propagations
++  long propagations;            // number of propagations
++  long limit;                   // limit on number of propagations
+   vector <Clause *> broken;     // currently unsatisfied clauses
+   double epsilon;               // smallest considered score
+   vector<double> table;         // break value to score table
+@@ -20,7 +20,7 @@
+ 
+   double score (unsigned);      // compute score from break count
+ 
+-  Walker (Internal *, double size, int64_t limit);
++  Walker (Internal *, double size, long limit);
+ };
+ 
+ // These are in essence the CB values from Adrian Balint's thesis.  They
+@@ -63,7 +63,7 @@
+ 
+ // Initialize the data structures for one local search round.
+ 
+-Walker::Walker (Internal * i, double size, int64_t l) :
++Walker::Walker (Internal * i, double size, long l) :
+   internal (i),
+   random (internal->opts.seed),         // global random seed
+   propagations (0),
+@@ -73,7 +73,7 @@
+ 
+   // This is the magic constant in ProbSAT (also called 'CB'), which we pick
+   // according to the average size every second invocation and otherwise
+-  // just the default '2.0', which turns into the base '0.5'.
++  // just the default '2.0', which turns into into the base '0.5'.
+   //
+   const bool use_size_based_cb = (internal->stats.walk.count & 1);
+   const double cb = use_size_based_cb ? fitcbval (size) : 2.0;
+@@ -102,7 +102,7 @@
+ Clause * Internal::walk_pick_clause (Walker & walker) {
+   require_mode (WALK);
+   assert (!walker.broken.empty ());
+-  int64_t size = walker.broken.size ();
++  long size = walker.broken.size ();
+   if (size > INT_MAX) size = INT_MAX;
+   int pos = walker.random.pick_int (0, size-1);
+   Clause * res = walker.broken[pos];
+@@ -187,7 +187,7 @@
+   LOG ("picking literal by break-count");
+   assert (walker.scores.empty ());
+   double sum = 0;
+-  int64_t propagations = 0;
++  long propagations = 0;
+   for (const auto lit : *c) {
+     assert (active (lit));
+     if (var (lit).level == 1) {
+@@ -271,7 +271,7 @@
+     const double ratio = clause_variable_ratio ();
+     const auto eou = walker.broken.end ();
+     auto j = walker.broken.begin (), i = j;
+-    int64_t made = 0, count = 0;
++    long made = 0, count = 0;
+ 
+     while (i != eou) {
+ 
+@@ -320,7 +320,7 @@
+       walker.propagations++;
+       stats.propagations.walk++;
+     }
+-    LOG ("made %" PRId64 " clauses by flipping %d", made, lit);
++    LOG ("made %ld clauses by flipping %d", made, lit);
+     walker.broken.resize (j - walker.broken.begin ());
+   }
+ 
+@@ -329,7 +329,7 @@
+     walker.propagations++;      // This really corresponds now to one
+     stats.propagations.walk++;  // propagation (in a one-watch scheme).
+ 
+-    int64_t broken = 0;
++    long broken = 0;
+     Watches & ws = watches (-lit);
+ 
+     LOG ("trying to brake %zd watched clauses", ws.size ());
+@@ -367,7 +367,7 @@
+         broken++;
+       }
+     }
+-    LOG ("broken %" PRId64 " clauses by flipping %d", broken, lit);
++    LOG ("broken %ld clauses by flipping %d", broken, lit);
+     ws.clear ();
+   }
+ }
+@@ -377,16 +377,16 @@
+ // Check whether to save the current phases as new global minimum.
+ 
+ inline void Internal::walk_save_minimum (Walker & walker) {
+-  int64_t broken = walker.broken.size ();
++  long broken = walker.broken.size ();
+   if (broken >= stats.walk.minimum) return;
+-  VERBOSE (3, "new global minimum %" PRId64 "", broken);
++  VERBOSE (3, "new global minimum %ld", broken);
+   stats.walk.minimum = broken;
+   copy_phases (phases.min);
+ }
+ 
+ /*------------------------------------------------------------------------*/
+ 
+-int Internal::walk_round (int64_t limit, bool prev) {
++int Internal::walk_round (long limit, bool prev) {
+ 
+   backtrack ();
+   if (propagated < trail.size () && !propagate ()) {
+@@ -414,12 +414,12 @@
+ #endif
+ 
+   PHASE ("walk", stats.walk.count,
+-    "random walk limit of %" PRId64 " propagations", limit);
++    "random walk limit of %ld propagations", limit);
+ 
+   // First compute the average clause size for picking the CB constant.
+   //
+   double size = 0;
+-  int64_t n = 0;
++  long n = 0;
+   for (const auto c : clauses) {
+     if (c->garbage) continue;
+     if (c->redundant) {
+@@ -432,7 +432,7 @@
+   double average_size = relative (size, n);
+ 
+   PHASE ("walk", stats.walk.count,
+-    "%" PRId64 " clauses average size %.2f over %d variables",
++    "%ld clauses average size %.2f over %d variables",
+     n, average_size, active ());
+ 
+   // Instantiate data structures for this local search round.
+@@ -496,7 +496,7 @@
+ 
+     LOG ("watching satisfied and registering broken clauses");
+ #ifdef LOGGING
+-    int64_t watched = 0;
++    long watched = 0;
+ #endif
+     for (const auto c : clauses) {
+ 
+@@ -547,31 +547,31 @@
+     }
+ #ifdef LOGGING
+     if (!failed) {
+-      int64_t broken = walker.broken.size ();
+-      int64_t total = watched + broken;
+-      LOG ("watching %" PRId64 " clauses %.0f%% out of %" PRId64 " (watched and broken)",
++      long broken = walker.broken.size ();
++      long total = watched + broken;
++      LOG ("watching %ld clauses %.0f%% out of %ld (watched and broken)",
+         watched, percent (watched, total), total);
+     }
+ #endif
+   }
+ 
+-  int64_t old_global_minimum = stats.walk.minimum;
++  long old_global_minimum = stats.walk.minimum;
+ 
+   int res;      // Tells caller to continue with local search.
+ 
+   if (!failed) {
+ 
+-    int64_t broken = walker.broken.size ();
++    long broken = walker.broken.size ();
+ 
+     PHASE ("walk", stats.walk.count,
+-     "starting with %" PRId64 " unsatisfied clauses (%.0f%% out of %" PRId64 ")",
++     "starting with %ld unsatisfied clauses (%.0f%% out of %ld)",
+      broken, percent (broken, stats.current.irredundant),
+      stats.current.irredundant);
+ 
+     copy_phases (phases.saved);
+     walk_save_minimum (walker);
+ 
+-    int64_t flips = 0, minimum = broken;
++    long flips = 0, minimum = broken;
+     while (!terminating () &&
+            !walker.broken.empty () &&
+            walker.propagations < walker.limit) {
+@@ -582,11 +582,11 @@
+       const int lit = walk_pick_lit (walker, c);
+       walk_flip_lit (walker, lit);
+       broken = walker.broken.size ();
+-      LOG ("now have %" PRId64 " broken clauses in total", broken);
++      LOG ("now have %ld broken clauses in total", broken);
+       if (broken >= minimum) continue;
+       minimum = broken;
+       VERBOSE (3,
+-        "new phase minimum %" PRId64 " after %" PRId64 " flips",
++        "new phase minimum %ld after %ld flips",
+         minimum, flips);
+       copy_phases (phases.saved);
+       walk_save_minimum (walker);
+@@ -594,12 +594,12 @@
+ 
+     if (minimum < old_global_minimum)
+       PHASE ("walk", stats.walk.count,
+-        "%snew global minimum %" PRId64 "%s in %" PRId64 " flips and %" PRId64 " propagations",
++        "%snew global minimum %ld%s in %ld flips and %ld propagations",
+         tout.bright_yellow_code (), minimum, tout.normal_code (),
+         flips, walker.propagations);
+     else
+       PHASE ("walk", stats.walk.count,
+-        "best phase minimum %" PRId64 " in %" PRId64 " flips and %" PRId64 " propagations",
++        "best phase minimum %ld in %ld flips and %ld propagations",
+         minimum, flips, walker.propagations);
+ 
+     PHASE ("walk", stats.walk.count,
+@@ -651,7 +651,7 @@
+ 
+ void Internal::walk () {
+   START_INNER_WALK ();
+-  int64_t limit = stats.propagations.search;
++  long limit = stats.propagations.search;
+   limit *= 1e-3 * opts.walkreleff;
+   if (limit < opts.walkmineff) limit = opts.walkmineff;
+   if (limit > opts.walkmaxeff) limit = opts.walkmaxeff;
+diff -Naur solvers/cadical/watch.cpp solvers/cdc/watch.cpp
+--- solvers/cadical/watch.cpp	2019-07-13 06:22:02.000000000 +1000
++++ solvers/cdc/watch.cpp	2019-07-11 19:06:47.000000000 +1000
+@@ -7,6 +7,7 @@
+   while (wtab.size () < 2*vsize)
+     wtab.push_back (Watches ());
+   LOG ("initialized watcher tables");
++  assert (sizeof (Watch) == 16);
+ }
+ 
+ void Internal::clear_watches () {
diff --git a/solvers/prepare.py b/solvers/prepare.py
index f947be1..97ccaa5 100644
--- a/solvers/prepare.py
+++ b/solvers/prepare.py
@@ -421,8 +421,6 @@ def do(to_install):
         adapt_files(solver)
         patch_solver(solver)
 
-        if platform.system() != 'Windows':
-            compile_solver(solver)
 
 #
 #==============================================================================
