From b6cca75fd5fd822fb6d4d9c950b77eccaa2ca75e Mon Sep 17 00:00:00 2001
From: Gabriel Fougeron <gabriel.fougeron@hotmail.fr>
Date: Tue, 15 Mar 2022 10:49:56 +0100
Subject: [PATCH 17/17] Init

---
 sparseqr/_sparseqr.c     | 2107 ++++++++++++++++++++++++++++++++++++++
 sparseqr/sparseqr_gen.py |   20 +-
 2 files changed, 2123 insertions(+), 4 deletions(-)
 create mode 100644 sparseqr/_sparseqr.c

diff --git a/sparseqr/_sparseqr.c b/sparseqr/_sparseqr.c
new file mode 100644
index 0000000..9583e48
--- /dev/null
+++ b/sparseqr/_sparseqr.c
@@ -0,0 +1,2107 @@
+#define _CFFI_
+
+/* We try to define Py_LIMITED_API before including Python.h.
+
+   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
+   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
+   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
+   the same works for the other two macros.  Py_DEBUG implies them,
+   but not the other way around.
+
+   The implementation is messy (issue #350): on Windows, with _MSC_VER,
+   we have to define Py_LIMITED_API even before including pyconfig.h.
+   In that case, we guess what pyconfig.h will do to the macros above,
+   and check our guess after the #include.
+
+   Note that on Windows, with CPython 3.x, you need >= 3.5 and virtualenv
+   version >= 16.0.0.  With older versions of either, you don't get a
+   copy of PYTHON3.DLL in the virtualenv.  We can't check the version of
+   CPython *before* we even include pyconfig.h.  ffi.set_source() puts
+   a ``#define _CFFI_NO_LIMITED_API'' at the start of this file if it is
+   running on Windows < 3.5, as an attempt at fixing it, but that's
+   arguably wrong because it may not be the target version of Python.
+   Still better than nothing I guess.  As another workaround, you can
+   remove the definition of Py_LIMITED_API here.
+
+   See also 'py_limited_api' in cffi/setuptools_ext.py.
+*/
+#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
+#  ifdef _MSC_VER
+#    if !defined(_DEBUG) && !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
+#      define Py_LIMITED_API
+#    endif
+#    include <pyconfig.h>
+     /* sanity-check: Py_LIMITED_API will cause crashes if any of these
+        are also defined.  Normally, the Python file PC/pyconfig.h does not
+        cause any of these to be defined, with the exception that _DEBUG
+        causes Py_DEBUG.  Double-check that. */
+#    ifdef Py_LIMITED_API
+#      if defined(Py_DEBUG)
+#        error "pyconfig.h unexpectedly defines Py_DEBUG, but Py_LIMITED_API is set"
+#      endif
+#      if defined(Py_TRACE_REFS)
+#        error "pyconfig.h unexpectedly defines Py_TRACE_REFS, but Py_LIMITED_API is set"
+#      endif
+#      if defined(Py_REF_DEBUG)
+#        error "pyconfig.h unexpectedly defines Py_REF_DEBUG, but Py_LIMITED_API is set"
+#      endif
+#    endif
+#  else
+#    include <pyconfig.h>
+#    if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
+#      define Py_LIMITED_API
+#    endif
+#  endif
+#endif
+
+#include <Python.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <stddef.h>
+
+/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
+   beginning of C sources generated by CFFI's ffi.set_source(). */
+
+typedef void *_cffi_opcode_t;
+
+#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
+#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
+#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)
+
+#define _CFFI_OP_PRIMITIVE       1
+#define _CFFI_OP_POINTER         3
+#define _CFFI_OP_ARRAY           5
+#define _CFFI_OP_OPEN_ARRAY      7
+#define _CFFI_OP_STRUCT_UNION    9
+#define _CFFI_OP_ENUM           11
+#define _CFFI_OP_FUNCTION       13
+#define _CFFI_OP_FUNCTION_END   15
+#define _CFFI_OP_NOOP           17
+#define _CFFI_OP_BITFIELD       19
+#define _CFFI_OP_TYPENAME       21
+#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
+#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
+#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
+#define _CFFI_OP_CONSTANT       29
+#define _CFFI_OP_CONSTANT_INT   31
+#define _CFFI_OP_GLOBAL_VAR     33
+#define _CFFI_OP_DLOPEN_FUNC    35
+#define _CFFI_OP_DLOPEN_CONST   37
+#define _CFFI_OP_GLOBAL_VAR_F   39
+#define _CFFI_OP_EXTERN_PYTHON  41
+
+#define _CFFI_PRIM_VOID          0
+#define _CFFI_PRIM_BOOL          1
+#define _CFFI_PRIM_CHAR          2
+#define _CFFI_PRIM_SCHAR         3
+#define _CFFI_PRIM_UCHAR         4
+#define _CFFI_PRIM_SHORT         5
+#define _CFFI_PRIM_USHORT        6
+#define _CFFI_PRIM_INT           7
+#define _CFFI_PRIM_UINT          8
+#define _CFFI_PRIM_LONG          9
+#define _CFFI_PRIM_ULONG        10
+#define _CFFI_PRIM_LONGLONG     11
+#define _CFFI_PRIM_ULONGLONG    12
+#define _CFFI_PRIM_FLOAT        13
+#define _CFFI_PRIM_DOUBLE       14
+#define _CFFI_PRIM_LONGDOUBLE   15
+
+#define _CFFI_PRIM_WCHAR        16
+#define _CFFI_PRIM_INT8         17
+#define _CFFI_PRIM_UINT8        18
+#define _CFFI_PRIM_INT16        19
+#define _CFFI_PRIM_UINT16       20
+#define _CFFI_PRIM_INT32        21
+#define _CFFI_PRIM_UINT32       22
+#define _CFFI_PRIM_INT64        23
+#define _CFFI_PRIM_UINT64       24
+#define _CFFI_PRIM_INTPTR       25
+#define _CFFI_PRIM_UINTPTR      26
+#define _CFFI_PRIM_PTRDIFF      27
+#define _CFFI_PRIM_SIZE         28
+#define _CFFI_PRIM_SSIZE        29
+#define _CFFI_PRIM_INT_LEAST8   30
+#define _CFFI_PRIM_UINT_LEAST8  31
+#define _CFFI_PRIM_INT_LEAST16  32
+#define _CFFI_PRIM_UINT_LEAST16 33
+#define _CFFI_PRIM_INT_LEAST32  34
+#define _CFFI_PRIM_UINT_LEAST32 35
+#define _CFFI_PRIM_INT_LEAST64  36
+#define _CFFI_PRIM_UINT_LEAST64 37
+#define _CFFI_PRIM_INT_FAST8    38
+#define _CFFI_PRIM_UINT_FAST8   39
+#define _CFFI_PRIM_INT_FAST16   40
+#define _CFFI_PRIM_UINT_FAST16  41
+#define _CFFI_PRIM_INT_FAST32   42
+#define _CFFI_PRIM_UINT_FAST32  43
+#define _CFFI_PRIM_INT_FAST64   44
+#define _CFFI_PRIM_UINT_FAST64  45
+#define _CFFI_PRIM_INTMAX       46
+#define _CFFI_PRIM_UINTMAX      47
+#define _CFFI_PRIM_FLOATCOMPLEX 48
+#define _CFFI_PRIM_DOUBLECOMPLEX 49
+#define _CFFI_PRIM_CHAR16       50
+#define _CFFI_PRIM_CHAR32       51
+
+#define _CFFI__NUM_PRIM         52
+#define _CFFI__UNKNOWN_PRIM           (-1)
+#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
+#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)
+
+#define _CFFI__IO_FILE_STRUCT         (-1)
+
+
+struct _cffi_global_s {
+    const char *name;
+    void *address;
+    _cffi_opcode_t type_op;
+    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
+                              // OP_CPYTHON_BLTN_*: addr of direct function
+};
+
+struct _cffi_getconst_s {
+    unsigned long long value;
+    const struct _cffi_type_context_s *ctx;
+    int gindex;
+};
+
+struct _cffi_struct_union_s {
+    const char *name;
+    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
+    int flags;               // _CFFI_F_* flags below
+    size_t size;
+    int alignment;
+    int first_field_index;   // -> _cffi_fields array
+    int num_fields;
+};
+#define _CFFI_F_UNION         0x01   // is a union, not a struct
+#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
+                                     // "standard layout" or if some are missing
+#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
+#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
+#define _CFFI_F_OPAQUE        0x10   // opaque
+
+struct _cffi_field_s {
+    const char *name;
+    size_t field_offset;
+    size_t field_size;
+    _cffi_opcode_t field_type_op;
+};
+
+struct _cffi_enum_s {
+    const char *name;
+    int type_index;          // -> _cffi_types, on a OP_ENUM
+    int type_prim;           // _CFFI_PRIM_xxx
+    const char *enumerators; // comma-delimited string
+};
+
+struct _cffi_typename_s {
+    const char *name;
+    int type_index;   /* if opaque, points to a possibly artificial
+                         OP_STRUCT which is itself opaque */
+};
+
+struct _cffi_type_context_s {
+    _cffi_opcode_t *types;
+    const struct _cffi_global_s *globals;
+    const struct _cffi_field_s *fields;
+    const struct _cffi_struct_union_s *struct_unions;
+    const struct _cffi_enum_s *enums;
+    const struct _cffi_typename_s *typenames;
+    int num_globals;
+    int num_struct_unions;
+    int num_enums;
+    int num_typenames;
+    const char *const *includes;
+    int num_types;
+    int flags;      /* future extension */
+};
+
+struct _cffi_parse_info_s {
+    const struct _cffi_type_context_s *ctx;
+    _cffi_opcode_t *output;
+    unsigned int output_size;
+    size_t error_location;
+    const char *error_message;
+};
+
+struct _cffi_externpy_s {
+    const char *name;
+    size_t size_of_result;
+    void *reserved1, *reserved2;
+};
+
+#ifdef _CFFI_INTERNAL
+static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
+static int search_in_globals(const struct _cffi_type_context_s *ctx,
+                             const char *search, size_t search_len);
+static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
+                                   const char *search, size_t search_len);
+#endif
+
+/* this block of #ifs should be kept exactly identical between
+   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
+   and cffi/_cffi_include.h */
+#if defined(_MSC_VER)
+# include <malloc.h>   /* for alloca() */
+# if _MSC_VER < 1600   /* MSVC < 2010 */
+   typedef __int8 int8_t;
+   typedef __int16 int16_t;
+   typedef __int32 int32_t;
+   typedef __int64 int64_t;
+   typedef unsigned __int8 uint8_t;
+   typedef unsigned __int16 uint16_t;
+   typedef unsigned __int32 uint32_t;
+   typedef unsigned __int64 uint64_t;
+   typedef __int8 int_least8_t;
+   typedef __int16 int_least16_t;
+   typedef __int32 int_least32_t;
+   typedef __int64 int_least64_t;
+   typedef unsigned __int8 uint_least8_t;
+   typedef unsigned __int16 uint_least16_t;
+   typedef unsigned __int32 uint_least32_t;
+   typedef unsigned __int64 uint_least64_t;
+   typedef __int8 int_fast8_t;
+   typedef __int16 int_fast16_t;
+   typedef __int32 int_fast32_t;
+   typedef __int64 int_fast64_t;
+   typedef unsigned __int8 uint_fast8_t;
+   typedef unsigned __int16 uint_fast16_t;
+   typedef unsigned __int32 uint_fast32_t;
+   typedef unsigned __int64 uint_fast64_t;
+   typedef __int64 intmax_t;
+   typedef unsigned __int64 uintmax_t;
+# else
+#  include <stdint.h>
+# endif
+# if _MSC_VER < 1800   /* MSVC < 2013 */
+#  ifndef __cplusplus
+    typedef unsigned char _Bool;
+#  endif
+# endif
+#else
+# include <stdint.h>
+# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
+#  include <alloca.h>
+# endif
+#endif
+
+#ifdef __GNUC__
+# define _CFFI_UNUSED_FN  __attribute__((unused))
+#else
+# define _CFFI_UNUSED_FN  /* nothing */
+#endif
+
+#ifdef __cplusplus
+# ifndef _Bool
+   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
+# endif
+#endif
+
+/**********  CPython-specific section  **********/
+#ifndef PYPY_VERSION
+
+
+#if PY_MAJOR_VERSION >= 3
+# define PyInt_FromLong PyLong_FromLong
+#endif
+
+#define _cffi_from_c_double PyFloat_FromDouble
+#define _cffi_from_c_float PyFloat_FromDouble
+#define _cffi_from_c_long PyInt_FromLong
+#define _cffi_from_c_ulong PyLong_FromUnsignedLong
+#define _cffi_from_c_longlong PyLong_FromLongLong
+#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
+#define _cffi_from_c__Bool PyBool_FromLong
+
+#define _cffi_to_c_double PyFloat_AsDouble
+#define _cffi_to_c_float PyFloat_AsDouble
+
+#define _cffi_from_c_int(x, type)                                        \
+    (((type)-1) > 0 ? /* unsigned */                                     \
+        (sizeof(type) < sizeof(long) ?                                   \
+            PyInt_FromLong((long)x) :                                    \
+         sizeof(type) == sizeof(long) ?                                  \
+            PyLong_FromUnsignedLong((unsigned long)x) :                  \
+            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
+        (sizeof(type) <= sizeof(long) ?                                  \
+            PyInt_FromLong((long)x) :                                    \
+            PyLong_FromLongLong((long long)x)))
+
+#define _cffi_to_c_int(o, type)                                          \
+    ((type)(                                                             \
+     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
+                                         : (type)_cffi_to_c_i8(o)) :     \
+     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
+                                         : (type)_cffi_to_c_i16(o)) :    \
+     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
+                                         : (type)_cffi_to_c_i32(o)) :    \
+     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
+                                         : (type)_cffi_to_c_i64(o)) :    \
+     (Py_FatalError("unsupported size for type " #type), (type)0)))
+
+#define _cffi_to_c_i8                                                    \
+                 ((int(*)(PyObject *))_cffi_exports[1])
+#define _cffi_to_c_u8                                                    \
+                 ((int(*)(PyObject *))_cffi_exports[2])
+#define _cffi_to_c_i16                                                   \
+                 ((int(*)(PyObject *))_cffi_exports[3])
+#define _cffi_to_c_u16                                                   \
+                 ((int(*)(PyObject *))_cffi_exports[4])
+#define _cffi_to_c_i32                                                   \
+                 ((int(*)(PyObject *))_cffi_exports[5])
+#define _cffi_to_c_u32                                                   \
+                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
+#define _cffi_to_c_i64                                                   \
+                 ((long long(*)(PyObject *))_cffi_exports[7])
+#define _cffi_to_c_u64                                                   \
+                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
+#define _cffi_to_c_char                                                  \
+                 ((int(*)(PyObject *))_cffi_exports[9])
+#define _cffi_from_c_pointer                                             \
+    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
+#define _cffi_to_c_pointer                                               \
+    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
+#define _cffi_get_struct_layout                                          \
+    not used any more
+#define _cffi_restore_errno                                              \
+    ((void(*)(void))_cffi_exports[13])
+#define _cffi_save_errno                                                 \
+    ((void(*)(void))_cffi_exports[14])
+#define _cffi_from_c_char                                                \
+    ((PyObject *(*)(char))_cffi_exports[15])
+#define _cffi_from_c_deref                                               \
+    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
+#define _cffi_to_c                                                       \
+    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
+#define _cffi_from_c_struct                                              \
+    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
+#define _cffi_to_c_wchar_t                                               \
+    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
+#define _cffi_from_c_wchar_t                                             \
+    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
+#define _cffi_to_c_long_double                                           \
+    ((long double(*)(PyObject *))_cffi_exports[21])
+#define _cffi_to_c__Bool                                                 \
+    ((_Bool(*)(PyObject *))_cffi_exports[22])
+#define _cffi_prepare_pointer_call_argument                              \
+    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
+                    PyObject *, char **))_cffi_exports[23])
+#define _cffi_convert_array_from_object                                  \
+    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
+#define _CFFI_CPIDX  25
+#define _cffi_call_python                                                \
+    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
+#define _cffi_to_c_wchar3216_t                                           \
+    ((int(*)(PyObject *))_cffi_exports[26])
+#define _cffi_from_c_wchar3216_t                                         \
+    ((PyObject *(*)(int))_cffi_exports[27])
+#define _CFFI_NUM_EXPORTS 28
+
+struct _cffi_ctypedescr;
+
+static void *_cffi_exports[_CFFI_NUM_EXPORTS];
+
+#define _cffi_type(index)   (                           \
+    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
+    (struct _cffi_ctypedescr *)_cffi_types[index])
+
+static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
+                            const struct _cffi_type_context_s *ctx)
+{
+    PyObject *module, *o_arg, *new_module;
+    void *raw[] = {
+        (void *)module_name,
+        (void *)version,
+        (void *)_cffi_exports,
+        (void *)ctx,
+    };
+
+    module = PyImport_ImportModule("_cffi_backend");
+    if (module == NULL)
+        goto failure;
+
+    o_arg = PyLong_FromVoidPtr((void *)raw);
+    if (o_arg == NULL)
+        goto failure;
+
+    new_module = PyObject_CallMethod(
+        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);
+
+    Py_DECREF(o_arg);
+    Py_DECREF(module);
+    return new_module;
+
+  failure:
+    Py_XDECREF(module);
+    return NULL;
+}
+
+
+#ifdef HAVE_WCHAR_H
+typedef wchar_t _cffi_wchar_t;
+#else
+typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
+#endif
+
+_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
+{
+    if (sizeof(_cffi_wchar_t) == 2)
+        return (uint16_t)_cffi_to_c_wchar_t(o);
+    else
+        return (uint16_t)_cffi_to_c_wchar3216_t(o);
+}
+
+_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
+{
+    if (sizeof(_cffi_wchar_t) == 2)
+        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
+    else
+        return _cffi_from_c_wchar3216_t((int)x);
+}
+
+_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
+{
+    if (sizeof(_cffi_wchar_t) == 4)
+        return (int)_cffi_to_c_wchar_t(o);
+    else
+        return (int)_cffi_to_c_wchar3216_t(o);
+}
+
+_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(unsigned int x)
+{
+    if (sizeof(_cffi_wchar_t) == 4)
+        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
+    else
+        return _cffi_from_c_wchar3216_t((int)x);
+}
+
+union _cffi_union_alignment_u {
+    unsigned char m_char;
+    unsigned short m_short;
+    unsigned int m_int;
+    unsigned long m_long;
+    unsigned long long m_longlong;
+    float m_float;
+    double m_double;
+    long double m_longdouble;
+};
+
+struct _cffi_freeme_s {
+    struct _cffi_freeme_s *next;
+    union _cffi_union_alignment_u alignment;
+};
+
+_CFFI_UNUSED_FN static int
+_cffi_convert_array_argument(struct _cffi_ctypedescr *ctptr, PyObject *arg,
+                             char **output_data, Py_ssize_t datasize,
+                             struct _cffi_freeme_s **freeme)
+{
+    char *p;
+    if (datasize < 0)
+        return -1;
+
+    p = *output_data;
+    if (p == NULL) {
+        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
+            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
+        if (fp == NULL)
+            return -1;
+        fp->next = *freeme;
+        *freeme = fp;
+        p = *output_data = (char *)&fp->alignment;
+    }
+    memset((void *)p, 0, (size_t)datasize);
+    return _cffi_convert_array_from_object(p, ctptr, arg);
+}
+
+_CFFI_UNUSED_FN static void
+_cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
+{
+    do {
+        void *p = (void *)freeme;
+        freeme = freeme->next;
+        PyObject_Free(p);
+    } while (freeme != NULL);
+}
+
+/**********  end CPython-specific section  **********/
+#else
+_CFFI_UNUSED_FN
+static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
+# define _cffi_call_python  _cffi_call_python_org
+#endif
+
+
+#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))
+
+#define _cffi_prim_int(size, sign)                                      \
+    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
+     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
+     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
+     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
+     _CFFI__UNKNOWN_PRIM)
+
+#define _cffi_prim_float(size)                                          \
+    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
+     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
+     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
+     _CFFI__UNKNOWN_FLOAT_PRIM)
+
+#define _cffi_check_int(got, got_nonpos, expected)      \
+    ((got_nonpos) == (expected <= 0) &&                 \
+     (got) == (unsigned long long)expected)
+
+#ifdef MS_WIN32
+# define _cffi_stdcall  __stdcall
+#else
+# define _cffi_stdcall  /* nothing */
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/************************************************************/
+
+#include <SuiteSparseQR_C.h>
+
+
+/************************************************************/
+
+static void *_cffi_types[] = {
+/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // SuiteSparse_long()(int, double, SuiteSparse_long, cholmod_sparse *, cholmod_sparse * *, cholmod_sparse * *, SuiteSparse_long * *, cholmod_common *)
+/*  1 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
+/*  2 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
+/*  3 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, _cffi_prim_int(sizeof(SuiteSparse_long), (
+           ((SuiteSparse_long)-1) | 0 /* check that SuiteSparse_long is an integer type */
+         ) <= 0)), // SuiteSparse_long
+/*  4 */ _CFFI_OP(_CFFI_OP_POINTER, 99), // cholmod_sparse *
+/*  5 */ _CFFI_OP(_CFFI_OP_POINTER, 4), // cholmod_sparse * *
+/*  6 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
+/*  7 */ _CFFI_OP(_CFFI_OP_POINTER, 95), // SuiteSparse_long * *
+/*  8 */ _CFFI_OP(_CFFI_OP_POINTER, 97), // cholmod_common *
+/*  9 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // SuiteSparse_long()(int, double, SuiteSparse_long, int, cholmod_sparse *, cholmod_sparse *, cholmod_dense *, cholmod_sparse * *, cholmod_dense * *, cholmod_sparse * *, SuiteSparse_long * *, cholmod_sparse * *, SuiteSparse_long * *, cholmod_dense * *, cholmod_common *)
+/* 11 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 12 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
+/* 13 */ _CFFI_OP(_CFFI_OP_NOOP, 3),
+/* 14 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 15 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
+/* 16 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
+/* 17 */ _CFFI_OP(_CFFI_OP_POINTER, 98), // cholmod_dense *
+/* 18 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
+/* 19 */ _CFFI_OP(_CFFI_OP_POINTER, 17), // cholmod_dense * *
+/* 20 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
+/* 21 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
+/* 22 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
+/* 23 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
+/* 24 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
+/* 25 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 27 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // cholmod_dense *()(int, double, cholmod_sparse *, cholmod_dense *, cholmod_common *)
+/* 28 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 29 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
+/* 30 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
+/* 31 */ _CFFI_OP(_CFFI_OP_NOOP, 17),
+/* 32 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 33 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 34 */ _CFFI_OP(_CFFI_OP_FUNCTION, 17), // cholmod_dense *()(size_t, size_t, size_t, int, cholmod_common *)
+/* 35 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
+/* 36 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 37 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 38 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 39 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 40 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 41 */ _CFFI_OP(_CFFI_OP_FUNCTION, 4), // cholmod_sparse *()(cholmod_triplet *, size_t, cholmod_common *)
+/* 42 */ _CFFI_OP(_CFFI_OP_POINTER, 100), // cholmod_triplet *
+/* 43 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 44 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 45 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 46 */ _CFFI_OP(_CFFI_OP_FUNCTION, 4), // cholmod_sparse *()(int, double, cholmod_sparse *, cholmod_sparse *, cholmod_common *)
+/* 47 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 48 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
+/* 49 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
+/* 50 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
+/* 51 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 52 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 53 */ _CFFI_OP(_CFFI_OP_FUNCTION, 42), // cholmod_triplet *()(cholmod_sparse *, cholmod_common *)
+/* 54 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
+/* 55 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 56 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 57 */ _CFFI_OP(_CFFI_OP_FUNCTION, 42), // cholmod_triplet *()(size_t, size_t, size_t, int, int, cholmod_common *)
+/* 58 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 59 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 60 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 61 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 62 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
+/* 63 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 64 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 65 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(cholmod_common *)
+/* 66 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 67 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 68 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(cholmod_dense * *, cholmod_common *)
+/* 69 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
+/* 70 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 71 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 72 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(cholmod_sparse * *, cholmod_common *)
+/* 73 */ _CFFI_OP(_CFFI_OP_NOOP, 5),
+/* 74 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 75 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 76 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(cholmod_triplet * *, cholmod_common *)
+/* 77 */ _CFFI_OP(_CFFI_OP_POINTER, 42), // cholmod_triplet * *
+/* 78 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 79 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 80 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(cholmod_triplet *, char const *, cholmod_common *)
+/* 81 */ _CFFI_OP(_CFFI_OP_NOOP, 42),
+/* 82 */ _CFFI_OP(_CFFI_OP_POINTER, 96), // char const *
+/* 83 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 84 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 85 */ _CFFI_OP(_CFFI_OP_FUNCTION, 1), // int()(cholmod_triplet *, cholmod_common *)
+/* 86 */ _CFFI_OP(_CFFI_OP_NOOP, 42),
+/* 87 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 88 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 89 */ _CFFI_OP(_CFFI_OP_FUNCTION, 92), // void *()(size_t, size_t, void *, cholmod_common *)
+/* 90 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 91 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
+/* 92 */ _CFFI_OP(_CFFI_OP_POINTER, 101), // void *
+/* 93 */ _CFFI_OP(_CFFI_OP_NOOP, 8),
+/* 94 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
+/* 95 */ _CFFI_OP(_CFFI_OP_POINTER, 3), // SuiteSparse_long *
+/* 96 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
+/* 97 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // cholmod_common
+/* 98 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // cholmod_dense
+/* 99 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // cholmod_sparse
+/* 100 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // cholmod_triplet
+/* 101 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
+};
+
+static SuiteSparse_long _cffi_d_SuiteSparseQR_C(int x0, double x1, SuiteSparse_long x2, int x3, cholmod_sparse * x4, cholmod_sparse * x5, cholmod_dense * x6, cholmod_sparse * * x7, cholmod_dense * * x8, cholmod_sparse * * x9, SuiteSparse_long * * x10, cholmod_sparse * * x11, SuiteSparse_long * * x12, cholmod_dense * * x13, cholmod_common * x14)
+{
+  return SuiteSparseQR_C(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_SuiteSparseQR_C(PyObject *self, PyObject *args)
+{
+  int x0;
+  double x1;
+  SuiteSparse_long x2;
+  int x3;
+  cholmod_sparse * x4;
+  cholmod_sparse * x5;
+  cholmod_dense * x6;
+  cholmod_sparse * * x7;
+  cholmod_dense * * x8;
+  cholmod_sparse * * x9;
+  SuiteSparse_long * * x10;
+  cholmod_sparse * * x11;
+  SuiteSparse_long * * x12;
+  cholmod_dense * * x13;
+  cholmod_common * x14;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  SuiteSparse_long result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+  PyObject *arg4;
+  PyObject *arg5;
+  PyObject *arg6;
+  PyObject *arg7;
+  PyObject *arg8;
+  PyObject *arg9;
+  PyObject *arg10;
+  PyObject *arg11;
+  PyObject *arg12;
+  PyObject *arg13;
+  PyObject *arg14;
+
+  if (!PyArg_UnpackTuple(args, "SuiteSparseQR_C", 15, 15, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12, &arg13, &arg14))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, int);
+  if (x0 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = (double)_cffi_to_c_double(arg1);
+  if (x1 == (double)-1 && PyErr_Occurred())
+    return NULL;
+
+  x2 = _cffi_to_c_int(arg2, SuiteSparse_long);
+  if (x2 == (SuiteSparse_long)-1 && PyErr_Occurred())
+    return NULL;
+
+  x3 = _cffi_to_c_int(arg3, int);
+  if (x3 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg4, (char **)&x4);
+  if (datasize != 0) {
+    x4 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg4, (char **)&x4,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg5, (char **)&x5);
+  if (datasize != 0) {
+    x5 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg5, (char **)&x5,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(17), arg6, (char **)&x6);
+  if (datasize != 0) {
+    x6 = ((size_t)datasize) <= 640 ? (cholmod_dense *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(17), arg6, (char **)&x6,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(5), arg7, (char **)&x7);
+  if (datasize != 0) {
+    x7 = ((size_t)datasize) <= 640 ? (cholmod_sparse * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(5), arg7, (char **)&x7,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(19), arg8, (char **)&x8);
+  if (datasize != 0) {
+    x8 = ((size_t)datasize) <= 640 ? (cholmod_dense * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(19), arg8, (char **)&x8,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(5), arg9, (char **)&x9);
+  if (datasize != 0) {
+    x9 = ((size_t)datasize) <= 640 ? (cholmod_sparse * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(5), arg9, (char **)&x9,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(7), arg10, (char **)&x10);
+  if (datasize != 0) {
+    x10 = ((size_t)datasize) <= 640 ? (SuiteSparse_long * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(7), arg10, (char **)&x10,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(5), arg11, (char **)&x11);
+  if (datasize != 0) {
+    x11 = ((size_t)datasize) <= 640 ? (cholmod_sparse * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(5), arg11, (char **)&x11,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(7), arg12, (char **)&x12);
+  if (datasize != 0) {
+    x12 = ((size_t)datasize) <= 640 ? (SuiteSparse_long * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(7), arg12, (char **)&x12,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(19), arg13, (char **)&x13);
+  if (datasize != 0) {
+    x13 = ((size_t)datasize) <= 640 ? (cholmod_dense * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(19), arg13, (char **)&x13,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg14, (char **)&x14);
+  if (datasize != 0) {
+    x14 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg14, (char **)&x14,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = SuiteSparseQR_C(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, SuiteSparse_long);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_SuiteSparseQR_C _cffi_d_SuiteSparseQR_C
+#endif
+
+static SuiteSparse_long _cffi_d_SuiteSparseQR_C_QR(int x0, double x1, SuiteSparse_long x2, cholmod_sparse * x3, cholmod_sparse * * x4, cholmod_sparse * * x5, SuiteSparse_long * * x6, cholmod_common * x7)
+{
+  return SuiteSparseQR_C_QR(x0, x1, x2, x3, x4, x5, x6, x7);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_SuiteSparseQR_C_QR(PyObject *self, PyObject *args)
+{
+  int x0;
+  double x1;
+  SuiteSparse_long x2;
+  cholmod_sparse * x3;
+  cholmod_sparse * * x4;
+  cholmod_sparse * * x5;
+  SuiteSparse_long * * x6;
+  cholmod_common * x7;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  SuiteSparse_long result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+  PyObject *arg4;
+  PyObject *arg5;
+  PyObject *arg6;
+  PyObject *arg7;
+
+  if (!PyArg_UnpackTuple(args, "SuiteSparseQR_C_QR", 8, 8, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, int);
+  if (x0 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = (double)_cffi_to_c_double(arg1);
+  if (x1 == (double)-1 && PyErr_Occurred())
+    return NULL;
+
+  x2 = _cffi_to_c_int(arg2, SuiteSparse_long);
+  if (x2 == (SuiteSparse_long)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg3, (char **)&x3);
+  if (datasize != 0) {
+    x3 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg3, (char **)&x3,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(5), arg4, (char **)&x4);
+  if (datasize != 0) {
+    x4 = ((size_t)datasize) <= 640 ? (cholmod_sparse * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(5), arg4, (char **)&x4,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(5), arg5, (char **)&x5);
+  if (datasize != 0) {
+    x5 = ((size_t)datasize) <= 640 ? (cholmod_sparse * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(5), arg5, (char **)&x5,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(7), arg6, (char **)&x6);
+  if (datasize != 0) {
+    x6 = ((size_t)datasize) <= 640 ? (SuiteSparse_long * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(7), arg6, (char **)&x6,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg7, (char **)&x7);
+  if (datasize != 0) {
+    x7 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg7, (char **)&x7,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = SuiteSparseQR_C_QR(x0, x1, x2, x3, x4, x5, x6, x7); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, SuiteSparse_long);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_SuiteSparseQR_C_QR _cffi_d_SuiteSparseQR_C_QR
+#endif
+
+static cholmod_dense * _cffi_d_SuiteSparseQR_C_backslash(int x0, double x1, cholmod_sparse * x2, cholmod_dense * x3, cholmod_common * x4)
+{
+  return SuiteSparseQR_C_backslash(x0, x1, x2, x3, x4);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_SuiteSparseQR_C_backslash(PyObject *self, PyObject *args)
+{
+  int x0;
+  double x1;
+  cholmod_sparse * x2;
+  cholmod_dense * x3;
+  cholmod_common * x4;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  cholmod_dense * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+  PyObject *arg4;
+
+  if (!PyArg_UnpackTuple(args, "SuiteSparseQR_C_backslash", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, int);
+  if (x0 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = (double)_cffi_to_c_double(arg1);
+  if (x1 == (double)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg2, (char **)&x2);
+  if (datasize != 0) {
+    x2 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg2, (char **)&x2,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(17), arg3, (char **)&x3);
+  if (datasize != 0) {
+    x3 = ((size_t)datasize) <= 640 ? (cholmod_dense *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(17), arg3, (char **)&x3,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg4, (char **)&x4);
+  if (datasize != 0) {
+    x4 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg4, (char **)&x4,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = SuiteSparseQR_C_backslash(x0, x1, x2, x3, x4); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(17));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_SuiteSparseQR_C_backslash _cffi_d_SuiteSparseQR_C_backslash
+#endif
+
+static cholmod_sparse * _cffi_d_SuiteSparseQR_C_backslash_sparse(int x0, double x1, cholmod_sparse * x2, cholmod_sparse * x3, cholmod_common * x4)
+{
+  return SuiteSparseQR_C_backslash_sparse(x0, x1, x2, x3, x4);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_SuiteSparseQR_C_backslash_sparse(PyObject *self, PyObject *args)
+{
+  int x0;
+  double x1;
+  cholmod_sparse * x2;
+  cholmod_sparse * x3;
+  cholmod_common * x4;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  cholmod_sparse * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+  PyObject *arg4;
+
+  if (!PyArg_UnpackTuple(args, "SuiteSparseQR_C_backslash_sparse", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, int);
+  if (x0 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = (double)_cffi_to_c_double(arg1);
+  if (x1 == (double)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg2, (char **)&x2);
+  if (datasize != 0) {
+    x2 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg2, (char **)&x2,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg3, (char **)&x3);
+  if (datasize != 0) {
+    x3 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg3, (char **)&x3,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg4, (char **)&x4);
+  if (datasize != 0) {
+    x4 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg4, (char **)&x4,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = SuiteSparseQR_C_backslash_sparse(x0, x1, x2, x3, x4); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(4));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_SuiteSparseQR_C_backslash_sparse _cffi_d_SuiteSparseQR_C_backslash_sparse
+#endif
+
+static cholmod_dense * _cffi_d_cholmod_l_allocate_dense(size_t x0, size_t x1, size_t x2, int x3, cholmod_common * x4)
+{
+  return cholmod_l_allocate_dense(x0, x1, x2, x3, x4);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_allocate_dense(PyObject *self, PyObject *args)
+{
+  size_t x0;
+  size_t x1;
+  size_t x2;
+  int x3;
+  cholmod_common * x4;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  cholmod_dense * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+  PyObject *arg4;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_allocate_dense", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, size_t);
+  if (x0 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = _cffi_to_c_int(arg1, size_t);
+  if (x1 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x2 = _cffi_to_c_int(arg2, size_t);
+  if (x2 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x3 = _cffi_to_c_int(arg3, int);
+  if (x3 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg4, (char **)&x4);
+  if (datasize != 0) {
+    x4 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg4, (char **)&x4,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_allocate_dense(x0, x1, x2, x3, x4); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(17));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_allocate_dense _cffi_d_cholmod_l_allocate_dense
+#endif
+
+static cholmod_triplet * _cffi_d_cholmod_l_allocate_triplet(size_t x0, size_t x1, size_t x2, int x3, int x4, cholmod_common * x5)
+{
+  return cholmod_l_allocate_triplet(x0, x1, x2, x3, x4, x5);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_allocate_triplet(PyObject *self, PyObject *args)
+{
+  size_t x0;
+  size_t x1;
+  size_t x2;
+  int x3;
+  int x4;
+  cholmod_common * x5;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  cholmod_triplet * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+  PyObject *arg4;
+  PyObject *arg5;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_allocate_triplet", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, size_t);
+  if (x0 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = _cffi_to_c_int(arg1, size_t);
+  if (x1 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x2 = _cffi_to_c_int(arg2, size_t);
+  if (x2 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x3 = _cffi_to_c_int(arg3, int);
+  if (x3 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  x4 = _cffi_to_c_int(arg4, int);
+  if (x4 == (int)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg5, (char **)&x5);
+  if (datasize != 0) {
+    x5 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg5, (char **)&x5,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_allocate_triplet(x0, x1, x2, x3, x4, x5); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(42));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_allocate_triplet _cffi_d_cholmod_l_allocate_triplet
+#endif
+
+static int _cffi_d_cholmod_l_check_triplet(cholmod_triplet * x0, cholmod_common * x1)
+{
+  return cholmod_l_check_triplet(x0, x1);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_check_triplet(PyObject *self, PyObject *args)
+{
+  cholmod_triplet * x0;
+  cholmod_common * x1;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_check_triplet", 2, 2, &arg0, &arg1))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(42), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_triplet *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(42), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg1, (char **)&x1);
+  if (datasize != 0) {
+    x1 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg1, (char **)&x1,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_check_triplet(x0, x1); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_check_triplet _cffi_d_cholmod_l_check_triplet
+#endif
+
+static int _cffi_d_cholmod_l_finish(cholmod_common * x0)
+{
+  return cholmod_l_finish(x0);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_finish(PyObject *self, PyObject *arg0)
+{
+  cholmod_common * x0;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_finish(x0); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_finish _cffi_d_cholmod_l_finish
+#endif
+
+static void * _cffi_d_cholmod_l_free(size_t x0, size_t x1, void * x2, cholmod_common * x3)
+{
+  return cholmod_l_free(x0, x1, x2, x3);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_free(PyObject *self, PyObject *args)
+{
+  size_t x0;
+  size_t x1;
+  void * x2;
+  cholmod_common * x3;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  void * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+  PyObject *arg3;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_free", 4, 4, &arg0, &arg1, &arg2, &arg3))
+    return NULL;
+
+  x0 = _cffi_to_c_int(arg0, size_t);
+  if (x0 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  x1 = _cffi_to_c_int(arg1, size_t);
+  if (x1 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(92), arg2, (char **)&x2);
+  if (datasize != 0) {
+    x2 = ((size_t)datasize) <= 640 ? (void *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(92), arg2, (char **)&x2,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg3, (char **)&x3);
+  if (datasize != 0) {
+    x3 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg3, (char **)&x3,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_free(x0, x1, x2, x3); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(92));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_free _cffi_d_cholmod_l_free
+#endif
+
+static int _cffi_d_cholmod_l_free_dense(cholmod_dense * * x0, cholmod_common * x1)
+{
+  return cholmod_l_free_dense(x0, x1);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_free_dense(PyObject *self, PyObject *args)
+{
+  cholmod_dense * * x0;
+  cholmod_common * x1;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_free_dense", 2, 2, &arg0, &arg1))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(19), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_dense * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(19), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg1, (char **)&x1);
+  if (datasize != 0) {
+    x1 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg1, (char **)&x1,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_free_dense(x0, x1); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_free_dense _cffi_d_cholmod_l_free_dense
+#endif
+
+static int _cffi_d_cholmod_l_free_sparse(cholmod_sparse * * x0, cholmod_common * x1)
+{
+  return cholmod_l_free_sparse(x0, x1);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_free_sparse(PyObject *self, PyObject *args)
+{
+  cholmod_sparse * * x0;
+  cholmod_common * x1;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_free_sparse", 2, 2, &arg0, &arg1))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(5), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_sparse * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(5), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg1, (char **)&x1);
+  if (datasize != 0) {
+    x1 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg1, (char **)&x1,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_free_sparse(x0, x1); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_free_sparse _cffi_d_cholmod_l_free_sparse
+#endif
+
+static int _cffi_d_cholmod_l_free_triplet(cholmod_triplet * * x0, cholmod_common * x1)
+{
+  return cholmod_l_free_triplet(x0, x1);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_free_triplet(PyObject *self, PyObject *args)
+{
+  cholmod_triplet * * x0;
+  cholmod_common * x1;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_free_triplet", 2, 2, &arg0, &arg1))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(77), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_triplet * *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(77), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg1, (char **)&x1);
+  if (datasize != 0) {
+    x1 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg1, (char **)&x1,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_free_triplet(x0, x1); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_free_triplet _cffi_d_cholmod_l_free_triplet
+#endif
+
+static int _cffi_d_cholmod_l_print_triplet(cholmod_triplet * x0, char const * x1, cholmod_common * x2)
+{
+  return cholmod_l_print_triplet(x0, x1, x2);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_print_triplet(PyObject *self, PyObject *args)
+{
+  cholmod_triplet * x0;
+  char const * x1;
+  cholmod_common * x2;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_print_triplet", 3, 3, &arg0, &arg1, &arg2))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(42), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_triplet *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(42), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(82), arg1, (char **)&x1);
+  if (datasize != 0) {
+    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(82), arg1, (char **)&x1,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg2, (char **)&x2);
+  if (datasize != 0) {
+    x2 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg2, (char **)&x2,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_print_triplet(x0, x1, x2); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_print_triplet _cffi_d_cholmod_l_print_triplet
+#endif
+
+static cholmod_triplet * _cffi_d_cholmod_l_sparse_to_triplet(cholmod_sparse * x0, cholmod_common * x1)
+{
+  return cholmod_l_sparse_to_triplet(x0, x1);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_sparse_to_triplet(PyObject *self, PyObject *args)
+{
+  cholmod_sparse * x0;
+  cholmod_common * x1;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  cholmod_triplet * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_sparse_to_triplet", 2, 2, &arg0, &arg1))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(4), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_sparse *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(4), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg1, (char **)&x1);
+  if (datasize != 0) {
+    x1 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg1, (char **)&x1,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_sparse_to_triplet(x0, x1); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(42));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_sparse_to_triplet _cffi_d_cholmod_l_sparse_to_triplet
+#endif
+
+static int _cffi_d_cholmod_l_start(cholmod_common * x0)
+{
+  return cholmod_l_start(x0);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_start(PyObject *self, PyObject *arg0)
+{
+  cholmod_common * x0;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  int result;
+  PyObject *pyresult;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_start(x0); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_int(result, int);
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_start _cffi_d_cholmod_l_start
+#endif
+
+static cholmod_sparse * _cffi_d_cholmod_l_triplet_to_sparse(cholmod_triplet * x0, size_t x1, cholmod_common * x2)
+{
+  return cholmod_l_triplet_to_sparse(x0, x1, x2);
+}
+#ifndef PYPY_VERSION
+static PyObject *
+_cffi_f_cholmod_l_triplet_to_sparse(PyObject *self, PyObject *args)
+{
+  cholmod_triplet * x0;
+  size_t x1;
+  cholmod_common * x2;
+  Py_ssize_t datasize;
+  struct _cffi_freeme_s *large_args_free = NULL;
+  cholmod_sparse * result;
+  PyObject *pyresult;
+  PyObject *arg0;
+  PyObject *arg1;
+  PyObject *arg2;
+
+  if (!PyArg_UnpackTuple(args, "cholmod_l_triplet_to_sparse", 3, 3, &arg0, &arg1, &arg2))
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(42), arg0, (char **)&x0);
+  if (datasize != 0) {
+    x0 = ((size_t)datasize) <= 640 ? (cholmod_triplet *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(42), arg0, (char **)&x0,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  x1 = _cffi_to_c_int(arg1, size_t);
+  if (x1 == (size_t)-1 && PyErr_Occurred())
+    return NULL;
+
+  datasize = _cffi_prepare_pointer_call_argument(
+      _cffi_type(8), arg2, (char **)&x2);
+  if (datasize != 0) {
+    x2 = ((size_t)datasize) <= 640 ? (cholmod_common *)alloca((size_t)datasize) : NULL;
+    if (_cffi_convert_array_argument(_cffi_type(8), arg2, (char **)&x2,
+            datasize, &large_args_free) < 0)
+      return NULL;
+  }
+
+  Py_BEGIN_ALLOW_THREADS
+  _cffi_restore_errno();
+  { result = cholmod_l_triplet_to_sparse(x0, x1, x2); }
+  _cffi_save_errno();
+  Py_END_ALLOW_THREADS
+
+  (void)self; /* unused */
+  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(4));
+  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
+  return pyresult;
+}
+#else
+#  define _cffi_f_cholmod_l_triplet_to_sparse _cffi_d_cholmod_l_triplet_to_sparse
+#endif
+
+static int _cffi_const_CHOLMOD_COMPLEX(unsigned long long *o)
+{
+  int n = (CHOLMOD_COMPLEX) <= 0;
+  *o = (unsigned long long)((CHOLMOD_COMPLEX) | 0);  /* check that CHOLMOD_COMPLEX is an integer */
+  return n;
+}
+
+static int _cffi_const_CHOLMOD_PATTERN(unsigned long long *o)
+{
+  int n = (CHOLMOD_PATTERN) <= 0;
+  *o = (unsigned long long)((CHOLMOD_PATTERN) | 0);  /* check that CHOLMOD_PATTERN is an integer */
+  return n;
+}
+
+static int _cffi_const_CHOLMOD_REAL(unsigned long long *o)
+{
+  int n = (CHOLMOD_REAL) <= 0;
+  *o = (unsigned long long)((CHOLMOD_REAL) | 0);  /* check that CHOLMOD_REAL is an integer */
+  return n;
+}
+
+static int _cffi_const_CHOLMOD_ZOMPLEX(unsigned long long *o)
+{
+  int n = (CHOLMOD_ZOMPLEX) <= 0;
+  *o = (unsigned long long)((CHOLMOD_ZOMPLEX) | 0);  /* check that CHOLMOD_ZOMPLEX is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_DEFAULT_TOL(unsigned long long *o)
+{
+  int n = (SPQR_DEFAULT_TOL) <= 0;
+  *o = (unsigned long long)((SPQR_DEFAULT_TOL) | 0);  /* check that SPQR_DEFAULT_TOL is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_NO_TOL(unsigned long long *o)
+{
+  int n = (SPQR_NO_TOL) <= 0;
+  *o = (unsigned long long)((SPQR_NO_TOL) | 0);  /* check that SPQR_NO_TOL is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_AMD(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_AMD) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_AMD) | 0);  /* check that SPQR_ORDERING_AMD is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_BEST(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_BEST) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_BEST) | 0);  /* check that SPQR_ORDERING_BEST is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_BESTAMD(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_BESTAMD) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_BESTAMD) | 0);  /* check that SPQR_ORDERING_BESTAMD is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_CHOLMOD(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_CHOLMOD) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_CHOLMOD) | 0);  /* check that SPQR_ORDERING_CHOLMOD is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_COLAMD(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_COLAMD) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_COLAMD) | 0);  /* check that SPQR_ORDERING_COLAMD is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_DEFAULT(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_DEFAULT) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_DEFAULT) | 0);  /* check that SPQR_ORDERING_DEFAULT is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_FIXED(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_FIXED) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_FIXED) | 0);  /* check that SPQR_ORDERING_FIXED is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_GIVEN(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_GIVEN) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_GIVEN) | 0);  /* check that SPQR_ORDERING_GIVEN is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_METIS(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_METIS) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_METIS) | 0);  /* check that SPQR_ORDERING_METIS is an integer */
+  return n;
+}
+
+static int _cffi_const_SPQR_ORDERING_NATURAL(unsigned long long *o)
+{
+  int n = (SPQR_ORDERING_NATURAL) <= 0;
+  *o = (unsigned long long)((SPQR_ORDERING_NATURAL) | 0);  /* check that SPQR_ORDERING_NATURAL is an integer */
+  return n;
+}
+
+_CFFI_UNUSED_FN
+static void _cffi_checkfld__cholmod_common(cholmod_common *p)
+{
+  /* only to generate compile-time warnings or errors */
+  (void)p;
+}
+struct _cffi_align__cholmod_common { char x; cholmod_common y; };
+
+_CFFI_UNUSED_FN
+static void _cffi_checkfld__cholmod_dense(cholmod_dense *p)
+{
+  /* only to generate compile-time warnings or errors */
+  (void)p;
+  (void)((p->nrow) | 0);  /* check that 'cholmod_dense.nrow' is an integer */
+  (void)((p->ncol) | 0);  /* check that 'cholmod_dense.ncol' is an integer */
+  (void)((p->nzmax) | 0);  /* check that 'cholmod_dense.nzmax' is an integer */
+  (void)((p->d) | 0);  /* check that 'cholmod_dense.d' is an integer */
+  { void * *tmp = &p->x; (void)tmp; }
+  { void * *tmp = &p->z; (void)tmp; }
+  (void)((p->xtype) | 0);  /* check that 'cholmod_dense.xtype' is an integer */
+  (void)((p->dtype) | 0);  /* check that 'cholmod_dense.dtype' is an integer */
+}
+struct _cffi_align__cholmod_dense { char x; cholmod_dense y; };
+
+_CFFI_UNUSED_FN
+static void _cffi_checkfld__cholmod_triplet(cholmod_triplet *p)
+{
+  /* only to generate compile-time warnings or errors */
+  (void)p;
+  (void)((p->nrow) | 0);  /* check that 'cholmod_triplet.nrow' is an integer */
+  (void)((p->ncol) | 0);  /* check that 'cholmod_triplet.ncol' is an integer */
+  (void)((p->nzmax) | 0);  /* check that 'cholmod_triplet.nzmax' is an integer */
+  (void)((p->nnz) | 0);  /* check that 'cholmod_triplet.nnz' is an integer */
+  { void * *tmp = &p->i; (void)tmp; }
+  { void * *tmp = &p->j; (void)tmp; }
+  { void * *tmp = &p->x; (void)tmp; }
+  { void * *tmp = &p->z; (void)tmp; }
+  (void)((p->stype) | 0);  /* check that 'cholmod_triplet.stype' is an integer */
+  (void)((p->itype) | 0);  /* check that 'cholmod_triplet.itype' is an integer */
+  (void)((p->xtype) | 0);  /* check that 'cholmod_triplet.xtype' is an integer */
+  (void)((p->dtype) | 0);  /* check that 'cholmod_triplet.dtype' is an integer */
+}
+struct _cffi_align__cholmod_triplet { char x; cholmod_triplet y; };
+
+static const struct _cffi_global_s _cffi_globals[] = {
+  { "CHOLMOD_COMPLEX", (void *)_cffi_const_CHOLMOD_COMPLEX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "CHOLMOD_PATTERN", (void *)_cffi_const_CHOLMOD_PATTERN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "CHOLMOD_REAL", (void *)_cffi_const_CHOLMOD_REAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "CHOLMOD_ZOMPLEX", (void *)_cffi_const_CHOLMOD_ZOMPLEX, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_DEFAULT_TOL", (void *)_cffi_const_SPQR_DEFAULT_TOL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_NO_TOL", (void *)_cffi_const_SPQR_NO_TOL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_AMD", (void *)_cffi_const_SPQR_ORDERING_AMD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_BEST", (void *)_cffi_const_SPQR_ORDERING_BEST, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_BESTAMD", (void *)_cffi_const_SPQR_ORDERING_BESTAMD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_CHOLMOD", (void *)_cffi_const_SPQR_ORDERING_CHOLMOD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_COLAMD", (void *)_cffi_const_SPQR_ORDERING_COLAMD, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_DEFAULT", (void *)_cffi_const_SPQR_ORDERING_DEFAULT, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_FIXED", (void *)_cffi_const_SPQR_ORDERING_FIXED, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_GIVEN", (void *)_cffi_const_SPQR_ORDERING_GIVEN, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_METIS", (void *)_cffi_const_SPQR_ORDERING_METIS, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SPQR_ORDERING_NATURAL", (void *)_cffi_const_SPQR_ORDERING_NATURAL, _CFFI_OP(_CFFI_OP_CONSTANT_INT, -1), (void *)0 },
+  { "SuiteSparseQR_C", (void *)_cffi_f_SuiteSparseQR_C, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 10), (void *)_cffi_d_SuiteSparseQR_C },
+  { "SuiteSparseQR_C_QR", (void *)_cffi_f_SuiteSparseQR_C_QR, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_SuiteSparseQR_C_QR },
+  { "SuiteSparseQR_C_backslash", (void *)_cffi_f_SuiteSparseQR_C_backslash, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 27), (void *)_cffi_d_SuiteSparseQR_C_backslash },
+  { "SuiteSparseQR_C_backslash_sparse", (void *)_cffi_f_SuiteSparseQR_C_backslash_sparse, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 46), (void *)_cffi_d_SuiteSparseQR_C_backslash_sparse },
+  { "cholmod_l_allocate_dense", (void *)_cffi_f_cholmod_l_allocate_dense, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 34), (void *)_cffi_d_cholmod_l_allocate_dense },
+  { "cholmod_l_allocate_triplet", (void *)_cffi_f_cholmod_l_allocate_triplet, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 57), (void *)_cffi_d_cholmod_l_allocate_triplet },
+  { "cholmod_l_check_triplet", (void *)_cffi_f_cholmod_l_check_triplet, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 85), (void *)_cffi_d_cholmod_l_check_triplet },
+  { "cholmod_l_finish", (void *)_cffi_f_cholmod_l_finish, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 65), (void *)_cffi_d_cholmod_l_finish },
+  { "cholmod_l_free", (void *)_cffi_f_cholmod_l_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 89), (void *)_cffi_d_cholmod_l_free },
+  { "cholmod_l_free_dense", (void *)_cffi_f_cholmod_l_free_dense, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 68), (void *)_cffi_d_cholmod_l_free_dense },
+  { "cholmod_l_free_sparse", (void *)_cffi_f_cholmod_l_free_sparse, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 72), (void *)_cffi_d_cholmod_l_free_sparse },
+  { "cholmod_l_free_triplet", (void *)_cffi_f_cholmod_l_free_triplet, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 76), (void *)_cffi_d_cholmod_l_free_triplet },
+  { "cholmod_l_print_triplet", (void *)_cffi_f_cholmod_l_print_triplet, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 80), (void *)_cffi_d_cholmod_l_print_triplet },
+  { "cholmod_l_sparse_to_triplet", (void *)_cffi_f_cholmod_l_sparse_to_triplet, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 53), (void *)_cffi_d_cholmod_l_sparse_to_triplet },
+  { "cholmod_l_start", (void *)_cffi_f_cholmod_l_start, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 65), (void *)_cffi_d_cholmod_l_start },
+  { "cholmod_l_triplet_to_sparse", (void *)_cffi_f_cholmod_l_triplet_to_sparse, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 41), (void *)_cffi_d_cholmod_l_triplet_to_sparse },
+};
+
+static const struct _cffi_field_s _cffi_fields[] = {
+  { "nrow", offsetof(cholmod_dense, nrow),
+            sizeof(((cholmod_dense *)0)->nrow),
+            _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "ncol", offsetof(cholmod_dense, ncol),
+            sizeof(((cholmod_dense *)0)->ncol),
+            _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "nzmax", offsetof(cholmod_dense, nzmax),
+             sizeof(((cholmod_dense *)0)->nzmax),
+             _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "d", offsetof(cholmod_dense, d),
+         sizeof(((cholmod_dense *)0)->d),
+         _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "x", offsetof(cholmod_dense, x),
+         sizeof(((cholmod_dense *)0)->x),
+         _CFFI_OP(_CFFI_OP_NOOP, 92) },
+  { "z", offsetof(cholmod_dense, z),
+         sizeof(((cholmod_dense *)0)->z),
+         _CFFI_OP(_CFFI_OP_NOOP, 92) },
+  { "xtype", offsetof(cholmod_dense, xtype),
+             sizeof(((cholmod_dense *)0)->xtype),
+             _CFFI_OP(_CFFI_OP_NOOP, 1) },
+  { "dtype", offsetof(cholmod_dense, dtype),
+             sizeof(((cholmod_dense *)0)->dtype),
+             _CFFI_OP(_CFFI_OP_NOOP, 1) },
+  { "nrow", offsetof(cholmod_triplet, nrow),
+            sizeof(((cholmod_triplet *)0)->nrow),
+            _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "ncol", offsetof(cholmod_triplet, ncol),
+            sizeof(((cholmod_triplet *)0)->ncol),
+            _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "nzmax", offsetof(cholmod_triplet, nzmax),
+             sizeof(((cholmod_triplet *)0)->nzmax),
+             _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "nnz", offsetof(cholmod_triplet, nnz),
+           sizeof(((cholmod_triplet *)0)->nnz),
+           _CFFI_OP(_CFFI_OP_NOOP, 35) },
+  { "i", offsetof(cholmod_triplet, i),
+         sizeof(((cholmod_triplet *)0)->i),
+         _CFFI_OP(_CFFI_OP_NOOP, 92) },
+  { "j", offsetof(cholmod_triplet, j),
+         sizeof(((cholmod_triplet *)0)->j),
+         _CFFI_OP(_CFFI_OP_NOOP, 92) },
+  { "x", offsetof(cholmod_triplet, x),
+         sizeof(((cholmod_triplet *)0)->x),
+         _CFFI_OP(_CFFI_OP_NOOP, 92) },
+  { "z", offsetof(cholmod_triplet, z),
+         sizeof(((cholmod_triplet *)0)->z),
+         _CFFI_OP(_CFFI_OP_NOOP, 92) },
+  { "stype", offsetof(cholmod_triplet, stype),
+             sizeof(((cholmod_triplet *)0)->stype),
+             _CFFI_OP(_CFFI_OP_NOOP, 1) },
+  { "itype", offsetof(cholmod_triplet, itype),
+             sizeof(((cholmod_triplet *)0)->itype),
+             _CFFI_OP(_CFFI_OP_NOOP, 1) },
+  { "xtype", offsetof(cholmod_triplet, xtype),
+             sizeof(((cholmod_triplet *)0)->xtype),
+             _CFFI_OP(_CFFI_OP_NOOP, 1) },
+  { "dtype", offsetof(cholmod_triplet, dtype),
+             sizeof(((cholmod_triplet *)0)->dtype),
+             _CFFI_OP(_CFFI_OP_NOOP, 1) },
+};
+
+static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
+  { "$cholmod_sparse", 99, _CFFI_F_OPAQUE,
+    (size_t)-1, -1, -1, 0 /* opaque */ },
+  { "cholmod_common", 97, 0,
+    sizeof(cholmod_common), offsetof(struct _cffi_align__cholmod_common, y), 0, 0 },
+  { "cholmod_dense_struct", 98, _CFFI_F_CHECK_FIELDS,
+    sizeof(cholmod_dense), offsetof(struct _cffi_align__cholmod_dense, y), 0, 8 },
+  { "cholmod_triplet_struct", 100, _CFFI_F_CHECK_FIELDS,
+    sizeof(cholmod_triplet), offsetof(struct _cffi_align__cholmod_triplet, y), 8, 12 },
+};
+
+static const struct _cffi_typename_s _cffi_typenames[] = {
+  { "SuiteSparse_long", 3 },
+  { "cholmod_common", 97 },
+  { "cholmod_dense", 98 },
+  { "cholmod_sparse", 99 },
+  { "cholmod_triplet", 100 },
+};
+
+static const struct _cffi_type_context_s _cffi_type_context = {
+  _cffi_types,
+  _cffi_globals,
+  _cffi_fields,
+  _cffi_struct_unions,
+  NULL,  /* no enums */
+  _cffi_typenames,
+  32,  /* num_globals */
+  4,  /* num_struct_unions */
+  0,  /* num_enums */
+  5,  /* num_typenames */
+  NULL,  /* no includes */
+  102,  /* num_types */
+  0,  /* flags */
+};
+
+#ifdef __GNUC__
+#  pragma GCC visibility push(default)  /* for -fvisibility= */
+#endif
+
+#ifdef PYPY_VERSION
+PyMODINIT_FUNC
+_cffi_pypyinit__sparseqr(const void *p[])
+{
+    p[0] = (const void *)0x2601;
+    p[1] = &_cffi_type_context;
+#if PY_MAJOR_VERSION >= 3
+    return NULL;
+#endif
+}
+#  ifdef _MSC_VER
+     PyMODINIT_FUNC
+#  if PY_MAJOR_VERSION >= 3
+     PyInit__sparseqr(void) { return NULL; }
+#  else
+     init_sparseqr(void) { }
+#  endif
+#  endif
+#elif PY_MAJOR_VERSION >= 3
+PyMODINIT_FUNC
+PyInit__sparseqr(void)
+{
+  return _cffi_init("sparseqr._sparseqr", 0x2601, &_cffi_type_context);
+}
+#else
+PyMODINIT_FUNC
+init_sparseqr(void)
+{
+  _cffi_init("sparseqr._sparseqr", 0x2601, &_cffi_type_context);
+}
+#endif
+
+#ifdef __GNUC__
+#  pragma GCC visibility pop
+#endif
diff --git a/sparseqr/sparseqr_gen.py b/sparseqr/sparseqr_gen.py
index 45a0029..fad396b 100644
--- a/sparseqr/sparseqr_gen.py
+++ b/sparseqr/sparseqr_gen.py
@@ -11,8 +11,8 @@ import platform
 
 from cffi import FFI
 
+'''
 include_dirs = [ '/usr/include/suitesparse', join('C:', 'Program Files', 'Python', 'suitesparse') ]
-libraries = ['spqr']
 
 # for compatibility with conda envs
 if 'CONDA_DEFAULT_ENV' in os.environ:
@@ -24,16 +24,27 @@ if platform.system() == 'Windows':
     # https://github.com/yig/PySPQR/issues/6
     libraries.extend( ['amd','btf','camd','ccolamd','cholmod','colamd','cxsparse'
 'klu','lapack','ldl','lumfpack','metis','suitesparseconfig','libblas'] )
+'''
+
+__PACKAGE_ROOT__ = os.path.abspath(os.path.join(os.path.dirname(__file__),os.pardir,os.pardir,os.pardir,os.pardir))
+
+include_dirs = [os.path.join(__PACKAGE_ROOT__,'suitesparse','dist','include')]
+library_dirs = [os.path.join(__PACKAGE_ROOT__,'suitesparse','dist','lib')]
 
 ffibuilder = FFI()
 
+libraries = ['spqr']
+
+extra_link_args = ['-sSIDE_MODULE=1']
+
 ffibuilder.set_source( "sparseqr._sparseqr",
     """#include <SuiteSparseQR_C.h>
 """,
-    ## You may need to modify the following line,
-    ## which is needed on Ubuntu and harmless on Mac OS.
     include_dirs = include_dirs,
-    libraries = libraries )
+    library_dirs = library_dirs,
+    libraries = libraries,
+    extra_link_args = extra_link_args,
+    )
 
 ffibuilder.cdef("""
 // The int... is a magic thing which tells the compiler to figure out what the right
@@ -370,6 +381,7 @@ def main():
     ## Two dirnames because ffibuilder.set_source()
     ## passes the module name: "sparseqr._sparseqr"
     ffibuilder.compile( verbose = True, tmpdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) )
+    
 
 if __name__ == "__main__":
     main()
-- 
2.25.1

