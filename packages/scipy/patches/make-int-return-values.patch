The return values of f2c functions are insignificant in most cases, so often it
is treated as returning void, when it really should return int (values are
"returned" by writing to pointers passed as an argument, but an obscure feature
known as alternative returns can cause the return value to be significant).

There's a big change to scipy/linalg/_cython_wrapper_generators.py, which is
called on build to generate python wrappers for lapack and BLAS. The change
makes everything call direct to CLAPACK with the correct function signatures
and also fixes some fortran -> c linking oddities that occur because f2py assumes
different function signatures to f2c, which in turn creates different function 
signatures compared to what has been done in CLAPACK. 

f2py is patched in numpy to make subroutines return int.

emscripten is very strict about void vs int returns and function signatures, so we change everything to
return int from subroutines, and signatures are altered to be consistent.


diff --git a/scipy/_build_utils/_fortran.py b/scipy/_build_utils/_fortran.py
index 93ca908..038855b 100644
--- a/scipy/_build_utils/_fortran.py
+++ b/scipy/_build_utils/_fortran.py
@@ -79,7 +79,6 @@ def get_g77_abi_wrappers(info):
     else:
         wrapper_sources += [
             os.path.join(path, 'src', 'wrap_dummy_g77_abi.f'),
-            os.path.join(path, 'src', 'wrap_dummy_accelerate.f'),
         ]
     return wrapper_sources
 
diff --git a/scipy/cluster/cluster_blas.h b/scipy/cluster/cluster_blas.h
index 865e410..d5479e0 100644
--- a/scipy/cluster/cluster_blas.h
+++ b/scipy/cluster/cluster_blas.h
@@ -15,6 +15,8 @@
 #define F_FUNC(f,F) f##_
 #endif
 #endif
+extern int dgemm_(char *transa, char *transb, int *m, int *n, int *k, double *alpha, double *a, int *lda, double *b, int *ldb, double *beta, double *c, int *ldc);
+extern int sgemm_(char *transa, char *transb, int *m, int *n, int *k, float *alpha, float *a, int *lda, float *b, int *ldb, float *beta, float *c, int *ldc);
 
 #define f_sgemm F_FUNC(sgemm,SGEMM)
 #define f_dgemm F_FUNC(dgemm,DGEMM)
diff --git a/scipy/interpolate/blas_defs.h b/scipy/interpolate/blas_defs.h
index 0f95237..5a7adb7 100644
--- a/scipy/interpolate/blas_defs.h
+++ b/scipy/interpolate/blas_defs.h
@@ -16,4 +16,5 @@
 #endif
 #endif
 
+extern int dgeev_(char *jobvl, char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);
 #define c_dgeev F_FUNC(dgeev,DGEEV)
diff --git a/scipy/linalg/_cython_wrapper_generators.py b/scipy/linalg/_cython_wrapper_generators.py
index 62be001..b62c31a 100644
--- a/scipy/linalg/_cython_wrapper_generators.py
+++ b/scipy/linalg/_cython_wrapper_generators.py
@@ -3,8 +3,13 @@ Code generator script to make the Cython BLAS and LAPACK wrappers
 from the files "cython_blas_signatures.txt" and
 "cython_lapack_signatures.txt" which contain the signatures for
 all the BLAS/LAPACK routines that should be included in the wrappers.
+
+# NB: this version is updated for CLAPACK. It makes the assumption (as does
+# everything else in scipy, that CLAPACK long int is the same size as int )
 """
 
+
+
 from operator import itemgetter
 
 fortran_types = {'int': 'integer',
@@ -15,7 +20,9 @@ fortran_types = {'int': 'integer',
                  'char': 'character',
                  'bint': 'logical'}
 
-c_types = {'int': 'int',
+c_types = {'void':'int',
+        'VOID':'int',
+	   'int': 'int',
            'c': 'npy_complex64',
            'd': 'double',
            's': 'float',
@@ -31,17 +38,29 @@ c_types = {'int': 'int',
            'zselect1': '_zselect1',
            'zselect2': '_zselect2'}
 
+py_type_replacements={'npy_complex64':'float complex',
+                       'npy_complex128':'double complex'}
+
 
 def arg_names_and_types(args):
     return zip(*[arg.split(' *') for arg in args.split(', ')])
 
 pyx_func_template = """
+
 cdef extern from "{header_name}":
-    void _fortran_{name} "F_FUNC({name}wrp, {upname}WRP)"({ret_type} *out, {fort_args}) nogil
-cdef {ret_type} {name}({args}) nogil:
-    cdef {ret_type} out
-    _fortran_{name}(&out, {argnames})
-    return out
+    {c_ret_type} _fortran_{name} "F_FUNC({name}, {upname})"({args}) nogil
+cdef {py_ret_type} {name}({py_args}) nogil:
+    return  _fortran_{name}({argnames})
+"""
+
+# CLAPACK returns complex by pointer
+pyx_func_template_complex = """
+cdef extern from "{header_name}":
+    void _fortran_{name} "F_FUNC({name}, {upname})"({c_ret_type} *ret_val,{args}) nogil
+cdef {py_ret_type} {name}({py_args}) nogil:
+    cdef {py_ret_type} ret_val
+    _fortran_{name}(<{c_ret_type}*>&ret_val,{argnames})
+    return ret_val
 """
 
 npy_types = {'c': 'npy_complex64', 'z': 'npy_complex128',
@@ -50,57 +69,114 @@ npy_types = {'c': 'npy_complex64', 'z': 'npy_complex128',
              'sselect2': '_sselect2', 'sselect3': '_sselect3',
              'zselect1': '_zselect1', 'zselect2': '_zselect2'}
 
+# methods that use char* need a wrapper building,
+# because CLAPACK uses null terminated strings
+# and f2c uses char* + extra length args
+# the wrapper will be called in preprocessing of
+# f2c generated code
+
+def needs_wrapper(argtypes):
+    for c in argtypes:
+        if c=='char':
+            return True
+    return False
 
 def arg_casts(arg):
     if arg in ['npy_complex64', 'npy_complex128', '_cselect1', '_cselect2',
                '_dselect2', '_dselect3', '_sselect2', '_sselect3',
-               '_zselect1', '_zselect2']:
+               '_zselect1', '_zselect2','f2c_complex','f2c_doublecomplex','integer','real','doublereal','logical']:
         return '<{0}*>'.format(arg)
     return ''
 
-
 def pyx_decl_func(name, ret_type, args, header_name):
+    # clapack returns double for single precision functions (why?)
+    if ret_type=='s':
+        ret_type='d'
+
+    c_ret_type=c_types[ret_type]
+    if ret_type=='z':
+        py_ret_type='double complex'
+    elif ret_type=='c':
+        py_ret_type='float complex'
+    else:
+         py_ret_type=c_ret_type
     argtypes, argnames = arg_names_and_types(args)
-    # Fix the case where one of the arguments has the same name as the
-    # abbreviation for the argument type.
-    # Otherwise the variable passed as an argument is considered overwrites
-    # the previous typedef and Cython compilation fails.
-    if ret_type in argnames:
-        argnames = [n if n != ret_type else ret_type + '_' for n in argnames]
-        argnames = [n if n not in ['lambda', 'in'] else n + '_'
-                    for n in argnames]
-        args = ', '.join([' *'.join([n, t])
-                          for n, t in zip(argtypes, argnames)])
-    argtypes = [npy_types.get(t, t) for t in argtypes]
-    fort_args = ', '.join([' *'.join([n, t])
+    argtypes = [c_types.get(t, t) for t in argtypes]
+    pyargtypes = [py_type_replacements.get(t, t) for t in argtypes]
+    py_args = ', '.join([' *'.join([n, t])
+                           for n, t in zip(pyargtypes, argnames)])
+    args = ', '.join([' *'.join([n, t])
                            for n, t in zip(argtypes, argnames)])
+    unwrapper_argnames=",".join(argnames)
     argnames = [arg_casts(t) + n for n, t in zip(argnames, argtypes)]
     argnames = ', '.join(argnames)
-    c_ret_type = c_types[ret_type]
     args = args.replace('lambda', 'lambda_')
-    return pyx_func_template.format(name=name, upname=name.upper(), args=args,
-                                    fort_args=fort_args, ret_type=ret_type,
-                                    c_ret_type=c_ret_type, argnames=argnames,
+    # CLAPACK handles strings c style i.e. by null termination
+    # these unwrappers remove the fortran style length arguments
+    # they are for calling from f2c only
+    # I think normally they'd be in the lapack already, but they aren't in 
+    # clapack. They are made public for use in f2c generated code
+    unwrapper=""
+    if needs_wrapper(argtypes):
+        extra_args=args
+        num_extra=0
+        for c in argtypes:
+            if c=='char':
+                num_extra+=1
+                extra_args+=", int ignore_%d"%(num_extra)
+        unwrapper=pyx_clapack_unwrapper_template.format(name=name,extra_args=extra_args,argnames=unwrapper_argnames,args=args,c_ret_type=c_ret_type)
+    if ret_type=='z' or ret_type=='c':
+        return unwrapper+pyx_func_template_complex.format(name=name,upname=name.upper(),args=args,
+                                    ret_type=c_ret_type,c_ret_type=c_ret_type,py_ret_type=py_ret_type,
+                                    argnames=argnames,header_name=header_name,py_args=py_args)
+    else:
+        return unwrapper+pyx_func_template.format(name=name, upname=name.upper(), args=args,
+                                    ret_type=c_ret_type,c_ret_type=c_ret_type,py_args=py_args,
+                                    argnames=argnames,py_ret_type=py_ret_type,
                                     header_name=header_name)
 
 pyx_sub_template = """cdef extern from "{header_name}":
-    void _fortran_{name} "F_FUNC({name},{upname})"({fort_args}) nogil
-cdef void {name}({args}) nogil:
+    int _fortran_{name} "F_FUNC({name},{upname})"({args}) nogil
+cdef int {name}({py_args}) nogil:
     _fortran_{name}({argnames})
 """
 
+pyx_clapack_unwrapper_template= """
+
+cdef extern {c_ret_type} {name}_({args})
+
+cdef public {c_ret_type} w{name}_({extra_args}):
+    return {name}_({argnames});
+"""
 
 def pyx_decl_sub(name, args, header_name):
     argtypes, argnames = arg_names_and_types(args)
-    argtypes = [npy_types.get(t, t) for t in argtypes]
+    argtypes = [c_types.get(t, t) for t in argtypes]
     argnames = [n if n not in ['lambda', 'in'] else n + '_' for n in argnames]
-    fort_args = ', '.join([' *'.join([n, t])
+    pyargtypes = [py_type_replacements.get(t, t) for t in argtypes]
+    py_args = ', '.join([' *'.join([n, t])
+                           for n, t in zip(pyargtypes, argnames)])
+    args = ', '.join([' *'.join([n, t])
                            for n, t in zip(argtypes, argnames)])
+    unwrapper_argnames=",".join(argnames)
     argnames = [arg_casts(t) + n for n, t in zip(argnames, argtypes)]
     argnames = ', '.join(argnames)
     args = args.replace('*lambda,', '*lambda_,').replace('*in,', '*in_,')
-    return pyx_sub_template.format(name=name, upname=name.upper(),
-                                   args=args, fort_args=fort_args,
+    # CLAPACK handles strings c style i.e. by null termination
+    # these unwrappers remove the fortran style length arguments
+    # normally the lapack would be a fortran library so it would need 
+    # them, but not CLAPACK
+    unwrapper=""
+    if needs_wrapper(argtypes):
+        extra_args=args
+        num_extra=0
+        for c in argtypes:
+            if c=='char':
+                num_extra+=1
+                extra_args+=", int ignore_%d"%(num_extra)
+        unwrapper=pyx_clapack_unwrapper_template.format(name=name,extra_args=extra_args,argnames=unwrapper_argnames,args=args,c_ret_type='int')
+    return unwrapper+ pyx_sub_template.format(name=name, upname=name.upper(),
+                                   args=args, py_args=py_args,
                                    argnames=argnames, header_name=header_name)
 
 blas_pyx_preamble = '''# cython: boundscheck = False
@@ -190,14 +266,14 @@ from numpy cimport npy_complex64, npy_complex128
 cdef extern from "_lapack_subroutines.h":
     # Function pointer type declarations for
     # gees and gges families of functions.
-    ctypedef bint _cselect1(npy_complex64*)
-    ctypedef bint _cselect2(npy_complex64*, npy_complex64*)
-    ctypedef bint _dselect2(d*, d*)
-    ctypedef bint _dselect3(d*, d*, d*)
-    ctypedef bint _sselect2(s*, s*)
-    ctypedef bint _sselect3(s*, s*, s*)
-    ctypedef bint _zselect1(npy_complex128*)
-    ctypedef bint _zselect2(npy_complex128*, npy_complex128*)
+    ctypedef int _cselect1(npy_complex64*)
+    ctypedef int _cselect2(npy_complex64*, npy_complex64*)
+    ctypedef int _dselect2(d*, d*)
+    ctypedef int _dselect3(d*, d*, d*)
+    ctypedef int _sselect2(s*, s*)
+    ctypedef int _sselect3(s*, s*, s*)
+    ctypedef int _zselect1(npy_complex128*)
+    ctypedef int _zselect2(npy_complex128*, npy_complex128*)
 
 '''
 
@@ -210,7 +286,7 @@ blas_py_wrappers = """
 
 # Python-accessible wrappers for testing:
 
-cdef inline bint _is_contiguous(double[:,:] a, int axis) nogil:
+cdef inline int _is_contiguous(double[:,:] a, int axis) nogil:
     return (a.strides[axis] == sizeof(a[0,0]) or a.shape[axis] == 1)
 
 cpdef float complex _test_cdotc(float complex[:] cx, float complex[:] cy) nogil:
@@ -452,6 +528,16 @@ pxd_template = """cdef {ret_type} {name}({args}) nogil
 
 def pxd_decl(name, ret_type, args):
     args = args.replace('lambda', 'lambda_').replace('*in,', '*in_,')
+
+    argtypes, argnames = arg_names_and_types(args)
+    argtypes = [c_types.get(t, t) for t in argtypes]
+    argtypes = [py_type_replacements.get(t, t) for t in argtypes]
+    args = ', '.join([' *'.join([n, t])
+                           for n, t in zip(argtypes, argnames)])
+    if ret_type=='s':
+        ret_type='d'
+    ret_type=c_types[ret_type]
+    ret_type=py_type_replacements.get(ret_type,ret_type)
     return pxd_template.format(name=name, ret_type=ret_type, args=args)
 
 blas_pxd_preamble = """# Within scipy, these wrappers can be used via relative or absolute cimport.
@@ -470,6 +556,7 @@ ctypedef double d
 ctypedef float complex c
 ctypedef double complex z
 
+from numpy cimport npy_complex64, npy_complex128
 """
 
 
@@ -488,27 +575,43 @@ lapack_pxd_preamble = """# Within scipy, these wrappers can be used via relative
 # these wrappers should not be used.
 # The original libraries should be linked directly.
 
+
 ctypedef float s
 ctypedef double d
 ctypedef float complex c
 ctypedef double complex z
 
+from numpy cimport npy_complex64, npy_complex128
+
 # Function pointer type declarations for
 # gees and gges families of functions.
-ctypedef bint cselect1(c*)
-ctypedef bint cselect2(c*, c*)
-ctypedef bint dselect2(d*, d*)
-ctypedef bint dselect3(d*, d*, d*)
-ctypedef bint sselect2(s*, s*)
-ctypedef bint sselect3(s*, s*, s*)
-ctypedef bint zselect1(z*)
-ctypedef bint zselect2(z*, z*)
+#ctypedef int cselect1(npy_complex64*)
+#ctypedef int cselect2(npy_complex64*, npy_complex64*)
+#ctypedef int dselect2(double*, double*)
+#ctypedef int dselect3(double*,double*,double*)
+#ctypedef int sselect2(float*,float*)
+#ctypedef int sselect3(float*,float*,float*)
+#ctypedef int zselect1(npy_complex128*)
+#ctypedef int zselect2(npy_complex128*,npy_complex128*,npy_complex128*)
+
+cdef extern from "_lapack_subroutines.h":
+    # Function pointer type declarations for
+    # gees and gges families of functions.
+    ctypedef int _cselect1(npy_complex64*)
+    ctypedef int _cselect2(npy_complex64*, npy_complex64*)
+    ctypedef int _dselect2(d*, d*)
+    ctypedef int _dselect3(d*, d*, d*)
+    ctypedef int _sselect2(s*, s*)
+    ctypedef int _sselect3(s*, s*, s*)
+    ctypedef int _zselect1(npy_complex128*)
+    ctypedef int _zselect2(npy_complex128*, npy_complex128*)
+
 
 """
 
 
 def generate_lapack_pxd(all_sigs):
-    return lapack_pxd_preamble + '\n'.join(pxd_decl(*sig) for sig in all_sigs)
+    return lapack_pxd_preamble  + '\n'.join(pxd_decl(*sig) for sig in all_sigs)
 
 fortran_template = """      subroutine {name}wrp(ret, {argnames})
         external {wrapper}
@@ -535,12 +638,14 @@ def process_fortran_name(name, funcname):
 
 
 def fort_subroutine_wrapper(name, ret_type, args):
-    if name[0] in ['c', 's'] or name in ['zladiv', 'zdotu', 'zdotc']:
+    if ret_type=='s':
+        ret_type='d'
+    types, names = arg_names_and_types(args)
+    argnames = ', '.join(names)
+    if needs_wrapper(types):
         wrapper = 'w' + name
     else:
         wrapper = name
-    types, names = arg_names_and_types(args)
-    argnames = ', '.join(names)
 
     names = [process_fortran_name(n, name) for n in names]
     argdecls = '\n        '.join('{0} {1}'.format(fortran_types[t], n)
@@ -554,21 +659,38 @@ def generate_fortran(func_sigs):
     return "\n".join(fort_subroutine_wrapper(*sig) for sig in func_sigs)
 
 
-def make_c_args(args):
+def make_c_args(args,*,add_char_length_args=False):
     types, names = arg_names_and_types(args)
+    names=list(names)
     types = [c_types[arg] for arg in types]
+    if add_char_length_args:
+        new_args=0
+        for c in types:
+            if c=='char':
+                new_args+=1
+        for c in range(new_args):
+            types.append('ftnlen')
+            names.append('ignore_%d'%c)
     return ', '.join('{0} *{1}'.format(t, n) for t, n in zip(types, names))
 
-c_func_template = "void F_FUNC({name}wrp, {upname}WRP)({return_type} *ret, {args});\n"
+c_func_template = "{return_type} F_FUNC({name}, {upname})( {args});\n"
+c_func_template_complex = "void F_FUNC({name}, {upname})({return_type} *ret, {args});\n"
 
 
 def c_func_decl(name, return_type, args):
-    args = make_c_args(args)
-    return_type = c_types[return_type]
-    return c_func_template.format(name=name, upname=name.upper(),
+    if return_type=='s':
+        return_type='d'
+    args = make_c_args(args,add_char_length_args=False)
+    if return_type=='z' or return_type=='c':
+        return_type = c_types[return_type]
+        return c_func_template_complex.format(name=name, upname=name.upper(),
+                                  return_type=return_type, args=args)
+    else:
+        return_type = c_types[return_type]
+        return c_func_template.format(name=name, upname=name.upper(),
                                   return_type=return_type, args=args)
 
-c_sub_template = "void F_FUNC({name},{upname})({args});\n"
+c_sub_template = "int F_FUNC({name},{upname})({args});\n"
 
 
 def c_sub_decl(name, return_type, args):
@@ -579,6 +701,7 @@ c_preamble = """#ifndef SCIPY_LINALG_{lib}_FORTRAN_WRAPPERS_H
 #define SCIPY_LINALG_{lib}_FORTRAN_WRAPPERS_H
 #include "fortran_defs.h"
 #include "numpy/arrayobject.h"
+#include "f2c.h"
 """
 
 lapack_decls = """
@@ -630,6 +753,15 @@ def filter_lines(ls):
     all_sigs = list(sorted(func_sigs + sub_sigs, key=itemgetter(0)))
     return func_sigs, sub_sigs, all_sigs
 
+def generate_wrapper_list(sigs):
+    wrappers=""
+    for name,rt,args in sigs:
+        anames,atypes=arg_names_and_types(args)
+        if "char" in atypes:
+            wrappers+=name+":w"+name+",\n"
+    return wrappers
+
+    
 
 def make_all(blas_signature_file="cython_blas_signatures.txt",
              lapack_signature_file="cython_lapack_signatures.txt",
@@ -682,6 +814,10 @@ def make_all(blas_signature_file="cython_blas_signatures.txt",
     with open(lapack_header_name, 'w') as f:
         f.write(ccomment)
         f.write(lapack_c_header)
+    wrapper_list = generate_wrapper_list([*lapack_sigs[2]]+[*blas_sigs[2]])
+    with open("wrapper_list.txt",'w') as f:
+        f.write(ccomment)
+        f.write(wrapper_list)
 
 if __name__ == '__main__':
     make_all()
diff --git a/scipy/linalg/cython_lapack_signatures.txt b/scipy/linalg/cython_lapack_signatures.txt
index 0455995..34d0782 100644
--- a/scipy/linalg/cython_lapack_signatures.txt
+++ b/scipy/linalg/cython_lapack_signatures.txt
@@ -1296,3 +1296,4 @@ void zunmrz(char *side, char *trans, int *m, int *n, int *k, int *l, z *a, int *
 void zunmtr(char *side, char *uplo, char *trans, int *m, int *n, z *a, int *lda, z *tau, z *c, int *ldc, z *work, int *lwork, int *info)
 void zupgtr(char *uplo, int *n, z *ap, z *tau, z *q, int *ldq, z *work, int *info)
 void zupmtr(char *side, char *uplo, char *trans, int *m, int *n, z *ap, z *tau, z *c, int *ldc, z *work, int *info)
+void ilaenv(int *ispec, char *name, char *opts, int *n1, int *n2, int *n3, int *n4)
diff --git a/scipy/linalg/fblas_l1.pyf.src b/scipy/linalg/fblas_l1.pyf.src
index 5008ee8..6380740 100644
--- a/scipy/linalg/fblas_l1.pyf.src
+++ b/scipy/linalg/fblas_l1.pyf.src
@@ -252,14 +252,17 @@ end subroutine <prefix>axpy
 function sdot(n,x,offx,incx,y,offy,incy) result (xy)
   ! Computes a vector-vector dot product.
 
-  fortranname wsdot
+  callstatement sdot_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,float*,int*,float*,int*
+
+  fortranname F_FUNC(sdot,SDOT)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) sdot
 
-  callstatement (*f2py_func)(&sdot,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument float*,int*,float*,int*,float*,int*
 
   real dimension(*), intent(in) :: x
   real dimension(*), intent(in) :: y
-  real sdot,xy
+  double precision sdot,xy
   integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
   integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
   integer optional, intent(in),depend(x) :: offx=0
@@ -277,8 +280,12 @@ end function sdot
 function ddot(n,x,offx,incx,y,offy,incy) result (xy)
   ! Computes a vector-vector dot product.
 
-  callstatement (*f2py_func)(&ddot,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument double*,int*,double*,int*,double*,int*
+  callstatement ddot_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,double*,int*,double*,int*
+
+  fortranname F_FUNC(ddot,ddot)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) ddot
 
   double precision dimension(*), intent(in) :: x
   double precision dimension(*), intent(in) :: y
@@ -297,15 +304,19 @@ function ddot(n,x,offx,incx,y,offy,incy) result (xy)
 end function ddot
 
 
+// in CLAPACK, cdotu and zdotu are void and return by pointer (as can't return complex* without allocation)
 ! <prefix2c=c,z> <ftype2c=complex,double complex> <ctype2c=complex_float,complex_double>
 function <prefix2c>dotu(n,x,offx,incx,y,offy,incy) result(xy)
 
   <ftype2c> :: <prefix2c>dotu, xy
-  fortranname w<prefix2c>dotu
 
-  callstatement (*f2py_func)(&<prefix2c>dotu,&n,x+offx,&incx,y+offy,&incy)
+  callstatement (*f2py_func)(&<prefix2c>dotu_return_value,&n,x+offx,&incx,y+offy,&incy)
   callprotoargument <ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*
 
+  fortranname F_FUNC(<prefix2c>dotu,<C,Z>DOTU)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix2c>dotu
+
   <ftype2c> dimension(*),intent(in) :: x
   <ftype2c> dimension(*),intent(in) :: y
 
@@ -328,10 +339,12 @@ end function <prefix2c>dotu
 function <prefix2c>dotc(n,x,offx,incx,y,offy,incy) result(xy)
 
   <ftype2c> :: <prefix2c>dotc, xy
-  fortranname w<prefix2c>dotc
+  callstatement <prefix2c>dotc_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,<ctype2c>*,int*,<ctype2c>*,int*
 
-  callstatement (*f2py_func)(&<prefix2c>dotc,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument <ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*
+  fortranname F_FUNC(<prefix2c>dotc,<C,Z>DOTC)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix2c>dotc
 
   <ftype2c> dimension(*),intent(in) :: x
   <ftype2c> dimension(*),intent(in) :: y
@@ -354,11 +367,15 @@ end function <prefix2c>dotc
 ! <ftype3=real,complex> <ftypereal3=real,real>
 function <prefix3>nrm2(n,x,offx,incx) result(n2)
 
-  fortranname w<prefix3>nrm2
-  <ftypereal3> <prefix3>nrm2, n2
+  <ftypereal3> nm2
+  double precision <prefix3>nrm2
 
-  callstatement (*f2py_func)(&<prefix3>nrm2, &n,x+offx,&incx)
-  callprotoargument <ctypereal3>*,int*,<ctype3>*,int*
+  callstatement <prefix3>nrm2_return_value=(*f2py_func)( &n,x+offx,&incx)
+  callprotoargument int*,<ctype3>*,int*
+
+  fortranname F_FUNC(<prefix3>nrm2,<S,SC>NRM2)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix3>nrm2
 
   <ftype3> dimension(*),intent(in) :: x
 
@@ -378,10 +395,15 @@ end function <prefix3>nrm2
 ! <ftypereal4=double precision,double precision>
 function <prefix4>nrm2(n,x,offx,incx) result(n2)
 
-  <ftypereal4> <prefix4>nrm2, n2
+  callstatement <prefix4>nrm2_return_value=(*f2py_func)(&n,x+offx,&incx)
+  callprotoargument int*,<ctype4>*,int*
+
+  double precision <prefix4>nrm2
+  <ftype4> n2
+  fortranname F_FUNC(<prefix4>nrm2,<S,D>NRM2)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix4>nrm2
 
-  callstatement (*f2py_func)(&<prefix4>nrm2, &n,x+offx,&incx)
-  callprotoargument <ctypereal4>*,int*,<ctype4>*,int*
 
   <ftype4> dimension(*),intent(in) :: x
 
@@ -396,16 +418,20 @@ function <prefix4>nrm2(n,x,offx,incx) result(n2)
 end function <prefix4>nrm2
 
 
-function <prefix3>asum(n,x,offx,incx) result (s)
+function <prefix3>asum(n,x,offx,incx) result (d)
   ! Computes the sum of magnitudes of the vector elements
 
-  fortranname w<prefix3>asum
+  callstatement <prefix3>asum_return_value=(*f2py_func)(&n,x+offx,&incx)
+  callprotoargument int*,<ctype3>*,int*
 
-  callstatement (*f2py_func)(&<prefix3>asum,&n,x+offx,&incx)
-  callprotoargument <ctypereal3>*,int*,<ctype3>*,int*
+  double precision <prefix3>asum
+  fortranname F_FUNC(<prefix3>asum,<S,SC>ASUM)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix3>asum
 
   <ftype3> dimension(*), intent(in) :: x
-  <ftypereal3> <prefix3>asum,s
+  <ftypereal3> s
+  double precision <prefix3>asum
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
   integer optional, intent(in), depend(x) :: offx=0
   check(offx>=0 && offx<len(x)) :: offx
@@ -415,11 +441,16 @@ function <prefix3>asum(n,x,offx,incx) result (s)
 end function <prefix3>asum
 
 
-function <prefix4>asum(n,x,offx,incx) result (s)
+function <prefix4>asum(n,x,offx,incx) result (d)
   ! Computes the sum of magnitudes of the vector elements
 
-  callstatement (*f2py_func)(&<prefix4>asum,&n,x+offx,&incx)
-  callprotoargument <ctypereal4>*,int*,<ctype4>*,int*
+  callstatement <prefix4>asum_return_value=(*f2py_func)(&n,x+offx,&incx) 
+  callprotoargument int*,<ctype4>*,int*
+
+  <ftype4> <prefix4>asum
+  fortranname F_FUNC(<prefix4>asum,<D,Z>ASUM)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix4>asum
 
   <ftype4> dimension(*), intent(in) :: x
   <ftypereal4> <prefix4>asum,s
@@ -438,9 +469,9 @@ function i<prefix>amax(n,x,offx,incx) result(k)
   callstatement i<prefix>amax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
   callprotoargument int*,<ctype>*,int*
 
-  ! This is to avoid Fortran wrappers.
+  ! This is to avoid Fortran wrappers - fix for CLAPACK
   integer i<prefix>amax,k
-  fortranname F_FUNC(i<prefix>amax,I<S,D,C,Z>AMAX)
+  fortranname F_FUNC(i<prefix>amax,I<D,DZ>AMAX)
   intent(c) i<prefix>amax
   <ftype> dimension(*), intent(in) :: x
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
diff --git a/scipy/linalg/flapack.pyf.src b/scipy/linalg/flapack.pyf.src
index fd7c8ac..afbd956 100644
--- a/scipy/linalg/flapack.pyf.src
+++ b/scipy/linalg/flapack.pyf.src
@@ -2344,7 +2344,15 @@ end subroutine <prefix2c>hbevx
 !          rmax  = overflow threshold  - (base**emax)*(1-eps)
 function dlamch(cmach)
     character :: cmach
-    double precision intent(out):: dlamch
+    double precision:: dlamch
+    callstatement dlamch_return_value=(*f2py_func)(cmach)
+    callprotoargument char*
+
+    fortranname F_FUNC(dlamch,DLAMCH)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) dlamch
+
+
 end function dlamch
 
 function slamch(cmach)
@@ -2824,9 +2832,12 @@ function <prefix2>lange(norm,m,n,a,lda,work) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a real matrix A.
     <ftype2> <prefix2>lange, n2
-    fortranname <wrap2>lange
-    callstatement (*f2py_func)(&<prefix2>lange,norm,&m,&n,a,&m,work)
-    callprotoargument <ctype2>*,char*,int*,int*,<ctype2>*,int*,<ctype2>*
+    callstatement <prefix2>lange_return_value=(*f2py_func)(norm,&m,&n,a,&m,work)
+    callprotoargument char*,int*,int*,<ctype2>*,int*,<ctype2>*
+
+    fortranname F_FUNC(<prefix2>lange,<S,D>LANGE)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) <prefix2>lange
 
     character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
     integer intent(hide),depend(a,n) :: m = shape(a,0)
@@ -2840,9 +2851,13 @@ function <prefix2c>lange(norm,m,n,a,lda,work) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a complex matrix A.
     <ftype2> <prefix2c>lange, n2
-    fortranname <wrap2c>lange
-    callstatement (*f2py_func)(&<prefix2c>lange,norm,&m,&n,a,&m,work)
-    callprotoargument <ctype2>*,char*,int*,int*,<ctype2c>*,int*,<ctype2>*
+
+    callstatement <prefix2c>lange_return_value=(*f2py_func)(&norm,&m,&n,a,&m,work)
+    callprotoargument char*,int*,int*,<ctype2c>*,int*,<ctype2>*
+
+    fortranname F_FUNC(<prefix2c>lange,<C,Z>LANGE)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) <prefix2c>lange
 
     character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
     integer intent(hide),depend(a,n) :: m = shape(a,0)
diff --git a/scipy/linalg/setup.py b/scipy/linalg/setup.py
index 8084aa8..5408c79 100755
--- a/scipy/linalg/setup.py
+++ b/scipy/linalg/setup.py
@@ -44,9 +44,10 @@ def configuration(parent_package='', top_path=None):
     # flapack:
     sources = ['flapack.pyf.src']
     sources += get_g77_abi_wrappers(lapack_opt)
-    dep_pfx = join('src', 'lapack_deprecations')
-    deprecated_lapack_routines = [join(dep_pfx, c + 'gegv.f') for c in 'cdsz']
-    sources += deprecated_lapack_routines
+#   CLAPACK still has these routines (with conflicting signatures)
+#    dep_pfx = join('src', 'lapack_deprecations')
+#    deprecated_lapack_routines = [join(dep_pfx, c + 'gegv.f') for c in 'cdsz']
+#    sources += deprecated_lapack_routines
 
     config.add_extension('_flapack',
                          sources=sources,
diff --git a/scipy/optimize/_lsq/setup.py b/scipy/optimize/_lsq/setup.py
index b9222a0..863400b 100644
--- a/scipy/optimize/_lsq/setup.py
+++ b/scipy/optimize/_lsq/setup.py
@@ -5,7 +5,7 @@ def configuration(parent_package='', top_path=None):
     from numpy.distutils.misc_util import Configuration
     config = Configuration('_lsq', parent_package, top_path)
     config.add_extension('givens_elimination',
-                         sources=['givens_elimination.c'])
+                         sources=['givens_elimination.c'],include_dirs=['../../linalg'])
     return config
 
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
index e17532d..a7a5629 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
@@ -80,9 +80,6 @@ cgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     int    kase, kase1, onenrm, i;
     float ainvnm;
     complex *work;
-    extern int crscl_(int *, complex *, complex *, int *);
-
-    extern int clacon_(int *, complex *, complex *, float *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
index db31e35..1da9ac0 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
@@ -92,7 +92,6 @@ cgsequ(SuperMatrix *A, float *r, float *c, float *rowcnd,
     int i, j, irow;
     float rcmin, rcmax;
     float bignum, smlnum;
-    extern float slamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
index e7c2bc7..0dde69b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
@@ -158,14 +158,6 @@ cgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     float   *rwork;
     int      *iwork;
 
-    extern int clacon_(int *, complex *, complex *, float *, int *);
-#ifdef _CRAY
-    extern int CCOPY(int *, complex *, int *, complex *, int *);
-    extern int CSAXPY(int *, complex *, complex *, int *, complex *, int *);
-#else
-    extern int ccopy_(int *, complex *, int *, complex *, int *);
-    extern int caxpy_(int *, complex *, complex *, int *, complex *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
index d206d5a..8e64576 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
@@ -85,9 +85,6 @@ clacon_(int *n, complex *v, complex *x, float *est, int *kase)
     static int i, j;
     float temp;
     float safmin;
-    extern float slamch_(char *);
-    extern int icmax1_(int *, complex *, int *);
-    extern double scsum1_(int *, complex *, int *);
 
     safmin = slamch_("Safe minimum");
     if ( *kase == 0 ) {
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
index d91474a..f33f10d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
@@ -81,9 +81,6 @@ dgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     double ainvnm;
     double *work;
     int    *iwork;
-    extern int drscl_(int *, double *, double *, int *);
-
-    extern int dlacon_(int *, double *, double *, int *, double *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
index 73870d4..222bf66 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
@@ -92,7 +92,6 @@ dgsequ(SuperMatrix *A, double *r, double *c, double *rowcnd,
     int i, j, irow;
     double rcmin, rcmax;
     double bignum, smlnum;
-    extern double dlamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
index 55531b0..792509c 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
@@ -158,14 +158,6 @@ dgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     double   *rwork;
     int      *iwork;
 
-    extern int dlacon_(int *, double *, double *, int *, double *, int *);
-#ifdef _CRAY
-    extern int SCOPY(int *, double *, int *, double *, int *);
-    extern int SSAXPY(int *, double *, double *, int *, double *, int *);
-#else
-    extern int dcopy_(int *, double *, int *, double *, int *);
-    extern int daxpy_(int *, double *, double *, int *, double *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
index 951fe7a..7359570 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
@@ -80,15 +80,6 @@ dlacon_(int *n, double *v, double *x, int *isgn, double *est, int *kase)
     static double altsgn, estold;
     static int i, j;
     double temp;
-#ifdef _CRAY
-    extern int ISAMAX(int *, double *, int *);
-    extern double SASUM(int *, double *, int *);
-    extern int SCOPY(int *, double *, int *, double *, int *);
-#else
-    extern int idamax_(int *, double *, int *);
-    extern double dasum_(int *, double *, int *);
-    extern int dcopy_(int *, double *, int *, double *, int *);
-#endif
 #define d_sign(a, b) (b >= 0 ? fabs(a) : -fabs(a))    /* Copy sign */
 #define i_dnnt(a) \
 	( a>=0 ? floor(a+.5) : -floor(.5-a) ) /* Round to nearest integer */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
index e117915..28ffdbb 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
@@ -76,10 +76,7 @@ double dlamch_(char *cmach)
     static int imin, imax;
     static int lrnd;
     static double rmin, rmax, t, rmach;
-    extern int lsame_(char *, char *);
     static double small, sfmin;
-    extern /* Subroutine */ int dlamc2_(int *, int *, int *, 
-	    double *, int *, double *, int *, double *);
     static int it;
     static double rnd, eps;
 
@@ -197,7 +194,6 @@ int dlamc1_(int *beta, int *t, int *rnd, int
     static double a, b, c, f;
     static int lbeta;
     static double savec;
-    extern double dlamc3_(double *, double *);
     static int lieee1;
     static double t1, t2;
     static int lt;
@@ -435,13 +431,7 @@ int dlamc2_(int *beta, int *t, int *rnd,
     static double small;
     static int gpmin;
     static double third, lrmin, lrmax, sixth;
-    extern /* Subroutine */ int dlamc1_(int *, int *, int *, 
-	    int *);
-    extern double dlamc3_(double *, double *);
     static int lieee1;
-    extern /* Subroutine */ int dlamc4_(int *, double *, int *), 
-	    dlamc5_(int *, int *, int *, int *, int *, 
-	    double *);
     static int lt, ngnmin, ngpmin;
     static double one, two;
 
@@ -725,7 +715,6 @@ int dlamc4_(int *emin, double *start, int *base)
     static double zero, a;
     static int i;
     static double rbase, b1, b2, c1, c2, d1, d2;
-    extern double dlamc3_(double *, double *);
     static double one;
 
     a = *start;
@@ -840,7 +829,6 @@ int dlamc5_(int *beta, int *p, int *emin,
     static int uexp, i;
     static double y, z;
     static int nbits;
-    extern double dlamc3_(double *, double *);
     static double recbas;
     static int exbits, expsum, try__;
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
index 5a7203d..0ac71c0 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
@@ -16,10 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void ccopy_(int *, complex [], int *, complex [], int *);
-#if SCIPY_FIX
-extern double dlamch_(char *);
-#endif
 
 #if 0
 static complex *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
index 44173c8..fa1b999 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_cdefs.h"
 
-extern void cswap_(int *, complex [], int *, complex [], int *);
-extern void caxpy_(int *, complex *, complex [], int *, complex [], int *);
-extern void ccopy_(int *, complex [], int *, complex [], int *);
-extern float scasum_(int *, complex *, int *);
-extern float scnrm2_(int *, complex *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int icamax_(int *, complex [], int *);
 
 static float *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
index e9162a7..22eae38 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
@@ -16,7 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void dcopy_(int *, double [], int *, double [], int *);
 
 #if 0
 static double *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
index a08c85c..3174de3 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_ddefs.h"
 
-extern void dswap_(int *, double [], int *, double [], int *);
-extern void daxpy_(int *, double *, double [], int *, double [], int *);
-extern void dcopy_(int *, double [], int *, double [], int *);
-extern double dasum_(int *, double *, int *);
-extern double dnrm2_(int *, double *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int idamax_(int *, double [], int *);
 
 static double *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
index b9fd387..eee65c8 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
@@ -16,10 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void scopy_(int *, float [], int *, float [], int *);
-#if SCIPY_FIX
-extern double dlamch_(char *);
-#endif
 
 #if 0
 static float *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
index 108f849..7ce483d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_sdefs.h"
 
-extern void sswap_(int *, float [], int *, float [], int *);
-extern void saxpy_(int *, float *, float [], int *, float [], int *);
-extern void scopy_(int *, float [], int *, float [], int *);
-extern float sasum_(int *, float *, int *);
-extern float snrm2_(int *, float *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int isamax_(int *, float [], int *);
 
 static float *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
index ddf3a63..cef2341 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
@@ -16,7 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void zcopy_(int *, doublecomplex [], int *, doublecomplex [], int *);
 
 #if 0
 static doublecomplex *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
index 0a140d4..2207950 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_zdefs.h"
 
-extern void zswap_(int *, doublecomplex [], int *, doublecomplex [], int *);
-extern void zaxpy_(int *, doublecomplex *, doublecomplex [], int *, doublecomplex [], int *);
-extern void zcopy_(int *, doublecomplex [], int *, doublecomplex [], int *);
-extern double dzasum_(int *, doublecomplex *, int *);
-extern double dznrm2_(int *, doublecomplex *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int izamax_(int *, doublecomplex [], int *);
 
 static double *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
index 5afc93b..1a2c4ca 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
@@ -3,6 +3,14 @@
 
 #include <stdlib.h>
 
+#include"f2c.h"
+#define integer int
+#define logical int
+#include"clapack.h"
+#undef integer
+#undef logical
+
+
 /*
  * Support routines
  */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
index a474967..ae4a511 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
@@ -81,9 +81,6 @@ sgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     float ainvnm;
     float *work;
     int    *iwork;
-    extern int srscl_(int *, float *, float *, int *);
-
-    extern int slacon_(int *, float *, float *, int *, float *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
index 3637d7e..cf435db 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
@@ -92,7 +92,6 @@ sgsequ(SuperMatrix *A, float *r, float *c, float *rowcnd,
     int i, j, irow;
     float rcmin, rcmax;
     float bignum, smlnum;
-    extern float slamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
index a93bc5b..c685106 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
@@ -158,14 +158,6 @@ sgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     float   *rwork;
     int      *iwork;
 
-    extern int slacon_(int *, float *, float *, int *, float *, int *);
-#ifdef _CRAY
-    extern int SCOPY(int *, float *, int *, float *, int *);
-    extern int SSAXPY(int *, float *, float *, int *, float *, int *);
-#else
-    extern int scopy_(int *, float *, int *, float *, int *);
-    extern int saxpy_(int *, float *, float *, int *, float *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
index d33ca33..212ac4b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
@@ -11,6 +11,8 @@
  */
 #include "slu_sdefs.h"
 
+extern float slangs(char *, SuperMatrix *);
+
 /*! \brief
  *
  * <pre>
@@ -357,8 +359,6 @@ sgssvx(superlu_options_t *options, SuperMatrix *A, int *perm_c, int *perm_r,
     double    t0;      /* temporary time */
     double    *utime;
 
-    /* External functions */
-    extern float slangs(char *, SuperMatrix *);
 
     Bstore = B->Store;
     Xstore = X->Store;
@@ -552,7 +552,9 @@ printf("dgssvx: Fact=%4d, Trans=%4d, equed=%c\n",
         } else {
 	    *(unsigned char *)norm = 'I';
         }
-        anorm = slangs(norm, AA);
+        anorm = slangs(norm, AA);    /* External functions */
+        extern float slangs(char *, SuperMatrix *);
+
         sgscon(norm, L, U, anorm, rcond, stat, info);
         utime[RCOND] = SuperLU_timer_() - t0;
     }
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
index 4e02fdc..d49f040 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
@@ -80,15 +80,6 @@ slacon_(int *n, float *v, float *x, int *isgn, float *est, int *kase)
     static float altsgn, estold;
     static int i, j;
     float temp;
-#ifdef _CRAY
-    extern int ISAMAX(int *, float *, int *);
-    extern float SASUM(int *, float *, int *);
-    extern int SCOPY(int *, float *, int *, float *, int *);
-#else
-    extern int isamax_(int *, float *, int *);
-    extern float sasum_(int *, float *, int *);
-    extern int scopy_(int *, float *, int *, float *, int *);
-#endif
 #define d_sign(a, b) (b >= 0 ? fabs(a) : -fabs(a))    /* Copy sign */
 #define i_dnnt(a) \
 	( a>=0 ? floor(a+.5) : -floor(.5-a) ) /* Round to nearest integer */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
index 09cf6e2..3155468 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
@@ -58,7 +58,7 @@
    ===================================================================== 
 </pre>
 */
-float slamch_(char *cmach)
+doublereal slamch_(char *cmach)
 {
 /* >>Start of File<<   
        Initialized data */
@@ -75,10 +75,7 @@ float slamch_(char *cmach)
     static int imin, imax;
     static int lrnd;
     static float rmin, rmax, t, rmach;
-    extern int lsame_(char *, char *);
     static float small, sfmin;
-    extern /* Subroutine */ int slamc2_(int *, int *, int *, float 
-	    *, int *, float *, int *, float *);
     static int it;
     static float rnd, eps;
 
@@ -205,7 +202,6 @@ int slamc1_(int *beta, int *t, int *rnd, int
     static float savec;
     static int lieee1;
     static float t1, t2;
-    extern double slamc3_(float *, float *);
     static int lt;
     static float one, qtr;
 
@@ -443,12 +439,6 @@ int slamc2_(int *beta, int *t, int *rnd, float *
     static int gpmin;
     static float third, lrmin, lrmax, sixth;
     static int lieee1;
-    extern /* Subroutine */ int slamc1_(int *, int *, int *, 
-	    int *);
-    extern double slamc3_(float *, float *);
-    extern /* Subroutine */ int slamc4_(int *, float *, int *), 
-	    slamc5_(int *, int *, int *, int *, int *, 
-	    float *);
     static int lt, ngnmin, ngpmin;
     static float one, two;
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
index acb82bc..c9d0946 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
@@ -13,8 +13,8 @@
 
 extern int_t mc64id_(int_t*);
 extern int_t mc64ad_(int_t*, int_t*, int_t*, int_t [], int_t [], double [],
-		    int_t*, int_t [], int_t*, int_t[], int_t*, double [],
-		    int_t [], int_t []);
+            int_t*, int_t [], int_t*, int_t[], int_t*, double [],
+            int_t [], int_t []);
 
 /*! \brief
  *
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
index 24d1374..cea93d6 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
@@ -236,7 +236,6 @@ extern int     sp_cgemv (char *, complex, SuperMatrix *, complex *,
 extern int     sp_cgemm (char *, char *, int, int, int, complex,
 			SuperMatrix *, complex *, int, complex, 
 			complex *, int);
-extern         float slamch_(char *);
 
 
 /*! \brief Memory-related */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
index 386ad68..72f5355 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
@@ -18,7 +18,10 @@
 #ifndef DCOMPLEX_INCLUDE
 #define DCOMPLEX_INCLUDE
 
-typedef struct { double r, i; } doublecomplex;
+#include"scipy_slu_config.h"
+
+// defined in clapack
+//typedef struct { double r, i; } doublecomplex;
 
 
 /* Macro definitions */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
index c17490d..fef343d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
@@ -17,8 +17,9 @@
 
 #ifndef SCOMPLEX_INCLUDE
 #define SCOMPLEX_INCLUDE
-
-typedef struct { float r, i; } complex;
+#include"scipy_slu_config.h"
+// defined in  CLAPACK
+//typedef struct { float r, i; } complex;
 
 
 /* Macro definitions */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
index 745d76f..0c2a45b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
@@ -235,7 +235,6 @@ extern int     sp_sgemv (char *, float, SuperMatrix *, float *,
 extern int     sp_sgemm (char *, char *, int, int, int, float,
 			SuperMatrix *, float *, int, float, 
 			float *, int);
-extern         float slamch_(char *);
 
 
 /*! \brief Memory-related */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
index f41b4ca..1560371 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
@@ -348,8 +348,6 @@ extern int     spcoletree (int *, int *, int *, int, int, int *);
 extern int     *TreePostorder (int, int *);
 extern double  SuperLU_timer_ ();
 extern int     sp_ienv (int);
-extern int     lsame_ (char *, char *);
-extern int     xerbla_ (char *, int *);
 extern void    ifill (int *, int, int);
 extern void    snode_profile (int, int *);
 extern void    super_stats (int, int *);
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
index 8bb95aa..8b6651d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
@@ -80,9 +80,6 @@ zgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     int    kase, kase1, onenrm, i;
     double ainvnm;
     doublecomplex *work;
-    extern int zrscl_(int *, doublecomplex *, doublecomplex *, int *);
-
-    extern int zlacon_(int *, doublecomplex *, doublecomplex *, double *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
index 657637d..b04e46f 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
@@ -92,7 +92,6 @@ zgsequ(SuperMatrix *A, double *r, double *c, double *rowcnd,
     int i, j, irow;
     double rcmin, rcmax;
     double bignum, smlnum;
-    extern double dlamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
index 2ed0481..110bfe1 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
@@ -158,14 +158,6 @@ zgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     double   *rwork;
     int      *iwork;
 
-    extern int zlacon_(int *, doublecomplex *, doublecomplex *, double *, int *);
-#ifdef _CRAY
-    extern int CCOPY(int *, doublecomplex *, int *, doublecomplex *, int *);
-    extern int CSAXPY(int *, doublecomplex *, doublecomplex *, int *, doublecomplex *, int *);
-#else
-    extern int zcopy_(int *, doublecomplex *, int *, doublecomplex *, int *);
-    extern int zaxpy_(int *, doublecomplex *, doublecomplex *, int *, doublecomplex *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
index b2cd1ed..6934f1e 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
@@ -85,9 +85,6 @@ zlacon_(int *n, doublecomplex *v, doublecomplex *x, double *est, int *kase)
     static int i, j;
     double temp;
     double safmin;
-    extern double dlamch_(char *);
-    extern int izmax1_(int *, doublecomplex *, int *);
-    extern double dzsum1_(int *, doublecomplex *, int *);
 
     safmin = dlamch_("Safe minimum");
     if ( *kase == 0 ) {
diff --git a/scipy/sparse/linalg/dsolve/_superlu_utils.c b/scipy/sparse/linalg/dsolve/_superlu_utils.c
index c2a10a7..eb85c3b 100644
--- a/scipy/sparse/linalg/dsolve/_superlu_utils.c
+++ b/scipy/sparse/linalg/dsolve/_superlu_utils.c
@@ -79,12 +79,12 @@ void superlu_python_module_free(void *ptr)
  * Stubs for Harwell Subroutine Library functions that SuperLU tries to call.
  */
 
-void mc64id_(int *a)
+int mc64id_(int *a)
 {
     superlu_python_module_abort("chosen functionality not available");
 }
 
-void mc64ad_(int *a, int *b, int *c, int d[], int e[], double f[],
+int mc64ad_(int *a, int *b, int *c, int d[], int e[], double f[],
 	     int *g, int h[], int *i, int j[], int *k, double l[],
 	     int m[], int n[])
 {
diff --git a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
index 5eb0bb1..03fb23d 100644
--- a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
+++ b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
@@ -1,16 +1,16 @@
-c
+
 c\SCCS Information: @(#) 
 c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
 c
 c     %---------------------------------%
 c     | See debug.doc for documentation |
 c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c      integer  logfil, ndigit, mgetv0,
+c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c      common /debug/ 
+c     &         logfil, ndigit, mgetv0,
+c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
diff --git a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
index 66a8e9f..1f2d49c 100644
--- a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
+++ b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
@@ -5,17 +5,17 @@ c
 c\SCCS Information: @(#) 
 c FILE: stat.h   SID: 2.2   DATE OF SID: 11/16/95   RELEASE: 2 
 c
-      real       t0, t1, t2, t3, t4, t5
-      save       t0, t1, t2, t3, t4, t5
+c      real       t0, t1, t2, t3, t4, t5
+c      save       t0, t1, t2, t3, t4, t5
 c
-      integer    nopx, nbx, nrorth, nitref, nrstrt
-      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
-      common /timing/ 
-     &           nopx, nbx, nrorth, nitref, nrstrt,
-     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
+c      integer    nopx, nbx, nrorth, nitref, nrstrt
+c      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
+c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
+c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
+c     &           tmvopx, tmvbx, tgetv0, titref, trvec
+c      common /timing/ 
+c     &           nopx, nbx, nrorth, nitref, nrstrt,
+c     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
+c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
+c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
+c     &           tmvopx, tmvbx, tgetv0, titref, trvec
diff --git a/scipy/spatial/qhull_blas.h b/scipy/spatial/qhull_blas.h
index 2e235db..666630e 100644
--- a/scipy/spatial/qhull_blas.h
+++ b/scipy/spatial/qhull_blas.h
@@ -16,6 +16,10 @@
 #endif
 #endif
 
+int dgetrs_(char *trans, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);
+int dgetrf_(int *m, int *n, double *a, int *lda, int *ipiv, int *info);
+int dgecon_(char *norm, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);
+
 #define qh_dgetrf F_FUNC(dgetrf,DGETRF)
 #define qh_dgecon F_FUNC(dgecon,DGECON)
 #define qh_dgetrs F_FUNC(dgetrs,DGETRS)
diff --git a/scipy/special/lapack_defs.h b/scipy/special/lapack_defs.h
index fb8fd80..d84cd3f 100644
--- a/scipy/special/lapack_defs.h
+++ b/scipy/special/lapack_defs.h
@@ -16,5 +16,6 @@
 #endif
 #endif
 
+int dstevr_(char *jobz, char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);
 #define c_dstevr F_FUNC(dstevr,DSTEVR)
 

