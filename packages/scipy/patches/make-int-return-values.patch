The return values of f2c functions are insignificant in most cases, so often it
is treated as returning void, when it really should return int (values are
"returned" by writing to pointers passed as an argument, but an obscure feature
known as alternative returns can cause the return value to be significant).

emscripten is more strict about void vs int returns, so we change everything to
return int.

Also f2py makes subroutines void. This is fixed in numpy patches.

diff --git a/scipy/_build_utils/_fortran.py b/scipy/_build_utils/_fortran.py
index 93ca908..038855b 100644
--- a/scipy/_build_utils/_fortran.py
+++ b/scipy/_build_utils/_fortran.py
@@ -79,7 +79,6 @@ def get_g77_abi_wrappers(info):
     else:
         wrapper_sources += [
             os.path.join(path, 'src', 'wrap_dummy_g77_abi.f'),
-            os.path.join(path, 'src', 'wrap_dummy_accelerate.f'),
         ]
     return wrapper_sources
 
diff --git a/scipy/cluster/cluster_blas.h b/scipy/cluster/cluster_blas.h
index 865e410..d5479e0 100644
--- a/scipy/cluster/cluster_blas.h
+++ b/scipy/cluster/cluster_blas.h
@@ -15,6 +15,8 @@
 #define F_FUNC(f,F) f##_
 #endif
 #endif
+extern int dgemm_(char *transa, char *transb, int *m, int *n, int *k, double *alpha, double *a, int *lda, double *b, int *ldb, double *beta, double *c, int *ldc);
+extern int sgemm_(char *transa, char *transb, int *m, int *n, int *k, float *alpha, float *a, int *lda, float *b, int *ldb, float *beta, float *c, int *ldc);
 
 #define f_sgemm F_FUNC(sgemm,SGEMM)
 #define f_dgemm F_FUNC(dgemm,DGEMM)
diff --git a/scipy/cluster/cluster_blas.pxd b/scipy/cluster/cluster_blas.pxd
index b71ce90..4fbf2ca 100644
--- a/scipy/cluster/cluster_blas.pxd
+++ b/scipy/cluster/cluster_blas.pxd
@@ -1,10 +1,10 @@
 cdef extern from "cluster_blas.h":
 
-    void f_sgemm(char *transA, char *transB, int *m, int *n, int *k,
+    int f_sgemm(char *transA, char *transB, int *m, int *n, int *k,
                  float *alpha, float *A, int *lda, float *B, int *ldb,
                  float *beta, float *C, int *ldc) nogil
 
-    void f_dgemm(char *transA, char *transB, int *m, int *n, int *k,
+    int f_dgemm(char *transA, char *transB, int *m, int *n, int *k,
                  double *alpha, double *A, int *lda, double *B, int *ldb,
                  double *beta, double *C, int *ldc) nogil
 
diff --git a/scipy/interpolate/blas_defs.h b/scipy/interpolate/blas_defs.h
index 0f95237..5a7adb7 100644
--- a/scipy/interpolate/blas_defs.h
+++ b/scipy/interpolate/blas_defs.h
@@ -16,4 +16,5 @@
 #endif
 #endif
 
+extern int dgeev_(char *jobvl, char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);
 #define c_dgeev F_FUNC(dgeev,DGEEV)
diff --git a/scipy/linalg/_cython_wrapper_generators.py b/scipy/linalg/_cython_wrapper_generators.py
index 62be001..efb7194 100644
--- a/scipy/linalg/_cython_wrapper_generators.py
+++ b/scipy/linalg/_cython_wrapper_generators.py
@@ -15,7 +15,9 @@ fortran_types = {'int': 'integer',
                  'char': 'character',
                  'bint': 'logical'}
 
-c_types = {'int': 'int',
+c_types = {'void':'int',
+        'VOID':'int',
+	   'int': 'int',
            'c': 'npy_complex64',
            'd': 'double',
            's': 'float',
@@ -37,7 +39,7 @@ def arg_names_and_types(args):
 
 pyx_func_template = """
 cdef extern from "{header_name}":
-    void _fortran_{name} "F_FUNC({name}wrp, {upname}WRP)"({ret_type} *out, {fort_args}) nogil
+    int _fortran_{name} "F_FUNC({name}wrp, {upname}WRP)"({ret_type} *out, {fort_args}) nogil
 cdef {ret_type} {name}({args}) nogil:
     cdef {ret_type} out
     _fortran_{name}(&out, {argnames})
@@ -58,8 +60,10 @@ def arg_casts(arg):
         return '<{0}*>'.format(arg)
     return ''
 
-
 def pyx_decl_func(name, ret_type, args, header_name):
+    # clapack returns double for single precision functions (why?)
+    if ret_type=='s':
+        ret_type='d'
     argtypes, argnames = arg_names_and_types(args)
     # Fix the case where one of the arguments has the same name as the
     # abbreviation for the argument type.
@@ -74,21 +78,42 @@ def pyx_decl_func(name, ret_type, args, header_name):
     argtypes = [npy_types.get(t, t) for t in argtypes]
     fort_args = ', '.join([' *'.join([n, t])
                            for n, t in zip(argtypes, argnames)])
+    unwrapper_argnames=",".join(argnames)
     argnames = [arg_casts(t) + n for n, t in zip(argnames, argtypes)]
     argnames = ', '.join(argnames)
     c_ret_type = c_types[ret_type]
     args = args.replace('lambda', 'lambda_')
-    return pyx_func_template.format(name=name, upname=name.upper(), args=args,
+    # CLAPACK handles strings c style i.e. by null termination
+    # these unwrappers remove the fortran style length arguments
+    # I think normally they'd be in the lapack already, but they aren't in 
+    # clapack
+    unwrapper=""
+    if name[0] in ['c', 's'] and not name in ['cdotu','cdotc','cladiv']:
+        extra_args=fort_args
+        num_extra=0
+        for c in argtypes:
+            if c=='char':
+                num_extra+=1
+                extra_args+=", int ignore_%d"%(num_extra)
+        unwrapper=pyx_clapack_unwrapper_template.format(name=name,extra_args=extra_args,argnames=unwrapper_argnames,args=fort_args,ret_type=c_ret_type)
+    return unwrapper+pyx_func_template.format(name=name, upname=name.upper(), args=args,
                                     fort_args=fort_args, ret_type=ret_type,
                                     c_ret_type=c_ret_type, argnames=argnames,
                                     header_name=header_name)
 
 pyx_sub_template = """cdef extern from "{header_name}":
-    void _fortran_{name} "F_FUNC({name},{upname})"({fort_args}) nogil
-cdef void {name}({args}) nogil:
+    int _fortran_{name} "F_FUNC({name},{upname})"({fort_args}) nogil
+cdef int {name}({args}) nogil:
     _fortran_{name}({argnames})
 """
 
+pyx_clapack_unwrapper_template= """
+
+cdef extern {ret_type} {name}_({args})
+
+cdef public {ret_type} w{name}_({extra_args}):
+    return {name}_({argnames});
+"""
 
 def pyx_decl_sub(name, args, header_name):
     argtypes, argnames = arg_names_and_types(args)
@@ -96,10 +121,24 @@ def pyx_decl_sub(name, args, header_name):
     argnames = [n if n not in ['lambda', 'in'] else n + '_' for n in argnames]
     fort_args = ', '.join([' *'.join([n, t])
                            for n, t in zip(argtypes, argnames)])
+    unwrapper_argnames=",".join(argnames)
     argnames = [arg_casts(t) + n for n, t in zip(argnames, argtypes)]
     argnames = ', '.join(argnames)
     args = args.replace('*lambda,', '*lambda_,').replace('*in,', '*in_,')
-    return pyx_sub_template.format(name=name, upname=name.upper(),
+    # CLAPACK handles strings c style i.e. by null termination
+    # these unwrappers remove the fortran style length arguments
+    # normally they'd be in the lapack already, but they aren't in 
+    # clapack
+    unwrapper=""
+    if name[0] in ['c', 's'] and not name in ['cdotu','cdotc','cladiv']:
+        extra_args=fort_args
+        num_extra=0
+        for c in argtypes:
+            if c=='char':
+                num_extra+=1
+                extra_args+=", int ignore_%d"%(num_extra)
+        unwrapper=pyx_clapack_unwrapper_template.format(name=name,extra_args=extra_args,argnames=unwrapper_argnames,args=fort_args,ret_type='int')
+    return unwrapper+ pyx_sub_template.format(name=name, upname=name.upper(),
                                    args=args, fort_args=fort_args,
                                    argnames=argnames, header_name=header_name)
 
@@ -452,6 +491,13 @@ pxd_template = """cdef {ret_type} {name}({args}) nogil
 
 def pxd_decl(name, ret_type, args):
     args = args.replace('lambda', 'lambda_').replace('*in,', '*in_,')
+    if ret_type=='void':
+        ret_type='int'
+    if ret_type=='float':
+        ret_type='double'
+    if ret_type=='s':
+        ret_type='d'
+        
     return pxd_template.format(name=name, ret_type=ret_type, args=args)
 
 blas_pxd_preamble = """# Within scipy, these wrappers can be used via relative or absolute cimport.
@@ -535,6 +581,8 @@ def process_fortran_name(name, funcname):
 
 
 def fort_subroutine_wrapper(name, ret_type, args):
+    if ret_type=='s':
+        ret_type='d'
     if name[0] in ['c', 's'] or name in ['zladiv', 'zdotu', 'zdotc']:
         wrapper = 'w' + name
     else:
@@ -559,16 +607,18 @@ def make_c_args(args):
     types = [c_types[arg] for arg in types]
     return ', '.join('{0} *{1}'.format(t, n) for t, n in zip(types, names))
 
-c_func_template = "void F_FUNC({name}wrp, {upname}WRP)({return_type} *ret, {args});\n"
+c_func_template = "int F_FUNC({name}wrp, {upname}WRP)({return_type} *ret, {args});\n"
 
 
 def c_func_decl(name, return_type, args):
+    if return_type=='s':
+        return_type='d'
     args = make_c_args(args)
     return_type = c_types[return_type]
     return c_func_template.format(name=name, upname=name.upper(),
                                   return_type=return_type, args=args)
 
-c_sub_template = "void F_FUNC({name},{upname})({args});\n"
+c_sub_template = "int F_FUNC({name},{upname})({args});\n"
 
 
 def c_sub_decl(name, return_type, args):
diff --git a/scipy/linalg/fblas_l1.pyf.src b/scipy/linalg/fblas_l1.pyf.src
index 5008ee8..6380740 100644
--- a/scipy/linalg/fblas_l1.pyf.src
+++ b/scipy/linalg/fblas_l1.pyf.src
@@ -252,14 +252,17 @@ end subroutine <prefix>axpy
 function sdot(n,x,offx,incx,y,offy,incy) result (xy)
   ! Computes a vector-vector dot product.
 
-  fortranname wsdot
+  callstatement sdot_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,float*,int*,float*,int*
+
+  fortranname F_FUNC(sdot,SDOT)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) sdot
 
-  callstatement (*f2py_func)(&sdot,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument float*,int*,float*,int*,float*,int*
 
   real dimension(*), intent(in) :: x
   real dimension(*), intent(in) :: y
-  real sdot,xy
+  double precision sdot,xy
   integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
   integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
   integer optional, intent(in),depend(x) :: offx=0
@@ -277,8 +280,12 @@ end function sdot
 function ddot(n,x,offx,incx,y,offy,incy) result (xy)
   ! Computes a vector-vector dot product.
 
-  callstatement (*f2py_func)(&ddot,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument double*,int*,double*,int*,double*,int*
+  callstatement ddot_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,double*,int*,double*,int*
+
+  fortranname F_FUNC(ddot,ddot)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) ddot
 
   double precision dimension(*), intent(in) :: x
   double precision dimension(*), intent(in) :: y
@@ -297,15 +304,19 @@ function ddot(n,x,offx,incx,y,offy,incy) result (xy)
 end function ddot
 
 
+// in CLAPACK, cdotu and zdotu are void and return by pointer (as can't return complex* without allocation)
 ! <prefix2c=c,z> <ftype2c=complex,double complex> <ctype2c=complex_float,complex_double>
 function <prefix2c>dotu(n,x,offx,incx,y,offy,incy) result(xy)
 
   <ftype2c> :: <prefix2c>dotu, xy
-  fortranname w<prefix2c>dotu
 
-  callstatement (*f2py_func)(&<prefix2c>dotu,&n,x+offx,&incx,y+offy,&incy)
+  callstatement (*f2py_func)(&<prefix2c>dotu_return_value,&n,x+offx,&incx,y+offy,&incy)
   callprotoargument <ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*
 
+  fortranname F_FUNC(<prefix2c>dotu,<C,Z>DOTU)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix2c>dotu
+
   <ftype2c> dimension(*),intent(in) :: x
   <ftype2c> dimension(*),intent(in) :: y
 
@@ -328,10 +339,12 @@ end function <prefix2c>dotu
 function <prefix2c>dotc(n,x,offx,incx,y,offy,incy) result(xy)
 
   <ftype2c> :: <prefix2c>dotc, xy
-  fortranname w<prefix2c>dotc
+  callstatement <prefix2c>dotc_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,<ctype2c>*,int*,<ctype2c>*,int*
 
-  callstatement (*f2py_func)(&<prefix2c>dotc,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument <ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*
+  fortranname F_FUNC(<prefix2c>dotc,<C,Z>DOTC)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix2c>dotc
 
   <ftype2c> dimension(*),intent(in) :: x
   <ftype2c> dimension(*),intent(in) :: y
@@ -354,11 +367,15 @@ end function <prefix2c>dotc
 ! <ftype3=real,complex> <ftypereal3=real,real>
 function <prefix3>nrm2(n,x,offx,incx) result(n2)
 
-  fortranname w<prefix3>nrm2
-  <ftypereal3> <prefix3>nrm2, n2
+  <ftypereal3> nm2
+  double precision <prefix3>nrm2
 
-  callstatement (*f2py_func)(&<prefix3>nrm2, &n,x+offx,&incx)
-  callprotoargument <ctypereal3>*,int*,<ctype3>*,int*
+  callstatement <prefix3>nrm2_return_value=(*f2py_func)( &n,x+offx,&incx)
+  callprotoargument int*,<ctype3>*,int*
+
+  fortranname F_FUNC(<prefix3>nrm2,<S,SC>NRM2)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix3>nrm2
 
   <ftype3> dimension(*),intent(in) :: x
 
@@ -378,10 +395,15 @@ end function <prefix3>nrm2
 ! <ftypereal4=double precision,double precision>
 function <prefix4>nrm2(n,x,offx,incx) result(n2)
 
-  <ftypereal4> <prefix4>nrm2, n2
+  callstatement <prefix4>nrm2_return_value=(*f2py_func)(&n,x+offx,&incx)
+  callprotoargument int*,<ctype4>*,int*
+
+  double precision <prefix4>nrm2
+  <ftype4> n2
+  fortranname F_FUNC(<prefix4>nrm2,<S,D>NRM2)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix4>nrm2
 
-  callstatement (*f2py_func)(&<prefix4>nrm2, &n,x+offx,&incx)
-  callprotoargument <ctypereal4>*,int*,<ctype4>*,int*
 
   <ftype4> dimension(*),intent(in) :: x
 
@@ -396,16 +418,20 @@ function <prefix4>nrm2(n,x,offx,incx) result(n2)
 end function <prefix4>nrm2
 
 
-function <prefix3>asum(n,x,offx,incx) result (s)
+function <prefix3>asum(n,x,offx,incx) result (d)
   ! Computes the sum of magnitudes of the vector elements
 
-  fortranname w<prefix3>asum
+  callstatement <prefix3>asum_return_value=(*f2py_func)(&n,x+offx,&incx)
+  callprotoargument int*,<ctype3>*,int*
 
-  callstatement (*f2py_func)(&<prefix3>asum,&n,x+offx,&incx)
-  callprotoargument <ctypereal3>*,int*,<ctype3>*,int*
+  double precision <prefix3>asum
+  fortranname F_FUNC(<prefix3>asum,<S,SC>ASUM)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix3>asum
 
   <ftype3> dimension(*), intent(in) :: x
-  <ftypereal3> <prefix3>asum,s
+  <ftypereal3> s
+  double precision <prefix3>asum
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
   integer optional, intent(in), depend(x) :: offx=0
   check(offx>=0 && offx<len(x)) :: offx
@@ -415,11 +441,16 @@ function <prefix3>asum(n,x,offx,incx) result (s)
 end function <prefix3>asum
 
 
-function <prefix4>asum(n,x,offx,incx) result (s)
+function <prefix4>asum(n,x,offx,incx) result (d)
   ! Computes the sum of magnitudes of the vector elements
 
-  callstatement (*f2py_func)(&<prefix4>asum,&n,x+offx,&incx)
-  callprotoargument <ctypereal4>*,int*,<ctype4>*,int*
+  callstatement <prefix4>asum_return_value=(*f2py_func)(&n,x+offx,&incx) 
+  callprotoargument int*,<ctype4>*,int*
+
+  <ftype4> <prefix4>asum
+  fortranname F_FUNC(<prefix4>asum,<D,Z>ASUM)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix4>asum
 
   <ftype4> dimension(*), intent(in) :: x
   <ftypereal4> <prefix4>asum,s
@@ -438,9 +469,9 @@ function i<prefix>amax(n,x,offx,incx) result(k)
   callstatement i<prefix>amax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
   callprotoargument int*,<ctype>*,int*
 
-  ! This is to avoid Fortran wrappers.
+  ! This is to avoid Fortran wrappers - fix for CLAPACK
   integer i<prefix>amax,k
-  fortranname F_FUNC(i<prefix>amax,I<S,D,C,Z>AMAX)
+  fortranname F_FUNC(i<prefix>amax,I<D,DZ>AMAX)
   intent(c) i<prefix>amax
   <ftype> dimension(*), intent(in) :: x
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
diff --git a/scipy/linalg/flapack.pyf.src b/scipy/linalg/flapack.pyf.src
index fd7c8ac..afbd956 100644
--- a/scipy/linalg/flapack.pyf.src
+++ b/scipy/linalg/flapack.pyf.src
@@ -2344,7 +2344,15 @@ end subroutine <prefix2c>hbevx
 !          rmax  = overflow threshold  - (base**emax)*(1-eps)
 function dlamch(cmach)
     character :: cmach
-    double precision intent(out):: dlamch
+    double precision:: dlamch
+    callstatement dlamch_return_value=(*f2py_func)(cmach)
+    callprotoargument char*
+
+    fortranname F_FUNC(dlamch,DLAMCH)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) dlamch
+
+
 end function dlamch
 
 function slamch(cmach)
@@ -2824,9 +2832,12 @@ function <prefix2>lange(norm,m,n,a,lda,work) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a real matrix A.
     <ftype2> <prefix2>lange, n2
-    fortranname <wrap2>lange
-    callstatement (*f2py_func)(&<prefix2>lange,norm,&m,&n,a,&m,work)
-    callprotoargument <ctype2>*,char*,int*,int*,<ctype2>*,int*,<ctype2>*
+    callstatement <prefix2>lange_return_value=(*f2py_func)(norm,&m,&n,a,&m,work)
+    callprotoargument char*,int*,int*,<ctype2>*,int*,<ctype2>*
+
+    fortranname F_FUNC(<prefix2>lange,<S,D>LANGE)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) <prefix2>lange
 
     character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
     integer intent(hide),depend(a,n) :: m = shape(a,0)
@@ -2840,9 +2851,13 @@ function <prefix2c>lange(norm,m,n,a,lda,work) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a complex matrix A.
     <ftype2> <prefix2c>lange, n2
-    fortranname <wrap2c>lange
-    callstatement (*f2py_func)(&<prefix2c>lange,norm,&m,&n,a,&m,work)
-    callprotoargument <ctype2>*,char*,int*,int*,<ctype2c>*,int*,<ctype2>*
+
+    callstatement <prefix2c>lange_return_value=(*f2py_func)(&norm,&m,&n,a,&m,work)
+    callprotoargument char*,int*,int*,<ctype2c>*,int*,<ctype2>*
+
+    fortranname F_FUNC(<prefix2c>lange,<C,Z>LANGE)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) <prefix2c>lange
 
     character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
     integer intent(hide),depend(a,n) :: m = shape(a,0)
diff --git a/scipy/linalg/setup.py b/scipy/linalg/setup.py
index 8084aa8..5408c79 100755
--- a/scipy/linalg/setup.py
+++ b/scipy/linalg/setup.py
@@ -44,9 +44,10 @@ def configuration(parent_package='', top_path=None):
     # flapack:
     sources = ['flapack.pyf.src']
     sources += get_g77_abi_wrappers(lapack_opt)
-    dep_pfx = join('src', 'lapack_deprecations')
-    deprecated_lapack_routines = [join(dep_pfx, c + 'gegv.f') for c in 'cdsz']
-    sources += deprecated_lapack_routines
+#   CLAPACK still has these routines (with conflicting signatures)
+#    dep_pfx = join('src', 'lapack_deprecations')
+#    deprecated_lapack_routines = [join(dep_pfx, c + 'gegv.f') for c in 'cdsz']
+#    sources += deprecated_lapack_routines
 
     config.add_extension('_flapack',
                          sources=sources,
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
index e17532d..a7a5629 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
@@ -80,9 +80,6 @@ cgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     int    kase, kase1, onenrm, i;
     float ainvnm;
     complex *work;
-    extern int crscl_(int *, complex *, complex *, int *);
-
-    extern int clacon_(int *, complex *, complex *, float *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
index db31e35..1da9ac0 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
@@ -92,7 +92,6 @@ cgsequ(SuperMatrix *A, float *r, float *c, float *rowcnd,
     int i, j, irow;
     float rcmin, rcmax;
     float bignum, smlnum;
-    extern float slamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
index e7c2bc7..0dde69b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
@@ -158,14 +158,6 @@ cgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     float   *rwork;
     int      *iwork;
 
-    extern int clacon_(int *, complex *, complex *, float *, int *);
-#ifdef _CRAY
-    extern int CCOPY(int *, complex *, int *, complex *, int *);
-    extern int CSAXPY(int *, complex *, complex *, int *, complex *, int *);
-#else
-    extern int ccopy_(int *, complex *, int *, complex *, int *);
-    extern int caxpy_(int *, complex *, complex *, int *, complex *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
index d206d5a..8e64576 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
@@ -85,9 +85,6 @@ clacon_(int *n, complex *v, complex *x, float *est, int *kase)
     static int i, j;
     float temp;
     float safmin;
-    extern float slamch_(char *);
-    extern int icmax1_(int *, complex *, int *);
-    extern double scsum1_(int *, complex *, int *);
 
     safmin = slamch_("Safe minimum");
     if ( *kase == 0 ) {
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
index d91474a..f33f10d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
@@ -81,9 +81,6 @@ dgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     double ainvnm;
     double *work;
     int    *iwork;
-    extern int drscl_(int *, double *, double *, int *);
-
-    extern int dlacon_(int *, double *, double *, int *, double *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
index 73870d4..222bf66 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
@@ -92,7 +92,6 @@ dgsequ(SuperMatrix *A, double *r, double *c, double *rowcnd,
     int i, j, irow;
     double rcmin, rcmax;
     double bignum, smlnum;
-    extern double dlamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
index 55531b0..792509c 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
@@ -158,14 +158,6 @@ dgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     double   *rwork;
     int      *iwork;
 
-    extern int dlacon_(int *, double *, double *, int *, double *, int *);
-#ifdef _CRAY
-    extern int SCOPY(int *, double *, int *, double *, int *);
-    extern int SSAXPY(int *, double *, double *, int *, double *, int *);
-#else
-    extern int dcopy_(int *, double *, int *, double *, int *);
-    extern int daxpy_(int *, double *, double *, int *, double *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
index 951fe7a..7359570 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
@@ -80,15 +80,6 @@ dlacon_(int *n, double *v, double *x, int *isgn, double *est, int *kase)
     static double altsgn, estold;
     static int i, j;
     double temp;
-#ifdef _CRAY
-    extern int ISAMAX(int *, double *, int *);
-    extern double SASUM(int *, double *, int *);
-    extern int SCOPY(int *, double *, int *, double *, int *);
-#else
-    extern int idamax_(int *, double *, int *);
-    extern double dasum_(int *, double *, int *);
-    extern int dcopy_(int *, double *, int *, double *, int *);
-#endif
 #define d_sign(a, b) (b >= 0 ? fabs(a) : -fabs(a))    /* Copy sign */
 #define i_dnnt(a) \
 	( a>=0 ? floor(a+.5) : -floor(.5-a) ) /* Round to nearest integer */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
index e117915..28ffdbb 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
@@ -76,10 +76,7 @@ double dlamch_(char *cmach)
     static int imin, imax;
     static int lrnd;
     static double rmin, rmax, t, rmach;
-    extern int lsame_(char *, char *);
     static double small, sfmin;
-    extern /* Subroutine */ int dlamc2_(int *, int *, int *, 
-	    double *, int *, double *, int *, double *);
     static int it;
     static double rnd, eps;
 
@@ -197,7 +194,6 @@ int dlamc1_(int *beta, int *t, int *rnd, int
     static double a, b, c, f;
     static int lbeta;
     static double savec;
-    extern double dlamc3_(double *, double *);
     static int lieee1;
     static double t1, t2;
     static int lt;
@@ -435,13 +431,7 @@ int dlamc2_(int *beta, int *t, int *rnd,
     static double small;
     static int gpmin;
     static double third, lrmin, lrmax, sixth;
-    extern /* Subroutine */ int dlamc1_(int *, int *, int *, 
-	    int *);
-    extern double dlamc3_(double *, double *);
     static int lieee1;
-    extern /* Subroutine */ int dlamc4_(int *, double *, int *), 
-	    dlamc5_(int *, int *, int *, int *, int *, 
-	    double *);
     static int lt, ngnmin, ngpmin;
     static double one, two;
 
@@ -725,7 +715,6 @@ int dlamc4_(int *emin, double *start, int *base)
     static double zero, a;
     static int i;
     static double rbase, b1, b2, c1, c2, d1, d2;
-    extern double dlamc3_(double *, double *);
     static double one;
 
     a = *start;
@@ -840,7 +829,6 @@ int dlamc5_(int *beta, int *p, int *emin,
     static int uexp, i;
     static double y, z;
     static int nbits;
-    extern double dlamc3_(double *, double *);
     static double recbas;
     static int exbits, expsum, try__;
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
index 5a7203d..0ac71c0 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
@@ -16,10 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void ccopy_(int *, complex [], int *, complex [], int *);
-#if SCIPY_FIX
-extern double dlamch_(char *);
-#endif
 
 #if 0
 static complex *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
index 44173c8..fa1b999 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_cdefs.h"
 
-extern void cswap_(int *, complex [], int *, complex [], int *);
-extern void caxpy_(int *, complex *, complex [], int *, complex [], int *);
-extern void ccopy_(int *, complex [], int *, complex [], int *);
-extern float scasum_(int *, complex *, int *);
-extern float scnrm2_(int *, complex *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int icamax_(int *, complex [], int *);
 
 static float *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
index e9162a7..22eae38 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
@@ -16,7 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void dcopy_(int *, double [], int *, double [], int *);
 
 #if 0
 static double *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
index a08c85c..3174de3 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_ddefs.h"
 
-extern void dswap_(int *, double [], int *, double [], int *);
-extern void daxpy_(int *, double *, double [], int *, double [], int *);
-extern void dcopy_(int *, double [], int *, double [], int *);
-extern double dasum_(int *, double *, int *);
-extern double dnrm2_(int *, double *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int idamax_(int *, double [], int *);
 
 static double *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
index b9fd387..eee65c8 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
@@ -16,10 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void scopy_(int *, float [], int *, float [], int *);
-#if SCIPY_FIX
-extern double dlamch_(char *);
-#endif
 
 #if 0
 static float *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
index 108f849..7ce483d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_sdefs.h"
 
-extern void sswap_(int *, float [], int *, float [], int *);
-extern void saxpy_(int *, float *, float [], int *, float [], int *);
-extern void scopy_(int *, float [], int *, float [], int *);
-extern float sasum_(int *, float *, int *);
-extern float snrm2_(int *, float *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int isamax_(int *, float [], int *);
 
 static float *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
index ddf3a63..cef2341 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
@@ -16,7 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void zcopy_(int *, doublecomplex [], int *, doublecomplex [], int *);
 
 #if 0
 static doublecomplex *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
index 0a140d4..2207950 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_zdefs.h"
 
-extern void zswap_(int *, doublecomplex [], int *, doublecomplex [], int *);
-extern void zaxpy_(int *, doublecomplex *, doublecomplex [], int *, doublecomplex [], int *);
-extern void zcopy_(int *, doublecomplex [], int *, doublecomplex [], int *);
-extern double dzasum_(int *, doublecomplex *, int *);
-extern double dznrm2_(int *, doublecomplex *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int izamax_(int *, doublecomplex [], int *);
 
 static double *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
index 5afc93b..1a2c4ca 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
@@ -3,6 +3,14 @@
 
 #include <stdlib.h>
 
+#include"f2c.h"
+#define integer int
+#define logical int
+#include"clapack.h"
+#undef integer
+#undef logical
+
+
 /*
  * Support routines
  */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
index a474967..ae4a511 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
@@ -81,9 +81,6 @@ sgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     float ainvnm;
     float *work;
     int    *iwork;
-    extern int srscl_(int *, float *, float *, int *);
-
-    extern int slacon_(int *, float *, float *, int *, float *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
index 3637d7e..cf435db 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
@@ -92,7 +92,6 @@ sgsequ(SuperMatrix *A, float *r, float *c, float *rowcnd,
     int i, j, irow;
     float rcmin, rcmax;
     float bignum, smlnum;
-    extern float slamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
index a93bc5b..c685106 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
@@ -158,14 +158,6 @@ sgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     float   *rwork;
     int      *iwork;
 
-    extern int slacon_(int *, float *, float *, int *, float *, int *);
-#ifdef _CRAY
-    extern int SCOPY(int *, float *, int *, float *, int *);
-    extern int SSAXPY(int *, float *, float *, int *, float *, int *);
-#else
-    extern int scopy_(int *, float *, int *, float *, int *);
-    extern int saxpy_(int *, float *, float *, int *, float *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
index d33ca33..212ac4b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
@@ -11,6 +11,8 @@
  */
 #include "slu_sdefs.h"
 
+extern float slangs(char *, SuperMatrix *);
+
 /*! \brief
  *
  * <pre>
@@ -357,8 +359,6 @@ sgssvx(superlu_options_t *options, SuperMatrix *A, int *perm_c, int *perm_r,
     double    t0;      /* temporary time */
     double    *utime;
 
-    /* External functions */
-    extern float slangs(char *, SuperMatrix *);
 
     Bstore = B->Store;
     Xstore = X->Store;
@@ -552,7 +552,9 @@ printf("dgssvx: Fact=%4d, Trans=%4d, equed=%c\n",
         } else {
 	    *(unsigned char *)norm = 'I';
         }
-        anorm = slangs(norm, AA);
+        anorm = slangs(norm, AA);    /* External functions */
+        extern float slangs(char *, SuperMatrix *);
+
         sgscon(norm, L, U, anorm, rcond, stat, info);
         utime[RCOND] = SuperLU_timer_() - t0;
     }
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
index 4e02fdc..d49f040 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
@@ -80,15 +80,6 @@ slacon_(int *n, float *v, float *x, int *isgn, float *est, int *kase)
     static float altsgn, estold;
     static int i, j;
     float temp;
-#ifdef _CRAY
-    extern int ISAMAX(int *, float *, int *);
-    extern float SASUM(int *, float *, int *);
-    extern int SCOPY(int *, float *, int *, float *, int *);
-#else
-    extern int isamax_(int *, float *, int *);
-    extern float sasum_(int *, float *, int *);
-    extern int scopy_(int *, float *, int *, float *, int *);
-#endif
 #define d_sign(a, b) (b >= 0 ? fabs(a) : -fabs(a))    /* Copy sign */
 #define i_dnnt(a) \
 	( a>=0 ? floor(a+.5) : -floor(.5-a) ) /* Round to nearest integer */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
index 09cf6e2..3155468 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
@@ -58,7 +58,7 @@
    ===================================================================== 
 </pre>
 */
-float slamch_(char *cmach)
+doublereal slamch_(char *cmach)
 {
 /* >>Start of File<<   
        Initialized data */
@@ -75,10 +75,7 @@ float slamch_(char *cmach)
     static int imin, imax;
     static int lrnd;
     static float rmin, rmax, t, rmach;
-    extern int lsame_(char *, char *);
     static float small, sfmin;
-    extern /* Subroutine */ int slamc2_(int *, int *, int *, float 
-	    *, int *, float *, int *, float *);
     static int it;
     static float rnd, eps;
 
@@ -205,7 +202,6 @@ int slamc1_(int *beta, int *t, int *rnd, int
     static float savec;
     static int lieee1;
     static float t1, t2;
-    extern double slamc3_(float *, float *);
     static int lt;
     static float one, qtr;
 
@@ -443,12 +439,6 @@ int slamc2_(int *beta, int *t, int *rnd, float *
     static int gpmin;
     static float third, lrmin, lrmax, sixth;
     static int lieee1;
-    extern /* Subroutine */ int slamc1_(int *, int *, int *, 
-	    int *);
-    extern double slamc3_(float *, float *);
-    extern /* Subroutine */ int slamc4_(int *, float *, int *), 
-	    slamc5_(int *, int *, int *, int *, int *, 
-	    float *);
     static int lt, ngnmin, ngpmin;
     static float one, two;
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
index acb82bc..c9d0946 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
@@ -13,8 +13,8 @@
 
 extern int_t mc64id_(int_t*);
 extern int_t mc64ad_(int_t*, int_t*, int_t*, int_t [], int_t [], double [],
-		    int_t*, int_t [], int_t*, int_t[], int_t*, double [],
-		    int_t [], int_t []);
+            int_t*, int_t [], int_t*, int_t[], int_t*, double [],
+            int_t [], int_t []);
 
 /*! \brief
  *
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
index 24d1374..cea93d6 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
@@ -236,7 +236,6 @@ extern int     sp_cgemv (char *, complex, SuperMatrix *, complex *,
 extern int     sp_cgemm (char *, char *, int, int, int, complex,
 			SuperMatrix *, complex *, int, complex, 
 			complex *, int);
-extern         float slamch_(char *);
 
 
 /*! \brief Memory-related */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
index 386ad68..72f5355 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
@@ -18,7 +18,10 @@
 #ifndef DCOMPLEX_INCLUDE
 #define DCOMPLEX_INCLUDE
 
-typedef struct { double r, i; } doublecomplex;
+#include"scipy_slu_config.h"
+
+// defined in clapack
+//typedef struct { double r, i; } doublecomplex;
 
 
 /* Macro definitions */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
index c17490d..fef343d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
@@ -17,8 +17,9 @@
 
 #ifndef SCOMPLEX_INCLUDE
 #define SCOMPLEX_INCLUDE
-
-typedef struct { float r, i; } complex;
+#include"scipy_slu_config.h"
+// defined in  CLAPACK
+//typedef struct { float r, i; } complex;
 
 
 /* Macro definitions */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
index 745d76f..0c2a45b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
@@ -235,7 +235,6 @@ extern int     sp_sgemv (char *, float, SuperMatrix *, float *,
 extern int     sp_sgemm (char *, char *, int, int, int, float,
 			SuperMatrix *, float *, int, float, 
 			float *, int);
-extern         float slamch_(char *);
 
 
 /*! \brief Memory-related */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
index f41b4ca..1560371 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
@@ -348,8 +348,6 @@ extern int     spcoletree (int *, int *, int *, int, int, int *);
 extern int     *TreePostorder (int, int *);
 extern double  SuperLU_timer_ ();
 extern int     sp_ienv (int);
-extern int     lsame_ (char *, char *);
-extern int     xerbla_ (char *, int *);
 extern void    ifill (int *, int, int);
 extern void    snode_profile (int, int *);
 extern void    super_stats (int, int *);
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
index 8bb95aa..8b6651d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
@@ -80,9 +80,6 @@ zgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     int    kase, kase1, onenrm, i;
     double ainvnm;
     doublecomplex *work;
-    extern int zrscl_(int *, doublecomplex *, doublecomplex *, int *);
-
-    extern int zlacon_(int *, doublecomplex *, doublecomplex *, double *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
index 657637d..b04e46f 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
@@ -92,7 +92,6 @@ zgsequ(SuperMatrix *A, double *r, double *c, double *rowcnd,
     int i, j, irow;
     double rcmin, rcmax;
     double bignum, smlnum;
-    extern double dlamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
index 2ed0481..110bfe1 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
@@ -158,14 +158,6 @@ zgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     double   *rwork;
     int      *iwork;
 
-    extern int zlacon_(int *, doublecomplex *, doublecomplex *, double *, int *);
-#ifdef _CRAY
-    extern int CCOPY(int *, doublecomplex *, int *, doublecomplex *, int *);
-    extern int CSAXPY(int *, doublecomplex *, doublecomplex *, int *, doublecomplex *, int *);
-#else
-    extern int zcopy_(int *, doublecomplex *, int *, doublecomplex *, int *);
-    extern int zaxpy_(int *, doublecomplex *, doublecomplex *, int *, doublecomplex *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
index b2cd1ed..6934f1e 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
@@ -85,9 +85,6 @@ zlacon_(int *n, doublecomplex *v, doublecomplex *x, double *est, int *kase)
     static int i, j;
     double temp;
     double safmin;
-    extern double dlamch_(char *);
-    extern int izmax1_(int *, doublecomplex *, int *);
-    extern double dzsum1_(int *, doublecomplex *, int *);
 
     safmin = dlamch_("Safe minimum");
     if ( *kase == 0 ) {
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/scipychanges.patch b/before/scipy/sparse/linalg/dsolve/SuperLU/scipychanges.patch
deleted file mode 100644
index 7a0a3ba..0000000
--- a/scipy/sparse/linalg/dsolve/SuperLU/scipychanges.patch
+++ /dev/null
@@ -1,378 +0,0 @@
-    ENH: sparse/dsolve: re-apply patches on top of SuperLU 4.3
-
-    - Hook up USER_* routines to Scipy
-
-    - Fix a dubious format string
-
-    - Sprinkle volatile into dlamc/slamc implementation to avoid an infinite loop
-
-    - Eliminate a crash for singular matrices for which pivoting fails
-
-    - Do not exit(1) when ILU decomposition encounters singularity;
-      instead call ABORT (which is hooked up in Scipy)
-
-    - Add missing declarations of dlamch_ (call without declaration to
-      functions returning floating point can cause NaN to appear later on, on i386).
-
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
-index a14ea72..f60c4dc 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
-@@ -125,7 +125,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
-index 678ac35..e117915 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
-@@ -673,9 +673,13 @@ double dlamc3_(double *a, double *b)
- {
- /* >>Start of File<<   
-        System generated locals */
--    double ret_val;
-+    volatile double ret_val;
-+    volatile double x;
-+    volatile double y;
- 
--    ret_val = *a + *b;
-+    x = *a;
-+    y = *b;
-+    ret_val = x + y;
- 
-     return ret_val;
- 
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c
-index bcfa96d..6a66068 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c
-@@ -124,7 +124,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
-index b6b0328..5a7203d 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
-@@ -17,6 +17,9 @@ int num_drop_U;
- #endif
- 
- extern void ccopy_(int *, complex [], int *, complex [], int *);
-+#if SCIPY_FIX
-+extern double dlamch_(char *);
-+#endif
- 
- #if 0
- static complex *A;  /* used in _compare_ only */
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c
-index d806485..98991d7 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c
-@@ -136,9 +136,13 @@ ilu_cpivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -151,9 +155,13 @@ ilu_cpivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c
-index 33c316d..0cbb21d 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c
-@@ -134,9 +134,13 @@ ilu_dpivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -149,9 +153,13 @@ ilu_dpivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
-index 7e0e97c..b9fd387 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
-@@ -17,6 +17,9 @@ int num_drop_U;
- #endif
- 
- extern void scopy_(int *, float [], int *, float [], int *);
-+#if SCIPY_FIX
-+extern double dlamch_(char *);
-+#endif
- 
- #if 0
- static float *A;  /* used in _compare_ only */
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c
-index 25b6b00..ff36657 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c
-@@ -134,9 +134,13 @@ ilu_spivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -149,9 +153,13 @@ ilu_spivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c
-index dafea2b..4ea86b1 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c
-@@ -136,9 +136,13 @@ ilu_zpivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -151,9 +155,13 @@ ilu_zpivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
-new file mode 100644
-index 0000000..5afc93b
---- /dev/null
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
-@@ -0,0 +1,36 @@
-+#ifndef SCIPY_SLU_CONFIG_H
-+#define SCIPY_SLU_CONFIG_H
-+
-+#include <stdlib.h>
-+
-+/*
-+ * Support routines
-+ */
-+void superlu_python_module_abort(char *msg);
-+void *superlu_python_module_malloc(size_t size);
-+void superlu_python_module_free(void *ptr);
-+
-+#define USER_ABORT  superlu_python_module_abort
-+#define USER_MALLOC superlu_python_module_malloc
-+#define USER_FREE   superlu_python_module_free
-+
-+#define SCIPY_FIX 1
-+
-+/*
-+ * Fortran configuration
-+ */
-+#if defined(NO_APPEND_FORTRAN)
-+#if defined(UPPERCASE_FORTRAN)
-+#define UpCase 1
-+#else
-+#define NoChange 1
-+#endif
-+#else
-+#if defined(UPPERCASE_FORTRAN)
-+#error Uppercase and trailing slash in Fortran names not supported
-+#else
-+#define Add_ 1
-+#endif
-+#endif
-+
-+#endif
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
-index ec3cd61..09cf6e2 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
-@@ -684,11 +684,13 @@ double slamc3_(float *a, float *b)
- 
- /* >>Start of File<<   
-        System generated locals */
--    float ret_val;
--
--
-+    volatile float ret_val;
-+    volatile float x;
-+    volatile float y;
- 
--    ret_val = *a + *b;
-+    x = *a;
-+    y = *b;
-+    ret_val = x + y;
- 
-     return ret_val;
- 
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h
-index 7bcd1bc..80b8aa1 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h
-@@ -19,6 +19,7 @@
- #ifndef __SUPERLU_CNAMES /* allow multiple inclusions */
- #define __SUPERLU_CNAMES
- 
-+#include "scipy_slu_config.h"
- 
- #define ADD_       0
- #define ADD__      1
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
-index 30b5f9b..f41b4ca 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
-@@ -22,6 +22,8 @@
- #include <assert.h>
- #include "superlu_enum_consts.h"
- 
-+#include "scipy_slu_config.h"
-+
- /***********************************************************************
-  * Macros
-  ***********************************************************************/
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c
-index 2a6950c..a9f0de5 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c
-@@ -124,7 +124,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c
-index 858fbbc..4c19e77 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c
-@@ -29,7 +29,7 @@
- 
- void superlu_abort_and_exit(char* msg)
- {
--    fprintf(stderr, msg);
-+    fprintf(stderr, "%s\n", msg);
-     exit (-1);
- }
- 
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c
-index ce4f513..e134896 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c
-@@ -125,7 +125,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
diff --git a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
index 5eb0bb1..03fb23d 100644
--- a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
+++ b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
@@ -1,16 +1,16 @@
-c
+
 c\SCCS Information: @(#) 
 c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
 c
 c     %---------------------------------%
 c     | See debug.doc for documentation |
 c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c      integer  logfil, ndigit, mgetv0,
+c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c      common /debug/ 
+c     &         logfil, ndigit, mgetv0,
+c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
diff --git a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
index 66a8e9f..1f2d49c 100644
--- a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
+++ b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
@@ -5,17 +5,17 @@ c
 c\SCCS Information: @(#) 
 c FILE: stat.h   SID: 2.2   DATE OF SID: 11/16/95   RELEASE: 2 
 c
-      real       t0, t1, t2, t3, t4, t5
-      save       t0, t1, t2, t3, t4, t5
+c      real       t0, t1, t2, t3, t4, t5
+c      save       t0, t1, t2, t3, t4, t5
 c
-      integer    nopx, nbx, nrorth, nitref, nrstrt
-      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
-      common /timing/ 
-     &           nopx, nbx, nrorth, nitref, nrstrt,
-     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
+c      integer    nopx, nbx, nrorth, nitref, nrstrt
+c      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
+c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
+c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
+c     &           tmvopx, tmvbx, tgetv0, titref, trvec
+c      common /timing/ 
+c     &           nopx, nbx, nrorth, nitref, nrstrt,
+c     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
+c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
+c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
+c     &           tmvopx, tmvbx, tgetv0, titref, trvec
diff --git a/scipy/spatial/qhull_blas.h b/scipy/spatial/qhull_blas.h
index 2e235db..666630e 100644
--- a/scipy/spatial/qhull_blas.h
+++ b/scipy/spatial/qhull_blas.h
@@ -16,6 +16,10 @@
 #endif
 #endif
 
+int dgetrs_(char *trans, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);
+int dgetrf_(int *m, int *n, double *a, int *lda, int *ipiv, int *info);
+int dgecon_(char *norm, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);
+
 #define qh_dgetrf F_FUNC(dgetrf,DGETRF)
 #define qh_dgecon F_FUNC(dgecon,DGECON)
 #define qh_dgetrs F_FUNC(dgetrs,DGETRS)
diff --git a/scipy/special/amos/.master.gz b/before/scipy/special/amos/.master.gz
deleted file mode 100644
index 8cd34d4..0000000
--- a/scipy/special/amos/.master.gz
+++ /dev/null
@@ -1,2 +0,0 @@
- ?-eN0E+P
-)T*.	9e ZB vtu4E`PcHh&8]|<YcuA-fobcZ^H>clyW#SRUM].dDW_pz*$_3-!E<O&O<Koejek$W49j^XSB zL  
\ No newline at end of file
diff --git a/scipy/special/lapack_defs.h b/scipy/special/lapack_defs.h
index fb8fd80..d84cd3f 100644
--- a/scipy/special/lapack_defs.h
+++ b/scipy/special/lapack_defs.h
@@ -16,5 +16,6 @@
 #endif
 #endif
 
+int dstevr_(char *jobz, char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);
 #define c_dstevr F_FUNC(dstevr,DSTEVR)
 
diff --git a/scipy/special/specfun_wrappers.c b/scipy/special/specfun_wrappers.c
index 8772dd1..8850496 100644
--- a/scipy/special/specfun_wrappers.c
+++ b/scipy/special/specfun_wrappers.c
@@ -35,6 +35,7 @@ extern void F_FUNC(chgu,CHGU)(double*,double*,double*,double*,int*);
 extern void F_FUNC(itairy,ITAIRY)(double*,double*,double*,double*,double*);
 extern void F_FUNC(e1xb,E1XB)(double*,double*);
 extern void F_FUNC(e1z,E1Z)(npy_cdouble*,npy_cdouble*);
+extern void F_FUNC(eixz,E1Z)(npy_cdouble*,npy_cdouble*);
 extern void F_FUNC(eix,EIX)(double*,double*);
 extern void F_FUNC(cerror,CERROR)(npy_cdouble*,npy_cdouble*);
 extern void F_FUNC(stvh0,STVH0)(double*,double*);
