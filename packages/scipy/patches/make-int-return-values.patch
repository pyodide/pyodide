The return values of f2c functions are insignificant in most cases, so often it
is treated as returning void, when it really should return int (values are
"returned" by writing to pointers passed as an argument, but an obscure feature
known as alternative returns can cause the return value to be significant).

There's a big change to scipy/linalg/_cython_wrapper_generators.py, which is
called on build to generate python wrappers for lapack and BLAS. The change
makes everything call direct to CLAPACK with the correct function signatures
and also fixes some fortran -> c linking oddities that occur because f2py assumes
different function signatures to f2c, which in turn creates different function 
signatures compared to what has been done in CLAPACK. 

f2py is patched in numpy to make subroutines return int.

emscripten is very strict about void vs int returns and function signatures, so we change everything to
return int from subroutines, and signatures are altered to be consistent.


diff --git a/scipy/_build_utils/_fortran.py b/scipy/_build_utils/_fortran.py
index 93ca908..038855b 100644
--- a/scipy/_build_utils/_fortran.py
+++ b/scipy/_build_utils/_fortran.py
@@ -79,7 +79,6 @@ def get_g77_abi_wrappers(info):
     else:
         wrapper_sources += [
             os.path.join(path, 'src', 'wrap_dummy_g77_abi.f'),
-            os.path.join(path, 'src', 'wrap_dummy_accelerate.f'),
         ]
     return wrapper_sources
 
diff --git a/scipy/cluster/cluster_blas.h b/scipy/cluster/cluster_blas.h
index 865e410..d5479e0 100644
--- a/scipy/cluster/cluster_blas.h
+++ b/scipy/cluster/cluster_blas.h
@@ -15,6 +15,8 @@
 #define F_FUNC(f,F) f##_
 #endif
 #endif
+extern int dgemm_(char *transa, char *transb, int *m, int *n, int *k, double *alpha, double *a, int *lda, double *b, int *ldb, double *beta, double *c, int *ldc);
+extern int sgemm_(char *transa, char *transb, int *m, int *n, int *k, float *alpha, float *a, int *lda, float *b, int *ldb, float *beta, float *c, int *ldc);
 
 #define f_sgemm F_FUNC(sgemm,SGEMM)
 #define f_dgemm F_FUNC(dgemm,DGEMM)
diff --git a/scipy/cluster/cluster_blas.pxd b/scipy/cluster/cluster_blas.pxd
index b71ce90..4fbf2ca 100644
--- a/scipy/cluster/cluster_blas.pxd
+++ b/scipy/cluster/cluster_blas.pxd
@@ -1,10 +1,10 @@
 cdef extern from "cluster_blas.h":
 
-    void f_sgemm(char *transA, char *transB, int *m, int *n, int *k,
+    int f_sgemm(char *transA, char *transB, int *m, int *n, int *k,
                  float *alpha, float *A, int *lda, float *B, int *ldb,
                  float *beta, float *C, int *ldc) nogil
 
-    void f_dgemm(char *transA, char *transB, int *m, int *n, int *k,
+    int f_dgemm(char *transA, char *transB, int *m, int *n, int *k,
                  double *alpha, double *A, int *lda, double *B, int *ldb,
                  double *beta, double *C, int *ldc) nogil
 
diff --git a/scipy/fftpack/src/convolve.c b/scipy/fftpack/src/convolve.c
index 1597a43..c59762a 100644
--- a/scipy/fftpack/src/convolve.c
+++ b/scipy/fftpack/src/convolve.c
@@ -12,9 +12,9 @@
 #include "fftpack.h"
 
 /**************** FFTPACK ZFFT **********************/
-extern void F_FUNC(dfftf, DFFTF) (int *, double *, double *);
-extern void F_FUNC(dfftb, DFFTB) (int *, double *, double *);
-extern void F_FUNC(dffti, DFFTI) (int *, double *);
+extern int F_FUNC(dfftf, DFFTF) (int *, double *, double *);
+extern int F_FUNC(dfftb, DFFTB) (int *, double *, double *);
+extern int F_FUNC(dffti, DFFTI) (int *, double *);
 GEN_CACHE(dfftpack, (int n)
           , double *wsave;, (caches_dfftpack[i].n == n)
           , caches_dfftpack[id].wsave =
diff --git a/scipy/fftpack/src/dct.c.src b/scipy/fftpack/src/dct.c.src
index 1e9042f..07af8ff 100644
--- a/scipy/fftpack/src/dct.c.src
+++ b/scipy/fftpack/src/dct.c.src
@@ -18,11 +18,11 @@ enum normalize {
 #pref=,d#
 #PREF=,D#
 */
-extern void F_FUNC(@pref@costi, @PREF@COSTI)(int*, @type@*);
-extern void F_FUNC(@pref@cost, @PREF@COST)(int*, @type@*, @type@*);
-extern void F_FUNC(@pref@cosqi, @PREF@COSQI)(int*, @type@*);
-extern void F_FUNC(@pref@cosqb, @PREF@COSQB)(int*, @type@*, @type@*);
-extern void F_FUNC(@pref@cosqf, @PREF@COSQF)(int*, @type@*, @type@*);
+extern int F_FUNC(@pref@costi, @PREF@COSTI)(int*, @type@*);
+extern int F_FUNC(@pref@cost, @PREF@COST)(int*, @type@*, @type@*);
+extern int F_FUNC(@pref@cosqi, @PREF@COSQI)(int*, @type@*);
+extern int F_FUNC(@pref@cosqb, @PREF@COSQB)(int*, @type@*, @type@*);
+extern int F_FUNC(@pref@cosqf, @PREF@COSQF)(int*, @type@*, @type@*);
 
 GEN_CACHE(@pref@dct1,(int n)
       ,@type@* wsave;
@@ -40,7 +40,7 @@ GEN_CACHE(@pref@dct2,(int n)
       ,free(caches_@pref@dct2[id].wsave);
       ,10)
 
-void @pref@dct1(@type@ * inout, int n, int howmany, int normalize)
+int @pref@dct1(@type@ * inout, int n, int howmany, int normalize)
 {
     int i;
     @type@ *ptr = inout;
@@ -80,7 +80,7 @@ void @pref@dct1(@type@ * inout, int n, int howmany, int normalize)
     }
 }
 
-void @pref@dct2(@type@ * inout, int n, int howmany, int normalize)
+int @pref@dct2(@type@ * inout, int n, int howmany, int normalize)
 {
     int i, j;
     @type@ *ptr = inout;
@@ -125,7 +125,7 @@ void @pref@dct2(@type@ * inout, int n, int howmany, int normalize)
     }
 }
 
-void @pref@dct3(@type@ * inout, int n, int howmany, int normalize)
+int @pref@dct3(@type@ * inout, int n, int howmany, int normalize)
 {
     int i, j;
     @type@ *ptr = inout;
diff --git a/scipy/fftpack/src/drfft.c b/scipy/fftpack/src/drfft.c
index 835415d..cf4b7e6 100644
--- a/scipy/fftpack/src/drfft.c
+++ b/scipy/fftpack/src/drfft.c
@@ -6,12 +6,12 @@
 
 #include "fftpack.h"
 
-extern void F_FUNC(dfftf, DFFTF) (int *, double *, double *);
-extern void F_FUNC(dfftb, DFFTB) (int *, double *, double *);
-extern void F_FUNC(dffti, DFFTI) (int *, double *);
-extern void F_FUNC(rfftf, RFFTF) (int *, float *, float *);
-extern void F_FUNC(rfftb, RFFTB) (int *, float *, float *);
-extern void F_FUNC(rffti, RFFTI) (int *, float *);
+extern int F_FUNC(dfftf, DFFTF) (int *, double *, double *);
+extern int F_FUNC(dfftb, DFFTB) (int *, double *, double *);
+extern int F_FUNC(dffti, DFFTI) (int *, double *);
+extern int F_FUNC(rfftf, RFFTF) (int *, float *, float *);
+extern int F_FUNC(rfftb, RFFTB) (int *, float *, float *);
+extern int F_FUNC(rffti, RFFTI) (int *, float *);
 
 
 GEN_CACHE(drfft, (int n)
@@ -32,7 +32,7 @@ GEN_CACHE(rfft, (int n)
 	  , free(caches_rfft[id].wsave);
 	  , 10)
 
-void drfft(double *inout, int n, int direction, int howmany,
+int drfft(double *inout, int n, int direction, int howmany,
 			  int normalize)
 {
     int i;
@@ -67,7 +67,7 @@ void drfft(double *inout, int n, int direction, int howmany,
     }
 }
 
-void rfft(float *inout, int n, int direction, int howmany,
+int rfft(float *inout, int n, int direction, int howmany,
 			 int normalize)
 {
     int i;
diff --git a/scipy/fftpack/src/dst.c.src b/scipy/fftpack/src/dst.c.src
index 3c952f5..859a2ee 100644
--- a/scipy/fftpack/src/dst.c.src
+++ b/scipy/fftpack/src/dst.c.src
@@ -18,11 +18,11 @@ enum normalize {
 #pref=,d#
 #PREF=,D#
 */
-extern void F_FUNC(@pref@sinti, @PREF@SINTI)(int*, @type@*);
-extern void F_FUNC(@pref@sint, @PREF@SINT)(int*, @type@*, @type@*);
-extern void F_FUNC(@pref@sinqi, @PREF@SINQI)(int*, @type@*);
-extern void F_FUNC(@pref@sinqb, @PREF@SINQB)(int*, @type@*, @type@*);
-extern void F_FUNC(@pref@sinqf, @PREF@SINQF)(int*, @type@*, @type@*);
+extern int F_FUNC(@pref@sinti, @PREF@SINTI)(int*, @type@*);
+extern int F_FUNC(@pref@sint, @PREF@SINT)(int*, @type@*, @type@*);
+extern int F_FUNC(@pref@sinqi, @PREF@SINQI)(int*, @type@*);
+extern int F_FUNC(@pref@sinqb, @PREF@SINQB)(int*, @type@*, @type@*);
+extern int F_FUNC(@pref@sinqf, @PREF@SINQF)(int*, @type@*, @type@*);
 
 GEN_CACHE(@pref@dst1,(int n)
       ,@type@* wsave;
@@ -40,7 +40,7 @@ GEN_CACHE(@pref@dst2,(int n)
       ,free(caches_@pref@dst2[id].wsave);
       ,10)
 
-void @pref@dst1(@type@ * inout, int n, int howmany, int normalize)
+int @pref@dst1(@type@ * inout, int n, int howmany, int normalize)
 {
     int i;
     @type@ *ptr = inout;
@@ -80,7 +80,7 @@ void @pref@dst1(@type@ * inout, int n, int howmany, int normalize)
     }
 }
 
-void @pref@dst2(@type@ * inout, int n, int howmany, int normalize)
+int @pref@dst2(@type@ * inout, int n, int howmany, int normalize)
 {
     int i, j;
     @type@ *ptr = inout;
@@ -125,7 +125,7 @@ void @pref@dst2(@type@ * inout, int n, int howmany, int normalize)
     }
 }
 
-void @pref@dst3(@type@ * inout, int n, int howmany, int normalize)
+int @pref@dst3(@type@ * inout, int n, int howmany, int normalize)
 {
     int i, j;
     @type@ *ptr = inout;
diff --git a/scipy/fftpack/src/zfft.c b/scipy/fftpack/src/zfft.c
index 45c0536..09b92d2 100644
--- a/scipy/fftpack/src/zfft.c
+++ b/scipy/fftpack/src/zfft.c
@@ -6,12 +6,12 @@
 
 #include "fftpack.h"
 
-extern void F_FUNC(zfftf,ZFFTF)(int*,double*,double*);
-extern void F_FUNC(zfftb,ZFFTB)(int*,double*,double*);
-extern void F_FUNC(zffti,ZFFTI)(int*,double*);
-extern void F_FUNC(cfftf,CFFTF)(int*,float*,float*);
-extern void F_FUNC(cfftb,CFFTB)(int*,float*,float*);
-extern void F_FUNC(cffti,CFFTI)(int*,float*);
+extern int F_FUNC(zfftf,ZFFTF)(int*,double*,double*);
+extern int F_FUNC(zfftb,ZFFTB)(int*,double*,double*);
+extern int F_FUNC(zffti,ZFFTI)(int*,double*);
+extern int F_FUNC(cfftf,CFFTF)(int*,float*,float*);
+extern int F_FUNC(cfftb,CFFTB)(int*,float*,float*);
+extern int F_FUNC(cffti,CFFTI)(int*,float*);
 
 GEN_CACHE(zfft,(int n)
 	  ,double* wsave;
@@ -29,7 +29,7 @@ GEN_CACHE(cfft,(int n)
 	  ,free(caches_cfft[id].wsave);
 	  ,10)
 
-void zfft(complex_double * inout, int n, int direction, int howmany,
+int zfft(complex_double * inout, int n, int direction, int howmany,
 		int normalize)
 {
 	int i;
@@ -64,7 +64,7 @@ void zfft(complex_double * inout, int n, int direction, int howmany,
 	}
 }
 
-void cfft(complex_float * inout, int n, int direction, int howmany,
+int cfft(complex_float * inout, int n, int direction, int howmany,
 	int normalize)
 {
 	int i;
diff --git a/scipy/fftpack/src/zfftnd.c b/scipy/fftpack/src/zfftnd.c
index 457a913..5952403 100644
--- a/scipy/fftpack/src/zfftnd.c
+++ b/scipy/fftpack/src/zfftnd.c
@@ -121,13 +121,13 @@ void sflatten(complex_float * dest, complex_float * src,
     }
 }
 
-extern void cfft(complex_float * inout,
+extern int cfft(complex_float * inout,
 		 int n, int direction, int howmany, int normalize);
 
-extern void zfft(complex_double * inout,
+extern int zfft(complex_double * inout,
 		 int n, int direction, int howmany, int normalize);
 
-extern void zfftnd(complex_double * inout, int rank,
+extern int zfftnd(complex_double * inout, int rank,
 			   int *dims, int direction, int howmany,
 			   int normalize)
 {
@@ -170,7 +170,7 @@ extern void zfftnd(complex_double * inout, int rank,
 
 }
 
-extern void cfftnd(complex_float * inout, int rank,
+extern int cfftnd(complex_float * inout, int rank,
 			   int *dims, int direction, int howmany,
 			   int normalize)
 {
diff --git a/scipy/fftpack/src/zrfft.c b/scipy/fftpack/src/zrfft.c
index c3f54ef..e8f1d48 100644
--- a/scipy/fftpack/src/zrfft.c
+++ b/scipy/fftpack/src/zrfft.c
@@ -6,10 +6,10 @@
 
 #include "fftpack.h"
 
-extern void drfft(double *inout,int n,int direction,int howmany,int normalize);
-extern void rfft(float *inout,int n,int direction,int howmany,int normalize);
+extern int drfft(double *inout,int n,int direction,int howmany,int normalize);
+extern int rfft(float *inout,int n,int direction,int howmany,int normalize);
 
-extern void zrfft(complex_double *inout,
+extern int zrfft(complex_double *inout,
 		  int n,int direction,int howmany,int normalize) {
   int i,j,k;
   double* ptr = (double *)inout;
@@ -54,7 +54,7 @@ extern void zrfft(complex_double *inout,
   }
 }
 
-extern void crfft(complex_float *inout,
+extern int crfft(complex_float *inout,
 		  int n,int direction,int howmany,int normalize) {
   int i,j,k;
   float* ptr = (float *)inout;
diff --git a/scipy/integrate/__quadpack.h b/scipy/integrate/__quadpack.h
index 2bf7aad..3610462 100644
--- a/scipy/integrate/__quadpack.h
+++ b/scipy/integrate/__quadpack.h
@@ -51,13 +51,13 @@
   #endif
 #endif
 
-void DQAGSE();
-void DQAGIE();
-void DQAGPE();
-void DQAWOE();
-void DQAWFE();
-void DQAWSE();
-void DQAWCE();
+int DQAGSE();
+int DQAGIE();
+int DQAGPE();
+int DQAWOE();
+int DQAWFE();
+int DQAWSE();
+int DQAWCE();
 
 
 typedef enum {
diff --git a/scipy/interpolate/blas_defs.h b/scipy/interpolate/blas_defs.h
index 0f95237..5a7adb7 100644
--- a/scipy/interpolate/blas_defs.h
+++ b/scipy/interpolate/blas_defs.h
@@ -16,4 +16,5 @@
 #endif
 #endif
 
+extern int dgeev_(char *jobvl, char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);
 #define c_dgeev F_FUNC(dgeev,DGEEV)
diff --git a/scipy/interpolate/src/__fitpack.h b/scipy/interpolate/src/__fitpack.h
index eccc5a8..5ed3cc3 100644
--- a/scipy/interpolate/src/__fitpack.h
+++ b/scipy/interpolate/src/__fitpack.h
@@ -76,35 +76,35 @@
 	#endif
 #endif
 
-void CURFIT(int*,int*,double*,double*,double*,double*,
+int CURFIT(int*,int*,double*,double*,double*,double*,
         double*,int*,double*,int*,int*,double*,double*,
         double*,double*,int*,int*,int*);
-void PERCUR(int*,int*,double*,double*,double*,int*,
+int PERCUR(int*,int*,double*,double*,double*,int*,
         double*,int*,int*,double*,double*,double*,
         double*,int*,int*,int*);
-void SPALDE(double*,int*,double*,int*,double*,double*,int*);
-void SPLDER(double*,int*,double*,int*,int*,double*,
+int SPALDE(double*,int*,double*,int*,double*,double*,int*);
+int SPLDER(double*,int*,double*,int*,int*,double*,
         double*,int*,int*,double*,int*);
-void SPLEV(double*,int*,double*,int*,double*,double*,int*,int*,int*);
+int SPLEV(double*,int*,double*,int*,double*,double*,int*,int*,int*);
 double SPLINT(double*,int*,double*,int*,double*,double*,double*);
-void SPROOT(double*,int*,double*,double*,int*,int*,int*);
-void PARCUR(int*,int*,int*,int*,double*,int*,double*,
+int SPROOT(double*,int*,double*,double*,int*,int*,int*);
+int PARCUR(int*,int*,int*,int*,double*,int*,double*,
         double*,double*,double*,int*,double*,int*,int*,
         double*,int*,double*,double*,double*,int*,int*,int*);
-void CLOCUR(int*,int*,int*,int*,double*,int*,double*,
+int CLOCUR(int*,int*,int*,int*,double*,int*,double*,
         double*,int*,double*,int*,int*,double*,int*,
         double*,double*,double*,int*,int*,int*);
-void SURFIT(int*,int*,double*,double*,double*,double*,
+int SURFIT(int*,int*,double*,double*,double*,double*,
         double*,double*,double*,double*,int*,int*,double*,
         int*,int*,int*,double*,int*,double*,int*,double*,
         double*,double*,double*,int*,double*,int*,int*,int*,int*);
-void BISPEV(double*,int*,double*,int*,double*,int*,int*,
+int BISPEV(double*,int*,double*,int*,double*,int*,int*,
         double*,int*,double*,int*,double*,double*,int*,
         int*,int*,int*);
-void PARDER(double*,int*,double*,int*,double*,int*,int*,
+int PARDER(double*,int*,double*,int*,double*,int*,int*,
         int*,int*,double*,int*,double*,int*,double*,
         double*,int*,int*,int*,int*);
-void INSERT(int*,double*,int*,double*,int*,double*,double*,
+int INSERT(int*,double*,int*,double*,int*,double*,double*,
         int*,double*,int*,int*);
 
 /* Note that curev, cualde need no interface. */
@@ -865,7 +865,7 @@ fail:
 }
 
 
-static void
+static int
 _deBoor_D(double *t, double x, int k, int ell, int m, double *result) {
     /*
      * On completion the result array stores
diff --git a/scipy/linalg/_cython_wrapper_generators.py b/scipy/linalg/_cython_wrapper_generators.py
index 62be001..b62c31a 100644
--- a/scipy/linalg/_cython_wrapper_generators.py
+++ b/scipy/linalg/_cython_wrapper_generators.py
@@ -3,8 +3,13 @@ Code generator script to make the Cython BLAS and LAPACK wrappers
 from the files "cython_blas_signatures.txt" and
 "cython_lapack_signatures.txt" which contain the signatures for
 all the BLAS/LAPACK routines that should be included in the wrappers.
+
+# NB: this version is updated for CLAPACK. It makes the assumption (as does
+# everything else in scipy, that CLAPACK long int is the same size as int )
 """
 
+
+
 from operator import itemgetter
 
 fortran_types = {'int': 'integer',
@@ -15,7 +20,9 @@ fortran_types = {'int': 'integer',
                  'char': 'character',
                  'bint': 'logical'}
 
-c_types = {'int': 'int',
+c_types = {'void':'int',
+        'VOID':'int',
+	   'int': 'int',
            'c': 'npy_complex64',
            'd': 'double',
            's': 'float',
@@ -31,17 +38,29 @@ c_types = {'int': 'int',
            'zselect1': '_zselect1',
            'zselect2': '_zselect2'}
 
+py_type_replacements={'npy_complex64':'float complex',
+                       'npy_complex128':'double complex'}
+
 
 def arg_names_and_types(args):
     return zip(*[arg.split(' *') for arg in args.split(', ')])
 
 pyx_func_template = """
+
 cdef extern from "{header_name}":
-    void _fortran_{name} "F_FUNC({name}wrp, {upname}WRP)"({ret_type} *out, {fort_args}) nogil
-cdef {ret_type} {name}({args}) nogil:
-    cdef {ret_type} out
-    _fortran_{name}(&out, {argnames})
-    return out
+    {c_ret_type} _fortran_{name} "F_FUNC({name}, {upname})"({args}) nogil
+cdef {py_ret_type} {name}({py_args}) nogil:
+    return  _fortran_{name}({argnames})
+"""
+
+# CLAPACK returns complex by pointer
+pyx_func_template_complex = """
+cdef extern from "{header_name}":
+    void _fortran_{name} "F_FUNC({name}, {upname})"({c_ret_type} *ret_val,{args}) nogil
+cdef {py_ret_type} {name}({py_args}) nogil:
+    cdef {py_ret_type} ret_val
+    _fortran_{name}(<{c_ret_type}*>&ret_val,{argnames})
+    return ret_val
 """
 
 npy_types = {'c': 'npy_complex64', 'z': 'npy_complex128',
@@ -50,57 +69,114 @@ npy_types = {'c': 'npy_complex64', 'z': 'npy_complex128',
              'sselect2': '_sselect2', 'sselect3': '_sselect3',
              'zselect1': '_zselect1', 'zselect2': '_zselect2'}
 
+# methods that use char* need a wrapper building,
+# because CLAPACK uses null terminated strings
+# and f2c uses char* + extra length args
+# the wrapper will be called in preprocessing of
+# f2c generated code
+
+def needs_wrapper(argtypes):
+    for c in argtypes:
+        if c=='char':
+            return True
+    return False
 
 def arg_casts(arg):
     if arg in ['npy_complex64', 'npy_complex128', '_cselect1', '_cselect2',
                '_dselect2', '_dselect3', '_sselect2', '_sselect3',
-               '_zselect1', '_zselect2']:
+               '_zselect1', '_zselect2','f2c_complex','f2c_doublecomplex','integer','real','doublereal','logical']:
         return '<{0}*>'.format(arg)
     return ''
 
-
 def pyx_decl_func(name, ret_type, args, header_name):
+    # clapack returns double for single precision functions (why?)
+    if ret_type=='s':
+        ret_type='d'
+
+    c_ret_type=c_types[ret_type]
+    if ret_type=='z':
+        py_ret_type='double complex'
+    elif ret_type=='c':
+        py_ret_type='float complex'
+    else:
+         py_ret_type=c_ret_type
     argtypes, argnames = arg_names_and_types(args)
-    # Fix the case where one of the arguments has the same name as the
-    # abbreviation for the argument type.
-    # Otherwise the variable passed as an argument is considered overwrites
-    # the previous typedef and Cython compilation fails.
-    if ret_type in argnames:
-        argnames = [n if n != ret_type else ret_type + '_' for n in argnames]
-        argnames = [n if n not in ['lambda', 'in'] else n + '_'
-                    for n in argnames]
-        args = ', '.join([' *'.join([n, t])
-                          for n, t in zip(argtypes, argnames)])
-    argtypes = [npy_types.get(t, t) for t in argtypes]
-    fort_args = ', '.join([' *'.join([n, t])
+    argtypes = [c_types.get(t, t) for t in argtypes]
+    pyargtypes = [py_type_replacements.get(t, t) for t in argtypes]
+    py_args = ', '.join([' *'.join([n, t])
+                           for n, t in zip(pyargtypes, argnames)])
+    args = ', '.join([' *'.join([n, t])
                            for n, t in zip(argtypes, argnames)])
+    unwrapper_argnames=",".join(argnames)
     argnames = [arg_casts(t) + n for n, t in zip(argnames, argtypes)]
     argnames = ', '.join(argnames)
-    c_ret_type = c_types[ret_type]
     args = args.replace('lambda', 'lambda_')
-    return pyx_func_template.format(name=name, upname=name.upper(), args=args,
-                                    fort_args=fort_args, ret_type=ret_type,
-                                    c_ret_type=c_ret_type, argnames=argnames,
+    # CLAPACK handles strings c style i.e. by null termination
+    # these unwrappers remove the fortran style length arguments
+    # they are for calling from f2c only
+    # I think normally they'd be in the lapack already, but they aren't in 
+    # clapack. They are made public for use in f2c generated code
+    unwrapper=""
+    if needs_wrapper(argtypes):
+        extra_args=args
+        num_extra=0
+        for c in argtypes:
+            if c=='char':
+                num_extra+=1
+                extra_args+=", int ignore_%d"%(num_extra)
+        unwrapper=pyx_clapack_unwrapper_template.format(name=name,extra_args=extra_args,argnames=unwrapper_argnames,args=args,c_ret_type=c_ret_type)
+    if ret_type=='z' or ret_type=='c':
+        return unwrapper+pyx_func_template_complex.format(name=name,upname=name.upper(),args=args,
+                                    ret_type=c_ret_type,c_ret_type=c_ret_type,py_ret_type=py_ret_type,
+                                    argnames=argnames,header_name=header_name,py_args=py_args)
+    else:
+        return unwrapper+pyx_func_template.format(name=name, upname=name.upper(), args=args,
+                                    ret_type=c_ret_type,c_ret_type=c_ret_type,py_args=py_args,
+                                    argnames=argnames,py_ret_type=py_ret_type,
                                     header_name=header_name)
 
 pyx_sub_template = """cdef extern from "{header_name}":
-    void _fortran_{name} "F_FUNC({name},{upname})"({fort_args}) nogil
-cdef void {name}({args}) nogil:
+    int _fortran_{name} "F_FUNC({name},{upname})"({args}) nogil
+cdef int {name}({py_args}) nogil:
     _fortran_{name}({argnames})
 """
 
+pyx_clapack_unwrapper_template= """
+
+cdef extern {c_ret_type} {name}_({args})
+
+cdef public {c_ret_type} w{name}_({extra_args}):
+    return {name}_({argnames});
+"""
 
 def pyx_decl_sub(name, args, header_name):
     argtypes, argnames = arg_names_and_types(args)
-    argtypes = [npy_types.get(t, t) for t in argtypes]
+    argtypes = [c_types.get(t, t) for t in argtypes]
     argnames = [n if n not in ['lambda', 'in'] else n + '_' for n in argnames]
-    fort_args = ', '.join([' *'.join([n, t])
+    pyargtypes = [py_type_replacements.get(t, t) for t in argtypes]
+    py_args = ', '.join([' *'.join([n, t])
+                           for n, t in zip(pyargtypes, argnames)])
+    args = ', '.join([' *'.join([n, t])
                            for n, t in zip(argtypes, argnames)])
+    unwrapper_argnames=",".join(argnames)
     argnames = [arg_casts(t) + n for n, t in zip(argnames, argtypes)]
     argnames = ', '.join(argnames)
     args = args.replace('*lambda,', '*lambda_,').replace('*in,', '*in_,')
-    return pyx_sub_template.format(name=name, upname=name.upper(),
-                                   args=args, fort_args=fort_args,
+    # CLAPACK handles strings c style i.e. by null termination
+    # these unwrappers remove the fortran style length arguments
+    # normally the lapack would be a fortran library so it would need 
+    # them, but not CLAPACK
+    unwrapper=""
+    if needs_wrapper(argtypes):
+        extra_args=args
+        num_extra=0
+        for c in argtypes:
+            if c=='char':
+                num_extra+=1
+                extra_args+=", int ignore_%d"%(num_extra)
+        unwrapper=pyx_clapack_unwrapper_template.format(name=name,extra_args=extra_args,argnames=unwrapper_argnames,args=args,c_ret_type='int')
+    return unwrapper+ pyx_sub_template.format(name=name, upname=name.upper(),
+                                   args=args, py_args=py_args,
                                    argnames=argnames, header_name=header_name)
 
 blas_pyx_preamble = '''# cython: boundscheck = False
@@ -190,14 +266,14 @@ from numpy cimport npy_complex64, npy_complex128
 cdef extern from "_lapack_subroutines.h":
     # Function pointer type declarations for
     # gees and gges families of functions.
-    ctypedef bint _cselect1(npy_complex64*)
-    ctypedef bint _cselect2(npy_complex64*, npy_complex64*)
-    ctypedef bint _dselect2(d*, d*)
-    ctypedef bint _dselect3(d*, d*, d*)
-    ctypedef bint _sselect2(s*, s*)
-    ctypedef bint _sselect3(s*, s*, s*)
-    ctypedef bint _zselect1(npy_complex128*)
-    ctypedef bint _zselect2(npy_complex128*, npy_complex128*)
+    ctypedef int _cselect1(npy_complex64*)
+    ctypedef int _cselect2(npy_complex64*, npy_complex64*)
+    ctypedef int _dselect2(d*, d*)
+    ctypedef int _dselect3(d*, d*, d*)
+    ctypedef int _sselect2(s*, s*)
+    ctypedef int _sselect3(s*, s*, s*)
+    ctypedef int _zselect1(npy_complex128*)
+    ctypedef int _zselect2(npy_complex128*, npy_complex128*)
 
 '''
 
@@ -210,7 +286,7 @@ blas_py_wrappers = """
 
 # Python-accessible wrappers for testing:
 
-cdef inline bint _is_contiguous(double[:,:] a, int axis) nogil:
+cdef inline int _is_contiguous(double[:,:] a, int axis) nogil:
     return (a.strides[axis] == sizeof(a[0,0]) or a.shape[axis] == 1)
 
 cpdef float complex _test_cdotc(float complex[:] cx, float complex[:] cy) nogil:
@@ -452,6 +528,16 @@ pxd_template = """cdef {ret_type} {name}({args}) nogil
 
 def pxd_decl(name, ret_type, args):
     args = args.replace('lambda', 'lambda_').replace('*in,', '*in_,')
+
+    argtypes, argnames = arg_names_and_types(args)
+    argtypes = [c_types.get(t, t) for t in argtypes]
+    argtypes = [py_type_replacements.get(t, t) for t in argtypes]
+    args = ', '.join([' *'.join([n, t])
+                           for n, t in zip(argtypes, argnames)])
+    if ret_type=='s':
+        ret_type='d'
+    ret_type=c_types[ret_type]
+    ret_type=py_type_replacements.get(ret_type,ret_type)
     return pxd_template.format(name=name, ret_type=ret_type, args=args)
 
 blas_pxd_preamble = """# Within scipy, these wrappers can be used via relative or absolute cimport.
@@ -470,6 +556,7 @@ ctypedef double d
 ctypedef float complex c
 ctypedef double complex z
 
+from numpy cimport npy_complex64, npy_complex128
 """
 
 
@@ -488,27 +575,43 @@ lapack_pxd_preamble = """# Within scipy, these wrappers can be used via relative
 # these wrappers should not be used.
 # The original libraries should be linked directly.
 
+
 ctypedef float s
 ctypedef double d
 ctypedef float complex c
 ctypedef double complex z
 
+from numpy cimport npy_complex64, npy_complex128
+
 # Function pointer type declarations for
 # gees and gges families of functions.
-ctypedef bint cselect1(c*)
-ctypedef bint cselect2(c*, c*)
-ctypedef bint dselect2(d*, d*)
-ctypedef bint dselect3(d*, d*, d*)
-ctypedef bint sselect2(s*, s*)
-ctypedef bint sselect3(s*, s*, s*)
-ctypedef bint zselect1(z*)
-ctypedef bint zselect2(z*, z*)
+#ctypedef int cselect1(npy_complex64*)
+#ctypedef int cselect2(npy_complex64*, npy_complex64*)
+#ctypedef int dselect2(double*, double*)
+#ctypedef int dselect3(double*,double*,double*)
+#ctypedef int sselect2(float*,float*)
+#ctypedef int sselect3(float*,float*,float*)
+#ctypedef int zselect1(npy_complex128*)
+#ctypedef int zselect2(npy_complex128*,npy_complex128*,npy_complex128*)
+
+cdef extern from "_lapack_subroutines.h":
+    # Function pointer type declarations for
+    # gees and gges families of functions.
+    ctypedef int _cselect1(npy_complex64*)
+    ctypedef int _cselect2(npy_complex64*, npy_complex64*)
+    ctypedef int _dselect2(d*, d*)
+    ctypedef int _dselect3(d*, d*, d*)
+    ctypedef int _sselect2(s*, s*)
+    ctypedef int _sselect3(s*, s*, s*)
+    ctypedef int _zselect1(npy_complex128*)
+    ctypedef int _zselect2(npy_complex128*, npy_complex128*)
+
 
 """
 
 
 def generate_lapack_pxd(all_sigs):
-    return lapack_pxd_preamble + '\n'.join(pxd_decl(*sig) for sig in all_sigs)
+    return lapack_pxd_preamble  + '\n'.join(pxd_decl(*sig) for sig in all_sigs)
 
 fortran_template = """      subroutine {name}wrp(ret, {argnames})
         external {wrapper}
@@ -535,12 +638,14 @@ def process_fortran_name(name, funcname):
 
 
 def fort_subroutine_wrapper(name, ret_type, args):
-    if name[0] in ['c', 's'] or name in ['zladiv', 'zdotu', 'zdotc']:
+    if ret_type=='s':
+        ret_type='d'
+    types, names = arg_names_and_types(args)
+    argnames = ', '.join(names)
+    if needs_wrapper(types):
         wrapper = 'w' + name
     else:
         wrapper = name
-    types, names = arg_names_and_types(args)
-    argnames = ', '.join(names)
 
     names = [process_fortran_name(n, name) for n in names]
     argdecls = '\n        '.join('{0} {1}'.format(fortran_types[t], n)
@@ -554,21 +659,38 @@ def generate_fortran(func_sigs):
     return "\n".join(fort_subroutine_wrapper(*sig) for sig in func_sigs)
 
 
-def make_c_args(args):
+def make_c_args(args,*,add_char_length_args=False):
     types, names = arg_names_and_types(args)
+    names=list(names)
     types = [c_types[arg] for arg in types]
+    if add_char_length_args:
+        new_args=0
+        for c in types:
+            if c=='char':
+                new_args+=1
+        for c in range(new_args):
+            types.append('ftnlen')
+            names.append('ignore_%d'%c)
     return ', '.join('{0} *{1}'.format(t, n) for t, n in zip(types, names))
 
-c_func_template = "void F_FUNC({name}wrp, {upname}WRP)({return_type} *ret, {args});\n"
+c_func_template = "{return_type} F_FUNC({name}, {upname})( {args});\n"
+c_func_template_complex = "void F_FUNC({name}, {upname})({return_type} *ret, {args});\n"
 
 
 def c_func_decl(name, return_type, args):
-    args = make_c_args(args)
-    return_type = c_types[return_type]
-    return c_func_template.format(name=name, upname=name.upper(),
+    if return_type=='s':
+        return_type='d'
+    args = make_c_args(args,add_char_length_args=False)
+    if return_type=='z' or return_type=='c':
+        return_type = c_types[return_type]
+        return c_func_template_complex.format(name=name, upname=name.upper(),
+                                  return_type=return_type, args=args)
+    else:
+        return_type = c_types[return_type]
+        return c_func_template.format(name=name, upname=name.upper(),
                                   return_type=return_type, args=args)
 
-c_sub_template = "void F_FUNC({name},{upname})({args});\n"
+c_sub_template = "int F_FUNC({name},{upname})({args});\n"
 
 
 def c_sub_decl(name, return_type, args):
@@ -579,6 +701,7 @@ c_preamble = """#ifndef SCIPY_LINALG_{lib}_FORTRAN_WRAPPERS_H
 #define SCIPY_LINALG_{lib}_FORTRAN_WRAPPERS_H
 #include "fortran_defs.h"
 #include "numpy/arrayobject.h"
+#include "f2c.h"
 """
 
 lapack_decls = """
@@ -630,6 +753,15 @@ def filter_lines(ls):
     all_sigs = list(sorted(func_sigs + sub_sigs, key=itemgetter(0)))
     return func_sigs, sub_sigs, all_sigs
 
+def generate_wrapper_list(sigs):
+    wrappers=""
+    for name,rt,args in sigs:
+        anames,atypes=arg_names_and_types(args)
+        if "char" in atypes:
+            wrappers+=name+":w"+name+",\n"
+    return wrappers
+
+    
 
 def make_all(blas_signature_file="cython_blas_signatures.txt",
              lapack_signature_file="cython_lapack_signatures.txt",
@@ -682,6 +814,10 @@ def make_all(blas_signature_file="cython_blas_signatures.txt",
     with open(lapack_header_name, 'w') as f:
         f.write(ccomment)
         f.write(lapack_c_header)
+    wrapper_list = generate_wrapper_list([*lapack_sigs[2]]+[*blas_sigs[2]])
+    with open("wrapper_list.txt",'w') as f:
+        f.write(ccomment)
+        f.write(wrapper_list)
 
 if __name__ == '__main__':
     make_all()
diff --git a/scipy/linalg/cython_lapack_signatures.txt b/scipy/linalg/cython_lapack_signatures.txt
index 0455995..34d0782 100644
--- a/scipy/linalg/cython_lapack_signatures.txt
+++ b/scipy/linalg/cython_lapack_signatures.txt
@@ -1296,3 +1296,4 @@ void zunmrz(char *side, char *trans, int *m, int *n, int *k, int *l, z *a, int *
 void zunmtr(char *side, char *uplo, char *trans, int *m, int *n, z *a, int *lda, z *tau, z *c, int *ldc, z *work, int *lwork, int *info)
 void zupgtr(char *uplo, int *n, z *ap, z *tau, z *q, int *ldq, z *work, int *info)
 void zupmtr(char *side, char *uplo, char *trans, int *m, int *n, z *ap, z *tau, z *c, int *ldc, z *work, int *info)
+void ilaenv(int *ispec, char *name, char *opts, int *n1, int *n2, int *n3, int *n4)
diff --git a/scipy/linalg/fblas_l1.pyf.src b/scipy/linalg/fblas_l1.pyf.src
index 5008ee8..6380740 100644
--- a/scipy/linalg/fblas_l1.pyf.src
+++ b/scipy/linalg/fblas_l1.pyf.src
@@ -252,14 +252,17 @@ end subroutine <prefix>axpy
 function sdot(n,x,offx,incx,y,offy,incy) result (xy)
   ! Computes a vector-vector dot product.
 
-  fortranname wsdot
+  callstatement sdot_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,float*,int*,float*,int*
+
+  fortranname F_FUNC(sdot,SDOT)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) sdot
 
-  callstatement (*f2py_func)(&sdot,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument float*,int*,float*,int*,float*,int*
 
   real dimension(*), intent(in) :: x
   real dimension(*), intent(in) :: y
-  real sdot,xy
+  double precision sdot,xy
   integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
   integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
   integer optional, intent(in),depend(x) :: offx=0
@@ -277,8 +280,12 @@ end function sdot
 function ddot(n,x,offx,incx,y,offy,incy) result (xy)
   ! Computes a vector-vector dot product.
 
-  callstatement (*f2py_func)(&ddot,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument double*,int*,double*,int*,double*,int*
+  callstatement ddot_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,double*,int*,double*,int*
+
+  fortranname F_FUNC(ddot,ddot)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) ddot
 
   double precision dimension(*), intent(in) :: x
   double precision dimension(*), intent(in) :: y
@@ -297,15 +304,19 @@ function ddot(n,x,offx,incx,y,offy,incy) result (xy)
 end function ddot
 
 
+// in CLAPACK, cdotu and zdotu are void and return by pointer (as can't return complex* without allocation)
 ! <prefix2c=c,z> <ftype2c=complex,double complex> <ctype2c=complex_float,complex_double>
 function <prefix2c>dotu(n,x,offx,incx,y,offy,incy) result(xy)
 
   <ftype2c> :: <prefix2c>dotu, xy
-  fortranname w<prefix2c>dotu
 
-  callstatement (*f2py_func)(&<prefix2c>dotu,&n,x+offx,&incx,y+offy,&incy)
+  callstatement (*f2py_func)(&<prefix2c>dotu_return_value,&n,x+offx,&incx,y+offy,&incy)
   callprotoargument <ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*
 
+  fortranname F_FUNC(<prefix2c>dotu,<C,Z>DOTU)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix2c>dotu
+
   <ftype2c> dimension(*),intent(in) :: x
   <ftype2c> dimension(*),intent(in) :: y
 
@@ -328,10 +339,12 @@ end function <prefix2c>dotu
 function <prefix2c>dotc(n,x,offx,incx,y,offy,incy) result(xy)
 
   <ftype2c> :: <prefix2c>dotc, xy
-  fortranname w<prefix2c>dotc
+  callstatement <prefix2c>dotc_return_value=(*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
+  callprotoargument int*,<ctype2c>*,int*,<ctype2c>*,int*
 
-  callstatement (*f2py_func)(&<prefix2c>dotc,&n,x+offx,&incx,y+offy,&incy)
-  callprotoargument <ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*
+  fortranname F_FUNC(<prefix2c>dotc,<C,Z>DOTC)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix2c>dotc
 
   <ftype2c> dimension(*),intent(in) :: x
   <ftype2c> dimension(*),intent(in) :: y
@@ -354,11 +367,15 @@ end function <prefix2c>dotc
 ! <ftype3=real,complex> <ftypereal3=real,real>
 function <prefix3>nrm2(n,x,offx,incx) result(n2)
 
-  fortranname w<prefix3>nrm2
-  <ftypereal3> <prefix3>nrm2, n2
+  <ftypereal3> nm2
+  double precision <prefix3>nrm2
 
-  callstatement (*f2py_func)(&<prefix3>nrm2, &n,x+offx,&incx)
-  callprotoargument <ctypereal3>*,int*,<ctype3>*,int*
+  callstatement <prefix3>nrm2_return_value=(*f2py_func)( &n,x+offx,&incx)
+  callprotoargument int*,<ctype3>*,int*
+
+  fortranname F_FUNC(<prefix3>nrm2,<S,SC>NRM2)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix3>nrm2
 
   <ftype3> dimension(*),intent(in) :: x
 
@@ -378,10 +395,15 @@ end function <prefix3>nrm2
 ! <ftypereal4=double precision,double precision>
 function <prefix4>nrm2(n,x,offx,incx) result(n2)
 
-  <ftypereal4> <prefix4>nrm2, n2
+  callstatement <prefix4>nrm2_return_value=(*f2py_func)(&n,x+offx,&incx)
+  callprotoargument int*,<ctype4>*,int*
+
+  double precision <prefix4>nrm2
+  <ftype4> n2
+  fortranname F_FUNC(<prefix4>nrm2,<S,D>NRM2)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix4>nrm2
 
-  callstatement (*f2py_func)(&<prefix4>nrm2, &n,x+offx,&incx)
-  callprotoargument <ctypereal4>*,int*,<ctype4>*,int*
 
   <ftype4> dimension(*),intent(in) :: x
 
@@ -396,16 +418,20 @@ function <prefix4>nrm2(n,x,offx,incx) result(n2)
 end function <prefix4>nrm2
 
 
-function <prefix3>asum(n,x,offx,incx) result (s)
+function <prefix3>asum(n,x,offx,incx) result (d)
   ! Computes the sum of magnitudes of the vector elements
 
-  fortranname w<prefix3>asum
+  callstatement <prefix3>asum_return_value=(*f2py_func)(&n,x+offx,&incx)
+  callprotoargument int*,<ctype3>*,int*
 
-  callstatement (*f2py_func)(&<prefix3>asum,&n,x+offx,&incx)
-  callprotoargument <ctypereal3>*,int*,<ctype3>*,int*
+  double precision <prefix3>asum
+  fortranname F_FUNC(<prefix3>asum,<S,SC>ASUM)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix3>asum
 
   <ftype3> dimension(*), intent(in) :: x
-  <ftypereal3> <prefix3>asum,s
+  <ftypereal3> s
+  double precision <prefix3>asum
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
   integer optional, intent(in), depend(x) :: offx=0
   check(offx>=0 && offx<len(x)) :: offx
@@ -415,11 +441,16 @@ function <prefix3>asum(n,x,offx,incx) result (s)
 end function <prefix3>asum
 
 
-function <prefix4>asum(n,x,offx,incx) result (s)
+function <prefix4>asum(n,x,offx,incx) result (d)
   ! Computes the sum of magnitudes of the vector elements
 
-  callstatement (*f2py_func)(&<prefix4>asum,&n,x+offx,&incx)
-  callprotoargument <ctypereal4>*,int*,<ctype4>*,int*
+  callstatement <prefix4>asum_return_value=(*f2py_func)(&n,x+offx,&incx) 
+  callprotoargument int*,<ctype4>*,int*
+
+  <ftype4> <prefix4>asum
+  fortranname F_FUNC(<prefix4>asum,<D,Z>ASUM)
+  ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+  intent(c) <prefix4>asum
 
   <ftype4> dimension(*), intent(in) :: x
   <ftypereal4> <prefix4>asum,s
@@ -438,9 +469,9 @@ function i<prefix>amax(n,x,offx,incx) result(k)
   callstatement i<prefix>amax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
   callprotoargument int*,<ctype>*,int*
 
-  ! This is to avoid Fortran wrappers.
+  ! This is to avoid Fortran wrappers - fix for CLAPACK
   integer i<prefix>amax,k
-  fortranname F_FUNC(i<prefix>amax,I<S,D,C,Z>AMAX)
+  fortranname F_FUNC(i<prefix>amax,I<D,DZ>AMAX)
   intent(c) i<prefix>amax
   <ftype> dimension(*), intent(in) :: x
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
diff --git a/scipy/linalg/flapack.pyf.src b/scipy/linalg/flapack.pyf.src
index fd7c8ac..afbd956 100644
--- a/scipy/linalg/flapack.pyf.src
+++ b/scipy/linalg/flapack.pyf.src
@@ -2344,7 +2344,15 @@ end subroutine <prefix2c>hbevx
 !          rmax  = overflow threshold  - (base**emax)*(1-eps)
 function dlamch(cmach)
     character :: cmach
-    double precision intent(out):: dlamch
+    double precision:: dlamch
+    callstatement dlamch_return_value=(*f2py_func)(cmach)
+    callprotoargument char*
+
+    fortranname F_FUNC(dlamch,DLAMCH)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) dlamch
+
+
 end function dlamch
 
 function slamch(cmach)
@@ -2824,9 +2832,12 @@ function <prefix2>lange(norm,m,n,a,lda,work) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a real matrix A.
     <ftype2> <prefix2>lange, n2
-    fortranname <wrap2>lange
-    callstatement (*f2py_func)(&<prefix2>lange,norm,&m,&n,a,&m,work)
-    callprotoargument <ctype2>*,char*,int*,int*,<ctype2>*,int*,<ctype2>*
+    callstatement <prefix2>lange_return_value=(*f2py_func)(norm,&m,&n,a,&m,work)
+    callprotoargument char*,int*,int*,<ctype2>*,int*,<ctype2>*
+
+    fortranname F_FUNC(<prefix2>lange,<S,D>LANGE)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) <prefix2>lange
 
     character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
     integer intent(hide),depend(a,n) :: m = shape(a,0)
@@ -2840,9 +2851,13 @@ function <prefix2c>lange(norm,m,n,a,lda,work) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a complex matrix A.
     <ftype2> <prefix2c>lange, n2
-    fortranname <wrap2c>lange
-    callstatement (*f2py_func)(&<prefix2c>lange,norm,&m,&n,a,&m,work)
-    callprotoargument <ctype2>*,char*,int*,int*,<ctype2c>*,int*,<ctype2>*
+
+    callstatement <prefix2c>lange_return_value=(*f2py_func)(&norm,&m,&n,a,&m,work)
+    callprotoargument char*,int*,int*,<ctype2c>*,int*,<ctype2>*
+
+    fortranname F_FUNC(<prefix2c>lange,<C,Z>LANGE)
+    ! This following line is to avoid Fortran wrappers - fix for CLAPACK
+    intent(c) <prefix2c>lange
 
     character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
     integer intent(hide),depend(a,n) :: m = shape(a,0)
diff --git a/scipy/linalg/setup.py b/scipy/linalg/setup.py
index 8084aa8..5408c79 100755
--- a/scipy/linalg/setup.py
+++ b/scipy/linalg/setup.py
@@ -44,9 +44,10 @@ def configuration(parent_package='', top_path=None):
     # flapack:
     sources = ['flapack.pyf.src']
     sources += get_g77_abi_wrappers(lapack_opt)
-    dep_pfx = join('src', 'lapack_deprecations')
-    deprecated_lapack_routines = [join(dep_pfx, c + 'gegv.f') for c in 'cdsz']
-    sources += deprecated_lapack_routines
+#   CLAPACK still has these routines (with conflicting signatures)
+#    dep_pfx = join('src', 'lapack_deprecations')
+#    deprecated_lapack_routines = [join(dep_pfx, c + 'gegv.f') for c in 'cdsz']
+#    sources += deprecated_lapack_routines
 
     config.add_extension('_flapack',
                          sources=sources,
diff --git a/scipy/linalg/src/calc_lwork.f b/scipy/linalg/src/calc_lwork.f
index 2c00970..60216a3 100644
--- a/scipy/linalg/src/calc_lwork.f
+++ b/scipy/linalg/src/calc_lwork.f
@@ -10,10 +10,10 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: n,lo,hi
 
       INTEGER NB
-      EXTERNAL ILAENV
+      EXTERNAL ILAENZ
       INTRINSIC MIN
 
-      NB = MIN( 64, ILAENV( 1, prefix // 'GEHRD', ' ', n, lo, hi, -1 ) )
+      NB = MIN( 64, ILAENZ( 1, prefix // 'GEHRD', ' ', n, lo, hi, -1 ) )
       max_lwork = n * NB
       min_lwork = MIN(max_lwork,MAX(1,n))
 
@@ -31,15 +31,15 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: m,n,compute_uv
 
       INTEGER MINMN, MNTHR, MINWRK, MAXWRK, SMLSIZ, BDSPAC, BDSPAN
-      INTEGER            ILAENV, WRKBL
-      EXTERNAL           ILAENV
+      INTEGER            ILAENZ, WRKBL
+      EXTERNAL           ILAENZ
       INTRINSIC          INT, MAX, MIN
 
       MINMN = MIN( M, N )
       MNTHR = INT( MINMN*11.0D0 / 6.0D0 )
       MINWRK = 1
       MAXWRK = 1
-      SMLSIZ = ILAENV( 9, prefix // 'GESDD', ' ', 0, 0, 0, 0 )
+      SMLSIZ = ILAENZ( 9, prefix // 'GESDD', ' ', 0, 0, 0, 0 )
       IF( M.GE.N ) THEN
 *
 *           Compute space needed for DBDSDC
@@ -51,11 +51,11 @@ cf2py intent(in) :: m,n,compute_uv
 *
 *     Path 1 (M much larger than N, JOBZ='N')
 *
-               MAXWRK = N + N*ILAENV( 1, prefix // 'GEQRF', ' ', 
+               MAXWRK = N + N*ILAENZ( 1, prefix // 'GEQRF', ' ', 
      $              M, N, -1,
      $              -1 )
                MAXWRK = MAX( MAXWRK, 3*N+2*N*
-     $              ILAENV( 1, prefix // 'GEBRD', ' ',
+     $              ILAENZ( 1, prefix // 'GEBRD', ' ',
      $              N, N, -1, -1 ) )
                MAXWRK = MAX( MAXWRK, BDSPAC )
                MINWRK = BDSPAC
@@ -63,19 +63,19 @@ cf2py intent(in) :: m,n,compute_uv
 *     
 *     Path 4 (M much larger than N, JOBZ='A')
 *
-               WRKBL = N + N*ILAENV( 1, prefix // 'GEQRF', ' ',
+               WRKBL = N + N*ILAENZ( 1, prefix // 'GEQRF', ' ',
      $              M, N, -1, -1 )
-               WRKBL = MAX( WRKBL, N+M*ILAENV( 1, prefix // 'ORGQR',
+               WRKBL = MAX( WRKBL, N+M*ILAENZ( 1, prefix // 'ORGQR',
      $              ' ', M,
      $              M, N, -1 ) )
                WRKBL = MAX( WRKBL, 3*N+2*N*
-     $              ILAENV( 1, prefix // 'GEBRD', ' ',
+     $              ILAENZ( 1, prefix // 'GEBRD', ' ',
      $              N, N, -1, -1 ) )
                WRKBL = MAX( WRKBL, 3*N+N*
-     $              ILAENV( 1, prefix // 'ORMBR', 'QLN', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'QLN', 
      $              N, N, N, -1 ) )
                WRKBL = MAX( WRKBL, 3*N+N*
-     $              ILAENV( 1, prefix // 'ORMBR', 'PRT', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'PRT', 
      $              N, N, N, -1 ) )
                WRKBL = MAX( WRKBL, BDSPAC+2*N )
                MAXWRK = N*N + WRKBL
@@ -85,17 +85,17 @@ cf2py intent(in) :: m,n,compute_uv
 *
 *     Path 5 (M at least N, but not much larger)
 *     
-            WRKBL = 3*N + ( M+N )*ILAENV( 1, prefix // 'GEBRD', ' ',
+            WRKBL = 3*N + ( M+N )*ILAENZ( 1, prefix // 'GEBRD', ' ',
      $           M, N, -1, -1)
             IF (compute_uv.eq.0) THEN
                MAXWRK = MAX(WRKBL,BDSPAC + 3*N)
                MINWRK = 3*N + MAX(M,BDSPAC)
             ELSE
                MAXWRK = MAX( MAXWRK, 3*N+M*
-     $              ILAENV( 1, prefix // 'ORMBR', 'QLN', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'QLN', 
      $              M, M, N, -1 ) )
                MAXWRK = MAX( MAXWRK, 3*N+N*
-     $              ILAENV( 1, prefix // 'ORMBR', 'PRT', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'PRT', 
      $              N, N, N, -1 ) )
                MAXWRK = MAX( MAXWRK, BDSPAC+2*N+M )
                MINWRK = BDSPAC + 2*N + M
@@ -112,11 +112,11 @@ cf2py intent(in) :: m,n,compute_uv
 *     
 *     Path 1t (N much larger than M, JOBZ='N')
 *     
-               MAXWRK = M + M*ILAENV( 1, prefix // 'GELQF', ' ',
+               MAXWRK = M + M*ILAENZ( 1, prefix // 'GELQF', ' ',
      $              M, N, -1,
      $              -1 )
                MAXWRK = MAX( MAXWRK, 3*M+2*M*
-     $              ILAENV( 1, prefix // 'GEBRD', ' ',
+     $              ILAENZ( 1, prefix // 'GEBRD', ' ',
      $              M, M, -1, -1 ) )
                MAXWRK = MAX( MAXWRK, BDSPAC )
                MINWRK = BDSPAC
@@ -124,26 +124,26 @@ cf2py intent(in) :: m,n,compute_uv
 *
 *     Path 4t (N much larger than M, JOBZ='A')
 *     
-               WRKBL = M + M*ILAENV( 1, prefix // 'GELQF', ' ',
+               WRKBL = M + M*ILAENZ( 1, prefix // 'GELQF', ' ',
      $              M, N, -1, -1 )
-               WRKBL = MAX( WRKBL, M+N*ILAENV( 1, prefix // 'ORGLQ',
+               WRKBL = MAX( WRKBL, M+N*ILAENZ( 1, prefix // 'ORGLQ',
      $              ' ', N,
      $              N, M, -1 ) )
                WRKBL = MAX( WRKBL, 3*M+2*M*
-     $              ILAENV( 1, prefix // 'GEBRD', ' ', 
+     $              ILAENZ( 1, prefix // 'GEBRD', ' ', 
      $              M, M, -1, -1 ) )
                WRKBL = MAX( WRKBL, 3*M+M*
-     $              ILAENV( 1, prefix // 'ORMBR', 'QLN', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'QLN', 
      $              M, M, M, -1 ) )
                WRKBL = MAX( WRKBL, 3*M+M*
-     $              ILAENV( 1, prefix // 'ORMBR', 'PRT', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'PRT', 
      $              M, M, M, -1 ) )
                WRKBL = MAX( WRKBL, BDSPAC+2*M )
                MAXWRK = WRKBL + M*M
                MINWRK = BDSPAC + M*M + M + N
             ENDIF
          ELSE
-            WRKBL = 3*M + ( M+N )*ILAENV( 1, prefix // 'GEBRD', ' ',
+            WRKBL = 3*M + ( M+N )*ILAENZ( 1, prefix // 'GEBRD', ' ',
      $           M, N, -1,
      $           -1 )
             IF (compute_uv.eq.0) THEN
@@ -151,10 +151,10 @@ cf2py intent(in) :: m,n,compute_uv
                MINWRK = 3*M + MAX(N,BDSPAC)               
             ELSE
                MAXWRK = MAX( MAXWRK, 3*M+M*
-     $              ILAENV( 1, prefix // 'ORMBR', 'QLN', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'QLN', 
      $              M, M, N, -1 ) )
                MAXWRK = MAX( MAXWRK, 3*M+N*
-     $              ILAENV( 1, prefix // 'ORMBR', 'PRT', 
+     $              ILAENZ( 1, prefix // 'ORMBR', 'PRT', 
      $              N, N, M, -1 ) )
                MAXWRK = MAX( MAXWRK, BDSPAC+2*M )
                MINWRK = BDSPAC + 2*M + N
@@ -178,13 +178,13 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: m,n,nrhs
 
       INTEGER MAXWRK, MINMN, MINWRK, MM, MNTHR
-      INTEGER ILAENV, BDSPAC, MAXMN
-      EXTERNAL ILAENV
+      INTEGER ILAENZ, BDSPAC, MAXMN
+      EXTERNAL ILAENZ
       INTRINSIC          MAX, MIN
 
       MINMN = MIN( M, N )
       MAXMN = MAX( M, N )
-      MNTHR = ILAENV( 6, prefix // 'GELSS', ' ', M, N, NRHS, -1 )
+      MNTHR = ILAENZ( 6, prefix // 'GELSS', ' ', M, N, NRHS, -1 )
       MINWRK = 1
       MAXWRK = 0
       MM = M
@@ -193,10 +193,10 @@ cf2py intent(in) :: m,n,nrhs
 *     Path 1a - overdetermined, with many more rows than columns
 *     
          MM = N
-         MAXWRK = MAX( MAXWRK, N+N*ILAENV( 1, prefix //  'GEQRF', ' ',
+         MAXWRK = MAX( MAXWRK, N+N*ILAENZ( 1, prefix //  'GEQRF', ' ',
      $        M, N, -1, -1 ) )
          MAXWRK = MAX( MAXWRK, N+NRHS*
-     $        ILAENV( 1, prefix //  'ORMQR', 'LT', M, NRHS, N, -1 ) )
+     $        ILAENZ( 1, prefix //  'ORMQR', 'LT', M, NRHS, N, -1 ) )
       END IF
       IF( M.GE.N ) THEN
 *     
@@ -206,11 +206,11 @@ cf2py intent(in) :: m,n,nrhs
 *     
          BDSPAC = MAX( 1, 5*N )
          MAXWRK = MAX( MAXWRK, 3*N+( MM+N )*
-     $        ILAENV( 1, prefix // 'GEBRD', ' ', MM, N, -1, -1 ) )
+     $        ILAENZ( 1, prefix // 'GEBRD', ' ', MM, N, -1, -1 ) )
          MAXWRK = MAX( MAXWRK, 3*N+NRHS*
-     $        ILAENV( 1, prefix // 'ORMBR', 'QLT', MM, NRHS, N, -1 ) )
+     $        ILAENZ( 1, prefix // 'ORMBR', 'QLT', MM, NRHS, N, -1 ) )
          MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
-     $        ILAENV( 1, prefix // 'ORGBR', 'P', N, N, N, -1 ) )
+     $        ILAENZ( 1, prefix // 'ORGBR', 'P', N, N, N, -1 ) )
          MAXWRK = MAX( MAXWRK, BDSPAC )
          MAXWRK = MAX( MAXWRK, N*NRHS )
          MINWRK = MAX( 3*N+MM, 3*N+NRHS, BDSPAC )
@@ -228,14 +228,14 @@ cf2py intent(in) :: m,n,nrhs
 *     Path 2a - underdetermined, with many more columns
 *     than rows
 *     
-            MAXWRK = M + M*ILAENV( 1, prefix // 'GELQF', ' ', 
+            MAXWRK = M + M*ILAENZ( 1, prefix // 'GELQF', ' ', 
      $           M, N, -1, -1 )
             MAXWRK = MAX( MAXWRK, M*M+4*M+2*M*
-     $           ILAENV( 1, prefix //  'GEBRD', ' ', M, M, -1, -1 ) )
+     $           ILAENZ( 1, prefix //  'GEBRD', ' ', M, M, -1, -1 ) )
             MAXWRK = MAX( MAXWRK, M*M+4*M+NRHS*
-     $           ILAENV( 1, prefix // 'ORMBR', 'QLT', M, NRHS, M, -1 ))
+     $           ILAENZ( 1, prefix // 'ORMBR', 'QLT', M, NRHS, M, -1 ))
             MAXWRK = MAX( MAXWRK, M*M+4*M+( M-1 )*
-     $           ILAENV( 1, prefix // 'ORGBR', 'P', M, M, M, -1 ) )
+     $           ILAENZ( 1, prefix // 'ORGBR', 'P', M, M, M, -1 ) )
             MAXWRK = MAX( MAXWRK, M*M+M+BDSPAC )
             IF( NRHS.GT.1 ) THEN
                MAXWRK = MAX( MAXWRK, M*M+M+M*NRHS )
@@ -243,18 +243,18 @@ cf2py intent(in) :: m,n,nrhs
                MAXWRK = MAX( MAXWRK, M*M+2*M )
             END IF
             MAXWRK = MAX( MAXWRK, M+NRHS*
-     $           ILAENV( 1, prefix // 'ORMLQ', 'LT', N, NRHS, M, -1 ) )
+     $           ILAENZ( 1, prefix // 'ORMLQ', 'LT', N, NRHS, M, -1 ) )
             
          ELSE
 *     
 *     Path 2 - underdetermined
 *     
-            MAXWRK = 3*M + ( N+M )*ILAENV( 1, prefix // 'GEBRD', ' ',
+            MAXWRK = 3*M + ( N+M )*ILAENZ( 1, prefix // 'GEBRD', ' ',
      $           M, N, -1, -1 )
             MAXWRK = MAX( MAXWRK, 3*M+NRHS*
-     $           ILAENV( 1, prefix // 'ORMBR', 'QLT', M, NRHS, M, -1 ) )
+     $           ILAENZ( 1, prefix // 'ORMBR', 'QLT', M, NRHS, M, -1 ) )
             MAXWRK = MAX( MAXWRK, 3*M+M*
-     $           ILAENV( 1, prefix // 'ORGBR', 'P', M, N, M, -1 ) )
+     $           ILAENZ( 1, prefix // 'ORGBR', 'P', M, N, M, -1 ) )
             MAXWRK = MAX( MAXWRK, BDSPAC )
             MAXWRK = MAX( MAXWRK, N*NRHS )
          END IF
@@ -275,9 +275,9 @@ cf2py intent(out,out=minwrk) :: min_lwork
 cf2py intent(out,out=maxwrk) :: max_lwork
 cf2py intent(in) :: prefix
 cf2py intent(in) :: n
-      INTEGER ILAENV, NB
-      EXTERNAL ILAENV
-      NB = ILAENV( 1, prefix // 'GETRI', ' ', N, -1, -1, -1 )
+      INTEGER ILAENZ, NB
+      EXTERNAL ILAENZ
+      NB = ILAENZ( 1, prefix // 'GETRI', ' ', N, -1, -1, -1 )
       min_lwork = N
       max_lwork = N*NB
       end
@@ -296,30 +296,30 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: n
 
       LOGICAL WANTVL, WANTVR
-      INTEGER ILAENV, MINWRK, MAXWRK, MAXB, HSWORK, K
-      EXTERNAL ILAENV
+      INTEGER ILAENZ, MINWRK, MAXWRK, MAXB, HSWORK, K
+      EXTERNAL ILAENZ
       INTRINSIC          MAX, MIN
 
       WANTVL = compute_vl.eq.1
       WANTVR = compute_vr.eq.1
 
       MINWRK = 1
-      MAXWRK = 2*N + N*ILAENV( 1, prefix // 'GEHRD', ' ', N, 1, N, 0 )
+      MAXWRK = 2*N + N*ILAENZ( 1, prefix // 'GEHRD', ' ', N, 1, N, 0 )
       IF( ( .NOT.WANTVL ) .AND. ( .NOT.WANTVR ) ) THEN
          MINWRK = MAX( 1, 3*N )
-         MAXB = MAX( ILAENV( 8, prefix // 'HSEQR', 'EN', N, 1, N, -1 )
+         MAXB = MAX( ILAENZ( 8, prefix // 'HSEQR', 'EN', N, 1, N, -1 )
      $        , 2 )
-         K = MIN( MAXB, N, MAX( 2, ILAENV( 4, prefix // 'HSEQR', 'EN', N
+         K = MIN( MAXB, N, MAX( 2, ILAENZ( 4, prefix // 'HSEQR', 'EN', N
      $        , 1,  N, -1 ) ) )
          HSWORK = MAX( K*( K+2 ), 2*N )
          MAXWRK = MAX( MAXWRK, N+1, N+HSWORK )
       ELSE
          MINWRK = MAX( 1, 4*N )
          MAXWRK = MAX( MAXWRK, 2*N+( N-1 )*
-     $        ILAENV( 1, prefix // 'ORGHR', ' ', N, 1, N, -1 ) )
-         MAXB = MAX( ILAENV( 8, prefix // 'HSEQR', 'SV', N, 1, N, -1 ), 
+     $        ILAENZ( 1, prefix // 'ORGHR', ' ', N, 1, N, -1 ) )
+         MAXB = MAX( ILAENZ( 8, prefix // 'HSEQR', 'SV', N, 1, N, -1 ), 
      $        2  )
-         K = MIN( MAXB, N, MAX( 2, ILAENV( 4, prefix // 'HSEQR', 'SV', N
+         K = MIN( MAXB, N, MAX( 2, ILAENZ( 4, prefix // 'HSEQR', 'SV', N
      $        , 1, N, -1 ) ) )
          HSWORK = MAX( K*( K+2 ), 2*N )
          MAXWRK = MAX( MAXWRK, N+1, N+HSWORK )
@@ -342,8 +342,8 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: n
 
       CHARACTER UPLO
-      INTEGER ILAENV, NB
-      EXTERNAL ILAENV
+      INTEGER ILAENZ, NB
+      EXTERNAL ILAENZ
       INTRINSIC MAX
 
       UPLO = 'L'
@@ -351,7 +351,7 @@ cf2py intent(in) :: n
         UPLO = 'U'
       endif
 
-      NB = ILAENV( 1, prefix // 'HETRD', UPLO, N, -1, -1, -1 )
+      NB = ILAENZ( 1, prefix // 'HETRD', UPLO, N, -1, -1, -1 )
 
       min_lwork = MAX(1,2*N-1)
       max_lwork = MAX( 1, ( NB+1 )*N )
@@ -371,8 +371,8 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: n
 
       CHARACTER UPLO
-      INTEGER ILAENV, NB
-      EXTERNAL ILAENV
+      INTEGER ILAENZ, NB
+      EXTERNAL ILAENZ
       INTRINSIC MAX
 
       UPLO = 'L'
@@ -380,7 +380,7 @@ cf2py intent(in) :: n
         UPLO = 'U'
       end if
 
-      NB = ILAENV( 1, prefix // 'SYTRD', UPLO, N, -1, -1, -1 )
+      NB = ILAENZ( 1, prefix // 'SYTRD', UPLO, N, -1, -1, -1 )
 
       min_lwork = MAX(1,3*N-1)
       max_lwork = MAX( 1, ( NB+2 )*N )
@@ -401,25 +401,25 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: n
 
       INTEGER            HSWORK, MAXWRK, MINWRK, MAXB, K
-      INTEGER            ILAENV
-      EXTERNAL           ILAENV
+      INTEGER            ILAENZ
+      EXTERNAL           ILAENZ
       INTRINSIC          MAX, MIN
 
-      MAXWRK = N + N*ILAENV( 1, prefix // 'GEHRD', ' ', N, 1, N, 0 )
+      MAXWRK = N + N*ILAENZ( 1, prefix // 'GEHRD', ' ', N, 1, N, 0 )
       MINWRK = MAX( 1, 2*N )
       IF( compute_v.eq.0 ) THEN
-         MAXB = MAX( ILAENV( 8, prefix // 'HSEQR',
+         MAXB = MAX( ILAENZ( 8, prefix // 'HSEQR',
      $        'SN', N, 1, N, -1 ), 2 )
-         K = MIN( MAXB, N, MAX( 2, ILAENV( 4, prefix // 'HSEQR', 
+         K = MIN( MAXB, N, MAX( 2, ILAENZ( 4, prefix // 'HSEQR', 
      $    'SN', N, 1, N, -1 ) ) )
          HSWORK = MAX( K*( K+2 ), 2*N )
          MAXWRK = MAX( MAXWRK, HSWORK, 1 )
       ELSE
          MAXWRK = MAX( MAXWRK, N+( N-1 )*
-     $        ILAENV( 1, prefix // 'UNGHR', ' ', N, 1, N, -1 ) )
-         MAXB = MAX( ILAENV( 8, prefix // 'HSEQR',
+     $        ILAENZ( 1, prefix // 'UNGHR', ' ', N, 1, N, -1 ) )
+         MAXB = MAX( ILAENZ( 8, prefix // 'HSEQR',
      $        'EN', N, 1, N, -1 ), 2 )
-         K = MIN( MAXB, N, MAX( 2, ILAENV( 4, prefix // 'HSEQR',
+         K = MIN( MAXB, N, MAX( 2, ILAENZ( 4, prefix // 'HSEQR',
      $        'EN', N, 1, N, -1 ) ) )
          HSWORK = MAX( K*( K+2 ), 2*N )
          MAXWRK = MAX( MAXWRK, HSWORK, 1 )
@@ -443,11 +443,11 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: m,n
 
       INTEGER NB
-      INTEGER ILAENV
-      EXTERNAL ILAENV
+      INTEGER ILAENZ
+      EXTERNAL ILAENZ
       INTRINSIC MAX
 
-      NB = ILAENV( 1, prefix // 'GEQRF', ' ', M, N, -1, -1 )
+      NB = ILAENZ( 1, prefix // 'GEQRF', ' ', M, N, -1, -1 )
 
       min_lwork = MAX(1,N)
       max_lwork = MAX(1,N*NB)
@@ -466,15 +466,15 @@ cf2py intent(in) :: prefix
 cf2py intent(in) :: m,n
 
       INTEGER NB
-      INTEGER ILAENV
-      EXTERNAL ILAENV
+      INTEGER ILAENZ
+      EXTERNAL ILAENZ
       INTRINSIC MAX
 
       if ((prefix.eq.'d').or.(prefix.eq.'s')
      $     .or.(prefix.eq.'D').or.(prefix.eq.'S')) then
-         NB = ILAENV( 1, prefix // 'ORGQR', ' ', M, N, -1, -1 )
+         NB = ILAENZ( 1, prefix // 'ORGQR', ' ', M, N, -1, -1 )
       else
-         NB = ILAENV( 1, prefix // 'UNGQR', ' ', M, N, -1, -1 )
+         NB = ILAENZ( 1, prefix // 'UNGQR', ' ', M, N, -1, -1 )
       endif
       min_lwork = MAX(1,N)
       max_lwork = MAX(1,N*NB)
diff --git a/scipy/odr/__odrpack.c b/scipy/odr/__odrpack.c
index 2d136d1..39d9139 100644
--- a/scipy/odr/__odrpack.c
+++ b/scipy/odr/__odrpack.c
@@ -12,7 +12,7 @@
 #include "odrpack.h"
 
 
-void F_FUNC(dodrc,DODRC)(void (*fcn)(int *n, int *m, int *np, int *nq, int *ldn, int *ldm, 
+int F_FUNC(dodrc,DODRC)(void (*fcn)(int *n, int *m, int *np, int *nq, int *ldn, int *ldm, 
             int *ldnp, double *beta, double *xplusd, int *ifixb, int *ifixx, 
             int *ldifx, int *ideval, double *f, double *fjacb, double *fjacd, 
             int *istop), 
@@ -23,7 +23,7 @@ void F_FUNC(dodrc,DODRC)(void (*fcn)(int *n, int *m, int *np, int *nq, int *ldn,
            int *maxit, int *iprint, int *lunerr, int *lunrpt, double *stpb,
            double *stpd, int *ldstpd, double *sclb, double *scld, int *ldscld,
            double *work, int *lwork, int *iwork, int *liwork, int *info);
-void F_FUNC(dwinf,DWINF)(int *n, int *m, int *np, int *nq, int *ldwe, int *ld2we, int *isodr,
+int F_FUNC(dwinf,DWINF)(int *n, int *m, int *np, int *nq, int *ldwe, int *ld2we, int *isodr,
         int *delta, int *eps, int *xplus, int *fn, int *sd, int *vcv, int *rvar,
         int *wss, int *wssde, int *wssep, int *rcond, int *eta, int *olmav, 
         int *tau, int *alpha, int *actrs, int *pnorm, int *rnors, int *prers,
@@ -32,8 +32,8 @@ void F_FUNC(dwinf,DWINF)(int *n, int *m, int *np, int *nq, int *ldwe, int *ld2we
         int *fs, int *fjacb, int *we1, int *diff, int *delts, int *deltn, 
         int *t, int *tt, int *omega, int *fjacd, int *wrk1, int *wrk2, 
         int *wrk3, int *wrk4, int *wrk5, int *wrk6, int *wrk7, int *lwkmn);
-void F_FUNC(dluno,DLUNO)(int *lun, char *fn, int fnlen);
-void F_FUNC(dlunc,DLUNC)(int *lun);
+int F_FUNC(dluno,DLUNO)(int *lun, char *fn, int fnlen);
+int F_FUNC(dlunc,DLUNC)(int *lun);
 
 
 
diff --git a/scipy/optimize/__minpack.h b/scipy/optimize/__minpack.h
index 8a2042d..6aca268 100644
--- a/scipy/optimize/__minpack.h
+++ b/scipy/optimize/__minpack.h
@@ -47,12 +47,12 @@
 #endif
 #endif
 
-extern void CHKDER(int*,int*,double*,double*,double*,int*,double*,double*,int*,double*);
-extern void HYBRD(void*,int*,double*,double*,double*,int*,int*,int*,double*,double*,int*,double*,int*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,double*);
-extern void HYBRJ(void*,int*,double*,double*,double*,int*,double*,int*,double*,int*,double*,int*,int*,int*,int*,double*,int*,double*,double*,double*,double*,double*);
-extern void LMDIF(void*,int*,int*,double*,double*,double*,double*,double*,int*,double*,double*,int*,double*,int*,int*,int*,double*,int*,int*,double*,double*,double*,double*,double*);
-extern void LMDER(void*,int*,int*,double*,double*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*,int*,int*,int*,double*,double*,double*,double*,double*);
-extern void LMSTR(void*,int*,int*,double*,double*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*,int*,int*,int*,double*,double*,double*,double*,double*);
+extern int CHKDER(int*,int*,double*,double*,double*,int*,double*,double*,int*,double*);
+extern int HYBRD(void*,int*,double*,double*,double*,int*,int*,int*,double*,double*,int*,double*,int*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,double*);
+extern int HYBRJ(void*,int*,double*,double*,double*,int*,double*,int*,double*,int*,double*,int*,int*,int*,int*,double*,int*,double*,double*,double*,double*,double*);
+extern int LMDIF(void*,int*,int*,double*,double*,double*,double*,double*,int*,double*,double*,int*,double*,int*,int*,int*,double*,int*,int*,double*,double*,double*,double*,double*);
+extern int LMDER(void*,int*,int*,double*,double*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*,int*,int*,int*,double*,double*,double*,double*,double*);
+extern int LMSTR(void*,int*,int*,double*,double*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*,int*,int*,int*,double*,double*,double*,double*,double*);
 
 int raw_multipack_calling_function(int *n, double *x, double *fvec, int *iflag)
 {
diff --git a/scipy/optimize/_lsq/setup.py b/scipy/optimize/_lsq/setup.py
index b9222a0..863400b 100644
--- a/scipy/optimize/_lsq/setup.py
+++ b/scipy/optimize/_lsq/setup.py
@@ -5,7 +5,7 @@ def configuration(parent_package='', top_path=None):
     from numpy.distutils.misc_util import Configuration
     config = Configuration('_lsq', parent_package, top_path)
     config.add_extension('givens_elimination',
-                         sources=['givens_elimination.c'])
+                         sources=['givens_elimination.c'],include_dirs=['../../linalg'])
     return config
 
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
index e17532d..a7a5629 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgscon.c
@@ -80,9 +80,6 @@ cgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     int    kase, kase1, onenrm, i;
     float ainvnm;
     complex *work;
-    extern int crscl_(int *, complex *, complex *, int *);
-
-    extern int clacon_(int *, complex *, complex *, float *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
index db31e35..1da9ac0 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsequ.c
@@ -92,7 +92,6 @@ cgsequ(SuperMatrix *A, float *r, float *c, float *rowcnd,
     int i, j, irow;
     float rcmin, rcmax;
     float bignum, smlnum;
-    extern float slamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
index e7c2bc7..0dde69b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cgsrfs.c
@@ -158,14 +158,6 @@ cgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     float   *rwork;
     int      *iwork;
 
-    extern int clacon_(int *, complex *, complex *, float *, int *);
-#ifdef _CRAY
-    extern int CCOPY(int *, complex *, int *, complex *, int *);
-    extern int CSAXPY(int *, complex *, complex *, int *, complex *, int *);
-#else
-    extern int ccopy_(int *, complex *, int *, complex *, int *);
-    extern int caxpy_(int *, complex *, complex *, int *, complex *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
index d206d5a..8e64576 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/clacon.c
@@ -85,9 +85,6 @@ clacon_(int *n, complex *v, complex *x, float *est, int *kase)
     static int i, j;
     float temp;
     float safmin;
-    extern float slamch_(char *);
-    extern int icmax1_(int *, complex *, int *);
-    extern double scsum1_(int *, complex *, int *);
 
     safmin = slamch_("Safe minimum");
     if ( *kase == 0 ) {
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
index d91474a..f33f10d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgscon.c
@@ -81,9 +81,6 @@ dgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     double ainvnm;
     double *work;
     int    *iwork;
-    extern int drscl_(int *, double *, double *, int *);
-
-    extern int dlacon_(int *, double *, double *, int *, double *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
index 73870d4..222bf66 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsequ.c
@@ -92,7 +92,6 @@ dgsequ(SuperMatrix *A, double *r, double *c, double *rowcnd,
     int i, j, irow;
     double rcmin, rcmax;
     double bignum, smlnum;
-    extern double dlamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
index 55531b0..792509c 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dgsrfs.c
@@ -158,14 +158,6 @@ dgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     double   *rwork;
     int      *iwork;
 
-    extern int dlacon_(int *, double *, double *, int *, double *, int *);
-#ifdef _CRAY
-    extern int SCOPY(int *, double *, int *, double *, int *);
-    extern int SSAXPY(int *, double *, double *, int *, double *, int *);
-#else
-    extern int dcopy_(int *, double *, int *, double *, int *);
-    extern int daxpy_(int *, double *, double *, int *, double *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
index 951fe7a..7359570 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlacon.c
@@ -80,15 +80,6 @@ dlacon_(int *n, double *v, double *x, int *isgn, double *est, int *kase)
     static double altsgn, estold;
     static int i, j;
     double temp;
-#ifdef _CRAY
-    extern int ISAMAX(int *, double *, int *);
-    extern double SASUM(int *, double *, int *);
-    extern int SCOPY(int *, double *, int *, double *, int *);
-#else
-    extern int idamax_(int *, double *, int *);
-    extern double dasum_(int *, double *, int *);
-    extern int dcopy_(int *, double *, int *, double *, int *);
-#endif
 #define d_sign(a, b) (b >= 0 ? fabs(a) : -fabs(a))    /* Copy sign */
 #define i_dnnt(a) \
 	( a>=0 ? floor(a+.5) : -floor(.5-a) ) /* Round to nearest integer */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
index e117915..28ffdbb 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
@@ -76,10 +76,7 @@ double dlamch_(char *cmach)
     static int imin, imax;
     static int lrnd;
     static double rmin, rmax, t, rmach;
-    extern int lsame_(char *, char *);
     static double small, sfmin;
-    extern /* Subroutine */ int dlamc2_(int *, int *, int *, 
-	    double *, int *, double *, int *, double *);
     static int it;
     static double rnd, eps;
 
@@ -197,7 +194,6 @@ int dlamc1_(int *beta, int *t, int *rnd, int
     static double a, b, c, f;
     static int lbeta;
     static double savec;
-    extern double dlamc3_(double *, double *);
     static int lieee1;
     static double t1, t2;
     static int lt;
@@ -435,13 +431,7 @@ int dlamc2_(int *beta, int *t, int *rnd,
     static double small;
     static int gpmin;
     static double third, lrmin, lrmax, sixth;
-    extern /* Subroutine */ int dlamc1_(int *, int *, int *, 
-	    int *);
-    extern double dlamc3_(double *, double *);
     static int lieee1;
-    extern /* Subroutine */ int dlamc4_(int *, double *, int *), 
-	    dlamc5_(int *, int *, int *, int *, int *, 
-	    double *);
     static int lt, ngnmin, ngpmin;
     static double one, two;
 
@@ -725,7 +715,6 @@ int dlamc4_(int *emin, double *start, int *base)
     static double zero, a;
     static int i;
     static double rbase, b1, b2, c1, c2, d1, d2;
-    extern double dlamc3_(double *, double *);
     static double one;
 
     a = *start;
@@ -840,7 +829,6 @@ int dlamc5_(int *beta, int *p, int *emin,
     static int uexp, i;
     static double y, z;
     static int nbits;
-    extern double dlamc3_(double *, double *);
     static double recbas;
     static int exbits, expsum, try__;
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
index 5a7203d..0ac71c0 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
@@ -16,10 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void ccopy_(int *, complex [], int *, complex [], int *);
-#if SCIPY_FIX
-extern double dlamch_(char *);
-#endif
 
 #if 0
 static complex *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
index 44173c8..fa1b999 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_cdefs.h"
 
-extern void cswap_(int *, complex [], int *, complex [], int *);
-extern void caxpy_(int *, complex *, complex [], int *, complex [], int *);
-extern void ccopy_(int *, complex [], int *, complex [], int *);
-extern float scasum_(int *, complex *, int *);
-extern float scnrm2_(int *, complex *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int icamax_(int *, complex [], int *);
 
 static float *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
index e9162a7..22eae38 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dcopy_to_ucol.c
@@ -16,7 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void dcopy_(int *, double [], int *, double [], int *);
 
 #if 0
 static double *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
index a08c85c..3174de3 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ddrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_ddefs.h"
 
-extern void dswap_(int *, double [], int *, double [], int *);
-extern void daxpy_(int *, double *, double [], int *, double [], int *);
-extern void dcopy_(int *, double [], int *, double [], int *);
-extern double dasum_(int *, double *, int *);
-extern double dnrm2_(int *, double *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int idamax_(int *, double [], int *);
 
 static double *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
index b9fd387..eee65c8 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
@@ -16,10 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void scopy_(int *, float [], int *, float [], int *);
-#if SCIPY_FIX
-extern double dlamch_(char *);
-#endif
 
 #if 0
 static float *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
index 108f849..7ce483d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_sdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_sdefs.h"
 
-extern void sswap_(int *, float [], int *, float [], int *);
-extern void saxpy_(int *, float *, float [], int *, float [], int *);
-extern void scopy_(int *, float [], int *, float [], int *);
-extern float sasum_(int *, float *, int *);
-extern float snrm2_(int *, float *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int isamax_(int *, float [], int *);
 
 static float *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
index ddf3a63..cef2341 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zcopy_to_ucol.c
@@ -16,7 +16,6 @@
 int num_drop_U;
 #endif
 
-extern void zcopy_(int *, doublecomplex [], int *, doublecomplex [], int *);
 
 #if 0
 static doublecomplex *A;  /* used in _compare_ only */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
index 0a140d4..2207950 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zdrop_row.c
@@ -13,13 +13,6 @@
 #include <stdlib.h>
 #include "slu_zdefs.h"
 
-extern void zswap_(int *, doublecomplex [], int *, doublecomplex [], int *);
-extern void zaxpy_(int *, doublecomplex *, doublecomplex [], int *, doublecomplex [], int *);
-extern void zcopy_(int *, doublecomplex [], int *, doublecomplex [], int *);
-extern double dzasum_(int *, doublecomplex *, int *);
-extern double dznrm2_(int *, doublecomplex *, int *);
-extern double dnrm2_(int *, double [], int *);
-extern int izamax_(int *, doublecomplex [], int *);
 
 static double *A;  /* used in _compare_ only */
 static int _compare_(const void *a, const void *b)
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
index 5afc93b..1a2c4ca 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
@@ -3,6 +3,14 @@
 
 #include <stdlib.h>
 
+#include"f2c.h"
+#define integer int
+#define logical int
+#include"clapack.h"
+#undef integer
+#undef logical
+
+
 /*
  * Support routines
  */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
index a474967..ae4a511 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgscon.c
@@ -81,9 +81,6 @@ sgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     float ainvnm;
     float *work;
     int    *iwork;
-    extern int srscl_(int *, float *, float *, int *);
-
-    extern int slacon_(int *, float *, float *, int *, float *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
index 3637d7e..cf435db 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsequ.c
@@ -92,7 +92,6 @@ sgsequ(SuperMatrix *A, float *r, float *c, float *rowcnd,
     int i, j, irow;
     float rcmin, rcmax;
     float bignum, smlnum;
-    extern float slamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
index a93bc5b..c685106 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgsrfs.c
@@ -158,14 +158,6 @@ sgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     float   *rwork;
     int      *iwork;
 
-    extern int slacon_(int *, float *, float *, int *, float *, int *);
-#ifdef _CRAY
-    extern int SCOPY(int *, float *, int *, float *, int *);
-    extern int SSAXPY(int *, float *, float *, int *, float *, int *);
-#else
-    extern int scopy_(int *, float *, int *, float *, int *);
-    extern int saxpy_(int *, float *, float *, int *, float *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
index d33ca33..212ac4b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sgssvx.c
@@ -11,6 +11,8 @@
  */
 #include "slu_sdefs.h"
 
+extern float slangs(char *, SuperMatrix *);
+
 /*! \brief
  *
  * <pre>
@@ -357,8 +359,6 @@ sgssvx(superlu_options_t *options, SuperMatrix *A, int *perm_c, int *perm_r,
     double    t0;      /* temporary time */
     double    *utime;
 
-    /* External functions */
-    extern float slangs(char *, SuperMatrix *);
 
     Bstore = B->Store;
     Xstore = X->Store;
@@ -552,7 +552,9 @@ printf("dgssvx: Fact=%4d, Trans=%4d, equed=%c\n",
         } else {
 	    *(unsigned char *)norm = 'I';
         }
-        anorm = slangs(norm, AA);
+        anorm = slangs(norm, AA);    /* External functions */
+        extern float slangs(char *, SuperMatrix *);
+
         sgscon(norm, L, U, anorm, rcond, stat, info);
         utime[RCOND] = SuperLU_timer_() - t0;
     }
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
index 4e02fdc..d49f040 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slacon.c
@@ -80,15 +80,6 @@ slacon_(int *n, float *v, float *x, int *isgn, float *est, int *kase)
     static float altsgn, estold;
     static int i, j;
     float temp;
-#ifdef _CRAY
-    extern int ISAMAX(int *, float *, int *);
-    extern float SASUM(int *, float *, int *);
-    extern int SCOPY(int *, float *, int *, float *, int *);
-#else
-    extern int isamax_(int *, float *, int *);
-    extern float sasum_(int *, float *, int *);
-    extern int scopy_(int *, float *, int *, float *, int *);
-#endif
 #define d_sign(a, b) (b >= 0 ? fabs(a) : -fabs(a))    /* Copy sign */
 #define i_dnnt(a) \
 	( a>=0 ? floor(a+.5) : -floor(.5-a) ) /* Round to nearest integer */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
index 09cf6e2..3155468 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
@@ -58,7 +58,7 @@
    ===================================================================== 
 </pre>
 */
-float slamch_(char *cmach)
+doublereal slamch_(char *cmach)
 {
 /* >>Start of File<<   
        Initialized data */
@@ -75,10 +75,7 @@ float slamch_(char *cmach)
     static int imin, imax;
     static int lrnd;
     static float rmin, rmax, t, rmach;
-    extern int lsame_(char *, char *);
     static float small, sfmin;
-    extern /* Subroutine */ int slamc2_(int *, int *, int *, float 
-	    *, int *, float *, int *, float *);
     static int it;
     static float rnd, eps;
 
@@ -205,7 +202,6 @@ int slamc1_(int *beta, int *t, int *rnd, int
     static float savec;
     static int lieee1;
     static float t1, t2;
-    extern double slamc3_(float *, float *);
     static int lt;
     static float one, qtr;
 
@@ -443,12 +439,6 @@ int slamc2_(int *beta, int *t, int *rnd, float *
     static int gpmin;
     static float third, lrmin, lrmax, sixth;
     static int lieee1;
-    extern /* Subroutine */ int slamc1_(int *, int *, int *, 
-	    int *);
-    extern double slamc3_(float *, float *);
-    extern /* Subroutine */ int slamc4_(int *, float *, int *), 
-	    slamc5_(int *, int *, int *, int *, int *, 
-	    float *);
     static int lt, ngnmin, ngpmin;
     static float one, two;
 
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
index acb82bc..c9d0946 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/sldperm.c
@@ -13,8 +13,8 @@
 
 extern int_t mc64id_(int_t*);
 extern int_t mc64ad_(int_t*, int_t*, int_t*, int_t [], int_t [], double [],
-		    int_t*, int_t [], int_t*, int_t[], int_t*, double [],
-		    int_t [], int_t []);
+            int_t*, int_t [], int_t*, int_t[], int_t*, double [],
+            int_t [], int_t []);
 
 /*! \brief
  *
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
index 24d1374..cea93d6 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_cdefs.h
@@ -236,7 +236,6 @@ extern int     sp_cgemv (char *, complex, SuperMatrix *, complex *,
 extern int     sp_cgemm (char *, char *, int, int, int, complex,
 			SuperMatrix *, complex *, int, complex, 
 			complex *, int);
-extern         float slamch_(char *);
 
 
 /*! \brief Memory-related */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
index 386ad68..72f5355 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_dcomplex.h
@@ -18,7 +18,10 @@
 #ifndef DCOMPLEX_INCLUDE
 #define DCOMPLEX_INCLUDE
 
-typedef struct { double r, i; } doublecomplex;
+#include"scipy_slu_config.h"
+
+// defined in clapack
+//typedef struct { double r, i; } doublecomplex;
 
 
 /* Macro definitions */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
index c17490d..fef343d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_scomplex.h
@@ -17,8 +17,9 @@
 
 #ifndef SCOMPLEX_INCLUDE
 #define SCOMPLEX_INCLUDE
-
-typedef struct { float r, i; } complex;
+#include"scipy_slu_config.h"
+// defined in  CLAPACK
+//typedef struct { float r, i; } complex;
 
 
 /* Macro definitions */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
index 745d76f..0c2a45b 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h
@@ -235,7 +235,6 @@ extern int     sp_sgemv (char *, float, SuperMatrix *, float *,
 extern int     sp_sgemm (char *, char *, int, int, int, float,
 			SuperMatrix *, float *, int, float, 
 			float *, int);
-extern         float slamch_(char *);
 
 
 /*! \brief Memory-related */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
index f41b4ca..1560371 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
@@ -348,8 +348,6 @@ extern int     spcoletree (int *, int *, int *, int, int, int *);
 extern int     *TreePostorder (int, int *);
 extern double  SuperLU_timer_ ();
 extern int     sp_ienv (int);
-extern int     lsame_ (char *, char *);
-extern int     xerbla_ (char *, int *);
 extern void    ifill (int *, int, int);
 extern void    snode_profile (int, int *);
 extern void    super_stats (int, int *);
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
index 8bb95aa..8b6651d 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgscon.c
@@ -80,9 +80,6 @@ zgscon(char *norm, SuperMatrix *L, SuperMatrix *U,
     int    kase, kase1, onenrm, i;
     double ainvnm;
     doublecomplex *work;
-    extern int zrscl_(int *, doublecomplex *, doublecomplex *, int *);
-
-    extern int zlacon_(int *, doublecomplex *, doublecomplex *, double *, int *);
 
     
     /* Test the input parameters. */
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
index 657637d..b04e46f 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsequ.c
@@ -92,7 +92,6 @@ zgsequ(SuperMatrix *A, double *r, double *c, double *rowcnd,
     int i, j, irow;
     double rcmin, rcmax;
     double bignum, smlnum;
-    extern double dlamch_(char *);
     
     /* Test the input parameters. */
     *info = 0;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
index 2ed0481..110bfe1 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zgsrfs.c
@@ -158,14 +158,6 @@ zgsrfs(trans_t trans, SuperMatrix *A, SuperMatrix *L, SuperMatrix *U,
     double   *rwork;
     int      *iwork;
 
-    extern int zlacon_(int *, doublecomplex *, doublecomplex *, double *, int *);
-#ifdef _CRAY
-    extern int CCOPY(int *, doublecomplex *, int *, doublecomplex *, int *);
-    extern int CSAXPY(int *, doublecomplex *, doublecomplex *, int *, doublecomplex *, int *);
-#else
-    extern int zcopy_(int *, doublecomplex *, int *, doublecomplex *, int *);
-    extern int zaxpy_(int *, doublecomplex *, doublecomplex *, int *, doublecomplex *, int *);
-#endif
 
     Astore = A->Store;
     Aval   = Astore->nzval;
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
index b2cd1ed..6934f1e 100644
--- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zlacon.c
@@ -85,9 +85,6 @@ zlacon_(int *n, doublecomplex *v, doublecomplex *x, double *est, int *kase)
     static int i, j;
     double temp;
     double safmin;
-    extern double dlamch_(char *);
-    extern int izmax1_(int *, doublecomplex *, int *);
-    extern double dzsum1_(int *, doublecomplex *, int *);
 
     safmin = dlamch_("Safe minimum");
     if ( *kase == 0 ) {
diff --git a/scipy/sparse/linalg/dsolve/SuperLU/scipychanges.patch b/before/scipy/sparse/linalg/dsolve/SuperLU/scipychanges.patch
deleted file mode 100644
index 7a0a3ba..0000000
--- a/scipy/sparse/linalg/dsolve/SuperLU/scipychanges.patch
+++ /dev/null
@@ -1,378 +0,0 @@
-    ENH: sparse/dsolve: re-apply patches on top of SuperLU 4.3
-
-    - Hook up USER_* routines to Scipy
-
-    - Fix a dubious format string
-
-    - Sprinkle volatile into dlamc/slamc implementation to avoid an infinite loop
-
-    - Eliminate a crash for singular matrices for which pivoting fails
-
-    - Do not exit(1) when ILU decomposition encounters singularity;
-      instead call ABORT (which is hooked up in Scipy)
-
-    - Add missing declarations of dlamch_ (call without declaration to
-      functions returning floating point can cause NaN to appear later on, on i386).
-
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
-index a14ea72..f60c4dc 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/cpivotL.c
-@@ -125,7 +125,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
-index 678ac35..e117915 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dlamch.c
-@@ -673,9 +673,13 @@ double dlamc3_(double *a, double *b)
- {
- /* >>Start of File<<   
-        System generated locals */
--    double ret_val;
-+    volatile double ret_val;
-+    volatile double x;
-+    volatile double y;
- 
--    ret_val = *a + *b;
-+    x = *a;
-+    y = *b;
-+    ret_val = x + y;
- 
-     return ret_val;
- 
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c
-index bcfa96d..6a66068 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/dpivotL.c
-@@ -124,7 +124,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
-index b6b0328..5a7203d 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_ccopy_to_ucol.c
-@@ -17,6 +17,9 @@ int num_drop_U;
- #endif
- 
- extern void ccopy_(int *, complex [], int *, complex [], int *);
-+#if SCIPY_FIX
-+extern double dlamch_(char *);
-+#endif
- 
- #if 0
- static complex *A;  /* used in _compare_ only */
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c
-index d806485..98991d7 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_cpivotL.c
-@@ -136,9 +136,13 @@ ilu_cpivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -151,9 +155,13 @@ ilu_cpivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c
-index 33c316d..0cbb21d 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_dpivotL.c
-@@ -134,9 +134,13 @@ ilu_dpivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -149,9 +153,13 @@ ilu_dpivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
-index 7e0e97c..b9fd387 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_scopy_to_ucol.c
-@@ -17,6 +17,9 @@ int num_drop_U;
- #endif
- 
- extern void scopy_(int *, float [], int *, float [], int *);
-+#if SCIPY_FIX
-+extern double dlamch_(char *);
-+#endif
- 
- #if 0
- static float *A;  /* used in _compare_ only */
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c
-index 25b6b00..ff36657 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_spivotL.c
-@@ -134,9 +134,13 @@ ilu_spivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -149,9 +153,13 @@ ilu_spivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c
-index dafea2b..4ea86b1 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/ilu_zpivotL.c
-@@ -136,9 +136,13 @@ ilu_zpivotL(
- 
-     /* Test for singularity */
-     if (pivmax < 0.0) {
-+#if SCIPY_FIX
-+	ABORT("[0]: matrix is singular");
-+#else
- 	fprintf(stderr, "[0]: jcol=%d, SINGULAR!!!\n", jcol);
- 	fflush(stderr);
- 	exit(1);
-+#endif
-     }
-     if ( pivmax == 0.0 ) {
- 	if (diag != EMPTY)
-@@ -151,9 +155,13 @@ ilu_zpivotL(
- 	    for (icol = jcol; icol < n; icol++)
- 		if (marker[swap[icol]] <= jcol) break;
- 	    if (icol >= n) {
-+#if SCIPY_FIX
-+		ABORT("[1]: matrix is singular");
-+#else
- 		fprintf(stderr, "[1]: jcol=%d, SINGULAR!!!\n", jcol);
- 		fflush(stderr);
- 		exit(1);
-+#endif
- 	    }
- 
- 	    *pivrow = swap[icol];
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
-new file mode 100644
-index 0000000..5afc93b
---- /dev/null
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/scipy_slu_config.h
-@@ -0,0 +1,36 @@
-+#ifndef SCIPY_SLU_CONFIG_H
-+#define SCIPY_SLU_CONFIG_H
-+
-+#include <stdlib.h>
-+
-+/*
-+ * Support routines
-+ */
-+void superlu_python_module_abort(char *msg);
-+void *superlu_python_module_malloc(size_t size);
-+void superlu_python_module_free(void *ptr);
-+
-+#define USER_ABORT  superlu_python_module_abort
-+#define USER_MALLOC superlu_python_module_malloc
-+#define USER_FREE   superlu_python_module_free
-+
-+#define SCIPY_FIX 1
-+
-+/*
-+ * Fortran configuration
-+ */
-+#if defined(NO_APPEND_FORTRAN)
-+#if defined(UPPERCASE_FORTRAN)
-+#define UpCase 1
-+#else
-+#define NoChange 1
-+#endif
-+#else
-+#if defined(UPPERCASE_FORTRAN)
-+#error Uppercase and trailing slash in Fortran names not supported
-+#else
-+#define Add_ 1
-+#endif
-+#endif
-+
-+#endif
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
-index ec3cd61..09cf6e2 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slamch.c
-@@ -684,11 +684,13 @@ double slamc3_(float *a, float *b)
- 
- /* >>Start of File<<   
-        System generated locals */
--    float ret_val;
--
--
-+    volatile float ret_val;
-+    volatile float x;
-+    volatile float y;
- 
--    ret_val = *a + *b;
-+    x = *a;
-+    y = *b;
-+    ret_val = x + y;
- 
-     return ret_val;
- 
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h
-index 7bcd1bc..80b8aa1 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_Cnames.h
-@@ -19,6 +19,7 @@
- #ifndef __SUPERLU_CNAMES /* allow multiple inclusions */
- #define __SUPERLU_CNAMES
- 
-+#include "scipy_slu_config.h"
- 
- #define ADD_       0
- #define ADD__      1
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
-index 30b5f9b..f41b4ca 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_util.h
-@@ -22,6 +22,8 @@
- #include <assert.h>
- #include "superlu_enum_consts.h"
- 
-+#include "scipy_slu_config.h"
-+
- /***********************************************************************
-  * Macros
-  ***********************************************************************/
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c
-index 2a6950c..a9f0de5 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/spivotL.c
-@@ -124,7 +124,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c
-index 858fbbc..4c19e77 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/util.c
-@@ -29,7 +29,7 @@
- 
- void superlu_abort_and_exit(char* msg)
- {
--    fprintf(stderr, msg);
-+    fprintf(stderr, "%s\n", msg);
-     exit (-1);
- }
- 
-diff --git a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c
-index ce4f513..e134896 100644
---- a/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c
-+++ b/scipy/sparse/linalg/dsolve/SuperLU/SRC/zpivotL.c
-@@ -125,7 +125,16 @@ if ( jcol == MIN_COL ) {
-     /* Test for singularity */
-     if ( pivmax == 0.0 ) {
- #if 1
-+#if SCIPY_FIX
-+	if (pivptr < nsupr) {
-+	    *pivrow = lsub_ptr[pivptr];
-+	}
-+	else {
-+	    *pivrow = diagind;
-+	}
-+#else
- 	*pivrow = lsub_ptr[pivptr];
-+#endif
- 	perm_r[*pivrow] = jcol;
- #else
- 	perm_r[diagind] = jcol;
diff --git a/scipy/sparse/linalg/dsolve/_superlu_utils.c b/scipy/sparse/linalg/dsolve/_superlu_utils.c
index c2a10a7..eb85c3b 100644
--- a/scipy/sparse/linalg/dsolve/_superlu_utils.c
+++ b/scipy/sparse/linalg/dsolve/_superlu_utils.c
@@ -79,12 +79,12 @@ void superlu_python_module_free(void *ptr)
  * Stubs for Harwell Subroutine Library functions that SuperLU tries to call.
  */
 
-void mc64id_(int *a)
+int mc64id_(int *a)
 {
     superlu_python_module_abort("chosen functionality not available");
 }
 
-void mc64ad_(int *a, int *b, int *c, int d[], int e[], double f[],
+int mc64ad_(int *a, int *b, int *c, int d[], int e[], double f[],
 	     int *g, int h[], int *i, int j[], int *k, double l[],
 	     int m[], int n[])
 {
diff --git a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
index 5eb0bb1..03fb23d 100644
--- a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
+++ b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/debug.h
@@ -1,16 +1,16 @@
-c
+
 c\SCCS Information: @(#) 
 c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
 c
 c     %---------------------------------%
 c     | See debug.doc for documentation |
 c     %---------------------------------%
-      integer  logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-      common /debug/ 
-     &         logfil, ndigit, mgetv0,
-     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c      integer  logfil, ndigit, mgetv0,
+c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
+c      common /debug/ 
+c     &         logfil, ndigit, mgetv0,
+c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
+c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
+c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
diff --git a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
index 66a8e9f..1f2d49c 100644
--- a/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
+++ b/scipy/sparse/linalg/eigen/arpack/ARPACK/SRC/stat.h
@@ -5,17 +5,17 @@ c
 c\SCCS Information: @(#) 
 c FILE: stat.h   SID: 2.2   DATE OF SID: 11/16/95   RELEASE: 2 
 c
-      real       t0, t1, t2, t3, t4, t5
-      save       t0, t1, t2, t3, t4, t5
+c      real       t0, t1, t2, t3, t4, t5
+c      save       t0, t1, t2, t3, t4, t5
 c
-      integer    nopx, nbx, nrorth, nitref, nrstrt
-      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
-      common /timing/ 
-     &           nopx, nbx, nrorth, nitref, nrstrt,
-     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-     &           tmvopx, tmvbx, tgetv0, titref, trvec
+c      integer    nopx, nbx, nrorth, nitref, nrstrt
+c      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
+c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
+c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
+c     &           tmvopx, tmvbx, tgetv0, titref, trvec
+c      common /timing/ 
+c     &           nopx, nbx, nrorth, nitref, nrstrt,
+c     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
+c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
+c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
+c     &           tmvopx, tmvbx, tgetv0, titref, trvec
diff --git a/scipy/spatial/qhull_blas.h b/scipy/spatial/qhull_blas.h
index 2e235db..666630e 100644
--- a/scipy/spatial/qhull_blas.h
+++ b/scipy/spatial/qhull_blas.h
@@ -16,6 +16,10 @@
 #endif
 #endif
 
+int dgetrs_(char *trans, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);
+int dgetrf_(int *m, int *n, double *a, int *lda, int *ipiv, int *info);
+int dgecon_(char *norm, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);
+
 #define qh_dgetrf F_FUNC(dgetrf,DGETRF)
 #define qh_dgecon F_FUNC(dgecon,DGECON)
 #define qh_dgetrs F_FUNC(dgetrs,DGETRS)
diff --git a/scipy/special/amos/.master.gz b/before/scipy/special/amos/.master.gz
deleted file mode 100644
diff --git a/scipy/special/cdf_wrappers.c b/scipy/special/cdf_wrappers.c
index 08121f2..7ee9b28 100644
--- a/scipy/special/cdf_wrappers.c
+++ b/scipy/special/cdf_wrappers.c
@@ -52,7 +52,7 @@ static void show_error(char *func, int status, int bound) {
   }
 }
 
-extern void F_FUNC(cdfbet,CDFBET)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfbet,CDFBET)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
 
 double cdfbet3_wrap(double p, double b, double x) {
   int which=3;
@@ -83,7 +83,7 @@ double cdfbet4_wrap(double a, double p, double x) {
 }
 
 
-extern void F_FUNC(cdfbin,CDFBIN)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfbin,CDFBIN)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
 
 double cdfbin2_wrap(double p, double xn, double pr) {
   int which=2;
@@ -113,7 +113,7 @@ double cdfbin3_wrap(double s, double p, double pr) {
   return xn;
 }
 
-extern void F_FUNC(cdfchi,CDFCHI)(int*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfchi,CDFCHI)(int*,double*,double*,double*,double*,int*,double*);
 double cdfchi3_wrap(double p, double x){
   int which=3;
   double q=1.0-p, df, bound;
@@ -128,7 +128,7 @@ double cdfchi3_wrap(double p, double x){
   return df;
 }
 
-extern void F_FUNC(cdfchn,CDFCHN)(int*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfchn,CDFCHN)(int*,double*,double*,double*,double*,double*,int*,double*);
 double cdfchn1_wrap(double x, double df, double nc) {
   int which=1;
   double q, p, bound;
@@ -184,7 +184,7 @@ double cdfchn4_wrap(double x, double df, double p) {
   return nc;
 }
 
-extern void F_FUNC(cdff,CDFF)(int*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdff,CDFF)(int*,double*,double*,double*,double*,double*,int*,double*);
 /*
 double cdff1_wrap(double dfn, double dfd, double f) {
   int which=1;
@@ -243,7 +243,7 @@ double cdff4_wrap(double dfn, double p, double f) {
 }
 
 
-extern void F_FUNC(cdffnc,CDFFNC)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdffnc,CDFFNC)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
 double cdffnc1_wrap(double dfn, double dfd, double nc, double f) {
   int which=1;
   double q, p, bound;
@@ -316,7 +316,7 @@ double cdffnc5_wrap(double dfn, double dfd, double p, double f) {
 /* scl == a in gdtr
    shp == b in gdtr
 */ 
-extern void F_FUNC(cdfgam,CDFGAM)(int*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfgam,CDFGAM)(int*,double*,double*,double*,double*,double*,int*,double*);
 double cdfgam1_wrap(double scl, double shp, double x) {
   int which=1;
   double q, p, bound;
@@ -372,7 +372,7 @@ double cdfgam4_wrap(double p, double shp, double x) {
   return scl;
 }
 
-extern void F_FUNC(cdfnbn,CDFNBN)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfnbn,CDFNBN)(int*,double*,double*,double*,double*,double*,double*,int*,double*);
 double cdfnbn2_wrap(double p, double xn, double pr) {
   int which=2;
   double q=1.0-p, s, ompr=1.0-pr, bound;
@@ -401,7 +401,7 @@ double cdfnbn3_wrap(double s, double p, double pr) {
   return xn;
 }
 
-extern void F_FUNC(cdfnor,CDFNOR)(int*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfnor,CDFNOR)(int*,double*,double*,double*,double*,double*,int*,double*);
 double cdfnor3_wrap(double p, double std, double x) {
   int which=3;
   double q=1.0-p, mn, bound;
@@ -430,7 +430,7 @@ double cdfnor4_wrap(double mn, double p, double x) {
   return std;
 }
 
-extern void F_FUNC(cdfpoi,CDFPOI)(int*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdfpoi,CDFPOI)(int*,double*,double*,double*,double*,int*,double*);
 double cdfpoi2_wrap(double p, double xlam){
   int which=2;
   double q=1.0-p, s, bound;
@@ -445,7 +445,7 @@ double cdfpoi2_wrap(double p, double xlam){
   return s;
 }
 
-extern void F_FUNC(cdft,CDFT)(int*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdft,CDFT)(int*,double*,double*,double*,double*,int*,double*);
 double cdft1_wrap(double df, double t){
   int which=1;
   double q, p, bound;
@@ -487,7 +487,7 @@ double cdft3_wrap(double p, double t){
   return df;
 }
 
-extern void F_FUNC(cdftnc,CDFTNC)(int*,double*,double*,double*,double*,double*,int*,double*);
+extern int F_FUNC(cdftnc,CDFTNC)(int*,double*,double*,double*,double*,double*,int*,double*);
 double cdftnc1_wrap(double df, double nc, double t) {
   int which=1;
   double q, p, bound;
diff --git a/scipy/special/lapack_defs.h b/scipy/special/lapack_defs.h
index fb8fd80..d84cd3f 100644
--- a/scipy/special/lapack_defs.h
+++ b/scipy/special/lapack_defs.h
@@ -16,5 +16,6 @@
 #endif
 #endif
 
+int dstevr_(char *jobz, char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);
 #define c_dstevr F_FUNC(dstevr,DSTEVR)
 
diff --git a/scipy/special/specfun_wrappers.c b/scipy/special/specfun_wrappers.c
index 8772dd1..d38505f 100644
--- a/scipy/special/specfun_wrappers.c
+++ b/scipy/special/specfun_wrappers.c
@@ -26,45 +26,46 @@
 extern double cephes_psi(double);
 extern double cephes_struve(double, double);
 
-extern void F_FUNC(cgama,CGAMA)(double*,double*,int*,double*,double*);
-extern void F_FUNC(cpsi,CPSI)(double*,double*,double*,double*);
-extern void F_FUNC(hygfz,HYGFZ)(double*,double*,double*,npy_cdouble*,npy_cdouble*);
-extern void F_FUNC(cchg,CCHG)(double*,double*,npy_cdouble*,npy_cdouble*);
-extern void F_FUNC(chgm,CHGM)(double*,double*,double*,double*);
-extern void F_FUNC(chgu,CHGU)(double*,double*,double*,double*,int*);
-extern void F_FUNC(itairy,ITAIRY)(double*,double*,double*,double*,double*);
-extern void F_FUNC(e1xb,E1XB)(double*,double*);
-extern void F_FUNC(e1z,E1Z)(npy_cdouble*,npy_cdouble*);
-extern void F_FUNC(eix,EIX)(double*,double*);
-extern void F_FUNC(cerror,CERROR)(npy_cdouble*,npy_cdouble*);
-extern void F_FUNC(stvh0,STVH0)(double*,double*);
-extern void F_FUNC(stvh1,STVH1)(double*,double*);
-extern void F_FUNC(stvhv,STVHV)(double*,double*,double*);
-extern void F_FUNC(stvl0,STVL0)(double*,double*);
-extern void F_FUNC(stvl1,STVL1)(double*,double*);
-extern void F_FUNC(stvlv,STVLV)(double*,double*,double*);
-extern void F_FUNC(itsh0,ITSH0)(double*,double*);
-extern void F_FUNC(itth0,ITTH0)(double*,double*);
-extern void F_FUNC(itsl0,ITSL0)(double*,double*);
-extern void F_FUNC(klvna,KLVNA)(double*,double*,double*,double*,double*,double*,double*,double*,double*);
-extern void F_FUNC(itjya,ITJYA)(double*,double*,double*);
-extern void F_FUNC(ittjya,ITTJYA)(double*,double*,double*);
-extern void F_FUNC(itika,ITIKA)(double*,double*,double*);
-extern void F_FUNC(ittika,ITTIKA)(double*,double*,double*);
-extern void F_FUNC(cfc,CFC)(npy_cdouble*,npy_cdouble*,npy_cdouble*);
-extern void F_FUNC(cfs,CFS)(npy_cdouble*,npy_cdouble*,npy_cdouble*);
-extern void F_FUNC(cva2,CVA2)(int*,int*,double*,double*);
-extern void F_FUNC(mtu0,MTU0)(int*,int*,double*,double*,double*,double*);
-extern void F_FUNC(mtu12,MTU12)(int*,int*,int*,double*,double*,double*,double*,double*,double*);
-extern void F_FUNC(lpmv,LPMV)(double*,int*,double*,double*);
-extern void F_FUNC(pbwa,PBWA)(double*,double*,double*,double*,double*,double*);
-extern void F_FUNC(pbdv,PBDV)(double*,double*,double*,double*,double*,double*);
-extern void F_FUNC(pbvv,PBVV)(double*,double*,double*,double*,double*,double*);
-extern void F_FUNC(segv,SEGV)(int*,int*,double*,int*,double*,double*);
-extern void F_FUNC(aswfa,ASWFA)(int*,int*,double*,double*,int*,double*,double*,double*);
-extern void F_FUNC(rswfp,RSWFP)(int*,int*,double*,double*,double*,int*,double*,double*,double*,double*);
-extern void F_FUNC(rswfo,RSWFO)(int*,int*,double*,double*,double*,int*,double*,double*,double*,double*);
-extern void F_FUNC(ffk,FFK)(int*,double*,double*,double*,double*,double*,double*,double*,double*,double*);
+extern int F_FUNC(cgama,CGAMA)(double*,double*,int*,double*,double*);
+extern int F_FUNC(cpsi,CPSI)(double*,double*,double*,double*);
+extern int F_FUNC(hygfz,HYGFZ)(double*,double*,double*,npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(cchg,CCHG)(double*,double*,npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(chgm,CHGM)(double*,double*,double*,double*);
+extern int F_FUNC(chgu,CHGU)(double*,double*,double*,double*,int*);
+extern int F_FUNC(itairy,ITAIRY)(double*,double*,double*,double*,double*);
+extern int F_FUNC(e1xb,E1XB)(double*,double*);
+extern int F_FUNC(e1z,E1Z)(npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(eixz,E1Z)(npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(eix,EIX)(double*,double*);
+extern int F_FUNC(cerror,CERROR)(npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(stvh0,STVH0)(double*,double*);
+extern int F_FUNC(stvh1,STVH1)(double*,double*);
+extern int F_FUNC(stvhv,STVHV)(double*,double*,double*);
+extern int F_FUNC(stvl0,STVL0)(double*,double*);
+extern int F_FUNC(stvl1,STVL1)(double*,double*);
+extern int F_FUNC(stvlv,STVLV)(double*,double*,double*);
+extern int F_FUNC(itsh0,ITSH0)(double*,double*);
+extern int F_FUNC(itth0,ITTH0)(double*,double*);
+extern int F_FUNC(itsl0,ITSL0)(double*,double*);
+extern int F_FUNC(klvna,KLVNA)(double*,double*,double*,double*,double*,double*,double*,double*,double*);
+extern int F_FUNC(itjya,ITJYA)(double*,double*,double*);
+extern int F_FUNC(ittjya,ITTJYA)(double*,double*,double*);
+extern int F_FUNC(itika,ITIKA)(double*,double*,double*);
+extern int F_FUNC(ittika,ITTIKA)(double*,double*,double*);
+extern int F_FUNC(cfc,CFC)(npy_cdouble*,npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(cfs,CFS)(npy_cdouble*,npy_cdouble*,npy_cdouble*);
+extern int F_FUNC(cva2,CVA2)(int*,int*,double*,double*);
+extern int F_FUNC(mtu0,MTU0)(int*,int*,double*,double*,double*,double*);
+extern int F_FUNC(mtu12,MTU12)(int*,int*,int*,double*,double*,double*,double*,double*,double*);
+extern int F_FUNC(lpmv,LPMV)(double*,int*,double*,double*);
+extern int F_FUNC(pbwa,PBWA)(double*,double*,double*,double*,double*,double*);
+extern int F_FUNC(pbdv,PBDV)(double*,double*,double*,double*,double*,double*);
+extern int F_FUNC(pbvv,PBVV)(double*,double*,double*,double*,double*,double*);
+extern int F_FUNC(segv,SEGV)(int*,int*,double*,int*,double*,double*);
+extern int F_FUNC(aswfa,ASWFA)(int*,int*,double*,double*,int*,double*,double*,double*);
+extern int F_FUNC(rswfp,RSWFP)(int*,int*,double*,double*,double*,int*,double*,double*,double*,double*);
+extern int F_FUNC(rswfo,RSWFO)(int*,int*,double*,double*,double*,int*,double*,double*,double*,double*);
+extern int F_FUNC(ffk,FFK)(int*,double*,double*,double*,double*,double*,double*,double*,double*,double*);
 
 
 /* This must be linked with fortran
