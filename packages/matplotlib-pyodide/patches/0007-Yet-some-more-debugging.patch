From 3914aa8eab3137f172d6e7e81bdb1cefcd841d50 Mon Sep 17 00:00:00 2001
From: Agriya Khetarpal <74401230+agriyakhetarpal@users.noreply.github.com>
Date: Tue, 10 Dec 2024 15:44:35 +0530
Subject: [PATCH] Yet some more debugging

---
 matplotlib_pyodide/html5_canvas_backend.py | 98 ++++++++++++++++++++--
 1 file changed, 89 insertions(+), 9 deletions(-)

diff --git a/matplotlib_pyodide/html5_canvas_backend.py b/matplotlib_pyodide/html5_canvas_backend.py
index 2d56f41..4d6a92f 100644
--- a/matplotlib_pyodide/html5_canvas_backend.py
+++ b/matplotlib_pyodide/html5_canvas_backend.py
@@ -314,7 +314,8 @@ class RendererHTMLCanvas(RendererBase):
         """
         import sys
 
-        print(f"Drawing math text: '{s}' at ({x}, {y})", file=sys.stderr)  # noqa: B907
+        print(f"Starting math text for: '{s}'", file=sys.stderr)  # noqa: B907
+        print(f"Initial position: ({x}, {y})", file=sys.stderr)
 
         # Parse the math text to get paths and metrics
         width, height, depth, glyphs, rects = self.mathtext_parser.parse(
@@ -327,6 +328,7 @@ class RendererHTMLCanvas(RendererBase):
         )
         print(f"Number of glyphs: {len(glyphs)}", file=sys.stderr)
         print(f"Number of rectangles: {len(rects)}", file=sys.stderr)
+        print(f"DPI: {self.dpi}, Canvas height: {self.height}", file=sys.stderr)
 
         # Save the canvas state
         self.ctx.save()
@@ -335,43 +337,99 @@ class RendererHTMLCanvas(RendererBase):
         self.ctx.translate(x, baseline_y)
 
         # Move to text position and apply rotation if needed
+        print(f"Transformed y-coordinate: {self.height - y}", file=sys.stderr)
+
+        print(
+            f"Initial transform matrix: a={self.ctx.currentTransform.a}, b={self.ctx.currentTransform.b}, c={self.ctx.currentTransform.c}, d={self.ctx.currentTransform.d}, e={self.ctx.currentTransform.e}, f={self.ctx.currentTransform.f}",
+            file=sys.stderr,
+        )
         self.ctx.translate(x, self.height - y)
+
+        current_transform = self.ctx.getTransform()
+        print(
+            f"After our transforms: a={current_transform.a}, b={current_transform.b}, c={current_transform.c}, d={current_transform.d}, e={current_transform.e}, f={current_transform.f}",
+            file=sys.stderr,
+        )
+
+        self.ctx.scale(1, -1)
+
         if angle != 0:
             self.ctx.rotate(-math.radians(angle))
+            print(f"Applied rotation of {angle} degrees", file=sys.stderr)
 
         # Set up text rendering style
-        self.ctx.fillStyle = self._matplotlib_color_to_CSS(
+        fill_style = self._matplotlib_color_to_CSS(
             gc.get_rgb(), gc.get_alpha(), gc.get_forced_alpha()
         )
+        print(f"Setting fill style to: {fill_style}", file=sys.stderr)
+        self.ctx.fillStyle = fill_style
+
+        # adding some additional debugging here to see what is going on:
+        # Draw a rectangle around the text area
+        self.ctx.strokeStyle = "#FF0000"  # Red
+        self.ctx.lineWidth = 1
+        self.ctx.strokeRect(0, -height, width, height)
 
         # Draw each glyph in the mathematical expression
+        print("\n=== Processing glyphs ===", file=sys.stderr)
+        i = 0
         for font, fontsize, _, ox, oy in glyphs:
+            print(f"\nGlyph {i + 1}:", file=sys.stderr)
+            print(f"  Character: '{s}'", file=sys.stderr)  # noqa: B907
+            print(f"  Position: ({ox}, {oy})", file=sys.stderr)
+            print(f"  Font size: {fontsize}", file=sys.stderr)
+
             # Move to glyph position
             self.ctx.save()
-            self.ctx.translate(ox, -oy)
+            self.ctx.translate(ox, oy)
 
             # Get the glyph's path data
             font.set_size(fontsize, self.dpi)
             verts, codes = font.get_path()
 
             verts = verts * fontsize / font.units_per_EM
+            print(
+                f"  Path has {len(verts)} vertices and {len(codes)} codes",
+                file=sys.stderr,
+            )
+
+            # DEBUGGING
+            # Draw debug point at glyph origin
+            self.ctx.fillStyle = "#00FF00"  # Green
+            self.ctx.beginPath()
+            self.ctx.arc(0, 0, 2, 0, 2 * math.pi)
+            self.ctx.fill()
+
+            # Reset fill style for actual glyph
+            self.ctx.fillStyle = fill_style
+            # END DEBUGGING
 
             # Convert the glyph to a Path object
             path = Path(verts, codes)
 
+            # DEBUGGING MORE: darw the path with a visible stroke first
+            self._path_helper(self.ctx, path, Affine2D())
+            self.ctx.lineWidth = 0.5
+            self.ctx.strokeStyle = "#0000FF"  # Blue
+            self.ctx.stroke()
+
             # Draw the path
-            transform = Affine2D().scale(1.0, -1.0)
+            transform = Affine2D()
             self._path_helper(self.ctx, path, transform)
             self.ctx.fill()
 
             self.ctx.restore()
+            i += 1
 
         # Draw rectangles (fraction bars, roots, etc.)
-        for x1, y1, x2, y2 in rects:
-            self.ctx.fillRect(x1, -y2, x2 - x1, y2 - y1)
+        for i, (x1, y1, x2, y2) in enumerate(rects):
+            print(f"Rectangle {i + 1}: ({x1}, {y1}) to ({x2}, {y2})", file=sys.stderr)
+            i += 1
+            self.ctx.fillRect(x1, y1, x2 - x1, y2 - y1)
 
         # Restore the canvas state
         self.ctx.restore()
+        print("\n=== Math text rendering complete ===\n", file=sys.stderr)
 
     def _draw_math_text(self, gc, x, y, s, prop, angle):
         """Draw mathematical text using the most appropriate method.
@@ -452,18 +510,40 @@ class RendererHTMLCanvas(RendererBase):
         self.ctx.lineWidth = self.points_to_pixels(gc.get_linewidth())
 
     def _path_helper(self, ctx, path, transform, clip=None):
+        import sys  # debugging
+
         ctx.beginPath()
-        for points, code in path.iter_segments(transform, remove_nans=True, clip=clip):
+        segment_count = 0
+        for points, code in path.iter_segments(
+            transform, remove_nans=True, clip=clip, simplify=False
+        ):
+            segment_count += 1
             if code == Path.MOVETO:
                 ctx.moveTo(points[0], points[1])
+                print(f"  MoveTo: ({points[0]}, {points[1]})", file=sys.stderr)
             elif code == Path.LINETO:
                 ctx.lineTo(points[0], points[1])
+                print(f"  LineTo: ({points[0]}, {points[1]})", file=sys.stderr)
             elif code == Path.CURVE3:
-                ctx.quadraticCurveTo(*points)
+                ctx.quadraticCurveTo(points[0], points[1], points[2], points[3])
+                print(
+                    f"  QuadraticCurveTo: control=({points[0]}, {points[1]}), end=({points[2]}, {points[3]})",
+                    file=sys.stderr,
+                )
             elif code == Path.CURVE4:
-                ctx.bezierCurveTo(*points)
+                ctx.bezierCurveTo(
+                    points[0], points[1], points[2], points[3], points[4], points[5]
+                )
+                print(
+                    f"  BezierCurveTo: control1=({points[0]}, {points[1]}), control2=({points[2]}, {points[3]}), end=({points[4]}, {points[5]})",
+                    file=sys.stderr,
+                )
             elif code == Path.CLOSEPOLY:
                 ctx.closePath()
+                print("  ClosePath", file=sys.stderr)
+
+        print(f"DEBUGGING total segments processed: {segment_count}", file=sys.stderr)
+        print("--- Path helper debugger ending ---\n", file=sys.stderr)
 
     def draw_path(self, gc, path, transform, rgbFace=None):
         self._set_style(gc, rgbFace)
-- 
2.39.5 (Apple Git-154)

