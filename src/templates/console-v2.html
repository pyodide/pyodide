<!DOCTYPE html>
<!--
Pyodide Console v2 (Experimental)

This is an experimental version of the Pyodide console that provides
an enhanced terminal experience using xterm.js. This implementation replaces
the jQuery Terminal used in the original console with a more feature-rich
terminal emulator that offers better performance and modern terminal capabilities.

Note: This console is still under development and may not have all the features
of the stable console.
 -->
<html>
  <head>
    <title>Pyodide Console</title>
    <meta charset="UTF-8" />
    <meta
      http-equiv="origin-trial"
      content="Aq6vv/4syIkcyMszFgCc9LlH0kX88jdE7SXfCFnh2RQN0nhhL8o6PCQ2oE3a7n3mC7+d9n89Repw5HYBtjarDw4AAAB3eyJvcmlnaW4iOiJodHRwczovL3B5b2RpZGUub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJBc3NlbWJseUpTUHJvbWlzZUludGVncmF0aW9uIiwiZXhwaXJ5IjoxNzMwMjQ2Mzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZX0="
    />
    <meta
      http-equiv="origin-trial"
      content="Ai8IXb0XqedlM/Q2guWXFfBkKiYY9uaPZpdjHqc8y0ZvpAfK9SKzp/dIuFH+txG/HEKxt59uIkk39hhWrhNgbw4AAABieyJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwMDAiLCJmZWF0dXJlIjoiV2ViQXNzZW1ibHlKU1Byb21pc2VJbnRlZ3JhdGlvbiIsImV4cGlyeSI6MTczMDI0NjM5OX0="
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@xterm/xterm@5.4.0/css/xterm.css"
    />
    <link
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêç</text></svg>"
      rel="icon"
    />
    <script src="https://unpkg.com/@xterm/xterm@5.4.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/@xterm/addon-fit@0.9.0/lib/addon-fit.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        background-color: #000000;
        font-family: "Monaco", "Menlo", "Courier New", monospace;
        overflow: hidden;
      }

      #terminal {
        position: fixed;
        inset: 10px;
      }

      #loading {
        display: inline-block;
        width: 50px;
        height: 50px;
        position: fixed;
        top: 50%;
        left: 50%;
        border: 3px solid rgba(172, 237, 255, 0.5);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        -webkit-animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          -webkit-transform: rotate(360deg);
        }
      }
      @-webkit-keyframes spin {
        to {
          -webkit-transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="loading"></div>
    <div id="terminal"></div>
    <script type="module">
      // ============================================================================
      // COMMAND - Base class for all commands
      // ============================================================================
      class Command {
        constructor(context) {
          this.context = context;
        }

        execute(data) {
          throw new Error("execute must be implemented");
        }

        canExecute(data) {
          return true;
        }
      }

      // ============================================================================
      // NORMAL MODE COMMANDS
      // ============================================================================
      class ExecuteCommand extends Command {
        async execute(data) {
          this.context.term.write("\r\n");
          await this.context.executeCommand();
          this.context.buffer = "";
          this.context.cursorIndex = 0;
          this.context.term.write(this.context.prompt);
        }
      }

      class InterruptCommand extends Command {
        execute(data) {
          this.context.pyconsole.buffer.clear();
          this.context.buffer = "";
          this.context.cursorIndex = 0;
          this.context.term.write(
            "^C\r\nKeyboardInterrupt\r\n" + this.context.PS1
          );
          this.context.prompt = this.context.PS1;
          this.context.historyIndex = null;
        }
      }

      class EnterReverseSearchCommand extends Command {
        canExecute(data) {
          return (
            this.context.prompt === this.context.PS1 &&
            this.context.history.length > 0
          );
        }

        execute(data) {
          this.context.transitionTo("reverseSearch");
        }
      }

      class PasteCommand extends Command {
        async execute(data) {
          try {
            const clipboard = await navigator.clipboard.readText();
            this.context.insertText(clipboard);
          } catch (e) {
            console.error("Failed to read clipboard:", e);
          }
        }
      }

      class BackspaceCommand extends Command {
        canExecute(data) {
          return this.context.cursorIndex > 0;
        }

        execute(data) {
          this.context.deleteChar();
        }
      }

      class HistoryUpCommand extends Command {
        canExecute(data) {
          return this.context.prompt === this.context.PS1;
        }

        execute(data) {
          this.context.navigateHistory(-1);
        }
      }

      class HistoryDownCommand extends Command {
        canExecute(data) {
          return (
            this.context.prompt === this.context.PS1 &&
            this.context.historyIndex !== null
          );
        }

        execute(data) {
          this.context.navigateHistory(1);
        }
      }

      class MoveCursorRightCommand extends Command {
        canExecute(data) {
          return this.context.cursorIndex < this.context.buffer.length;
        }

        execute(data) {
          this.context.moveCursor(1);
        }
      }

      class MoveCursorLeftCommand extends Command {
        canExecute(data) {
          return this.context.cursorIndex > 0;
        }

        execute(data) {
          this.context.moveCursor(-1);
        }
      }

      class InsertTextCommand extends Command {
        canExecute(data) {
          return data && data.length >= 1;
        }

        execute(data) {
          const normalizedData = data.replace(/\u00a0/g, " ");
          this.context.insertText(normalizedData);
        }
      }

      // ============================================================================
      // REVERSE SEARCH MODE COMMANDS
      // ============================================================================
      class AcceptSearchCommand extends Command {
        async execute(data) {
          this.context.transitionTo("normal");
          this.context.term.write("\r\n");
          await this.context.executeCommand();
          this.context.buffer = "";
          this.context.cursorIndex = 0;
          this.context.term.write(this.context.prompt);
        }
      }

      class CancelSearchWithInterruptCommand extends Command {
        execute(data) {
          this.context.state.cancelSearch();
          this.context.transitionTo("normal");
          this.context.term.write(
            "\r\nKeyboardInterrupt\r\n" + this.context.prompt
          );
        }
      }

      class CancelSearchCommand extends Command {
        execute(data) {
          this.context.state.cancelSearch();
          this.context.transitionTo("normal");
          this.context.term.write("");
        }
      }

      class NextSearchMatchCommand extends Command {
        execute(data) {
          this.context.state.findNextMatch();
        }
      }

      class SearchBackspaceCommand extends Command {
        canExecute(data) {
          return (
            this.context.state.query && this.context.state.query.length > 0
          );
        }

        execute(data) {
          this.context.state.removeChar();
        }
      }

      class ExitSearchKeepResultCommand extends Command {
        execute(data) {
          this.context.transitionTo("normal");
          // Clear the search line and refresh with normal prompt
          this.context.refreshLine();
        }
      }

      class AddSearchCharCommand extends Command {
        canExecute(data) {
          return data && data.length === 1 && data >= " " && data <= "~";
        }

        execute(data) {
          this.context.state.addChar(data);
        }
      }

      // ============================================================================
      // COMMAND - Maps keys to commands for each state
      // ============================================================================
      class NormalStateCommands {
        constructor(context) {
          this.context = context;
          this.commands = new Map();
          this.setupCommands();
        }

        setupCommands() {
          this.commands.set("\r", new ExecuteCommand(this.context)); // Enter key
          this.commands.set("\u0003", new InterruptCommand(this.context)); // Ctrl+C
          this.commands.set(
            "\u0012",
            new EnterReverseSearchCommand(this.context)
          ); // Ctrl+R
          this.commands.set("\u0016", new PasteCommand(this.context)); // Ctrl+V
          this.commands.set("\u007F", new BackspaceCommand(this.context)); // Backspace
          this.commands.set("\x1B[A", new HistoryUpCommand(this.context)); // Up arrow
          this.commands.set("\x1B[B", new HistoryDownCommand(this.context)); // Down arrow
          this.commands.set("\x1B[C", new MoveCursorRightCommand(this.context)); // Right arrow
          this.commands.set("\x1B[D", new MoveCursorLeftCommand(this.context)); // Left arrow
          this.commands.set("default", new InsertTextCommand(this.context));
        }

        async execute(data) {
          const command =
            this.commands.get(data) || this.commands.get("default");
          if (command && command.canExecute(data)) {
            await command.execute(data);
          }
        }
      }

      class ReverseSearchStateCommands {
        constructor(context) {
          this.context = context;
          this.commands = new Map();
          this.setupCommands();
        }

        setupCommands() {
          this.commands.set("\r", new AcceptSearchCommand(this.context)); // Enter key
          this.commands.set(
            "\u0003",
            new CancelSearchWithInterruptCommand(this.context)
          ); // Ctrl+C
          this.commands.set("\u0007", new CancelSearchCommand(this.context)); // Ctrl+G
          this.commands.set("\u0012", new NextSearchMatchCommand(this.context)); // Ctrl+R
          this.commands.set("\u007F", new SearchBackspaceCommand(this.context)); // Backspace
          this.commands.set(
            "\x1B[A",
            new ExitSearchKeepResultCommand(this.context)
          ); // Up arrow
          this.commands.set(
            "\x1B[B",
            new ExitSearchKeepResultCommand(this.context)
          ); // Down arrow
          this.commands.set(
            "\x1B[C",
            new ExitSearchKeepResultCommand(this.context)
          ); // Right arrow
          this.commands.set(
            "\x1B[D",
            new ExitSearchKeepResultCommand(this.context)
          ); // Left arrow
          this.commands.set(
            "\x09",
            new ExitSearchKeepResultCommand(this.context)
          ); // Tab key
          this.commands.set("default", new AddSearchCharCommand(this.context));
        }

        async execute(data) {
          const command =
            this.commands.get(data) || this.commands.get("default");
          if (command && command.canExecute(data)) {
            await command.execute(data);
          }
        }
      }

      // ============================================================================
      // STATE - Base class for input states
      // ============================================================================
      class InputState {
        constructor(context) {
          this.context = context;
        }

        handleInput(data) {
          throw new Error("Not Implemented");
        }

        enter() {}
        exit() {}
      }

      // ============================================================================
      // NORMAL INPUT STATE
      // ============================================================================
      class NormalInputState extends InputState {
        constructor(context) {
          super(context);
          this.commands = new NormalStateCommands(context);
        }

        async handleInput(data) {
          await this.commands.execute(data);
        }
      }

      // ============================================================================
      // REVERSE SEARCH STATE
      // ============================================================================
      class ReverseSearchState extends InputState {
        constructor(context) {
          super(context);
          this.commands = new ReverseSearchStateCommands(context);
          this.query = "";
          this.index = -1;
          this.savedBuffer = context.buffer;
        }

        async handleInput(data) {
          await this.commands.execute(data);
        }

        enter() {
          this.savedBuffer = this.context.buffer;
          this.context.buffer = "";
          this.query = "";
          this.index = -1;
          this.context.cursorIndex = 0;
          this.updateDisplay();
        }

        addChar(char) {
          this.query += char;
          this.index = this.context.searchHistory(this.query);
          if (this.index >= 0) {
            this.context.buffer = this.context.history[this.index];
            this.context.cursorIndex = this.context.buffer.length;
          }
          this.updateDisplay();
        }

        removeChar() {
          if (this.query.length > 0) {
            this.query = this.query.slice(0, -1);
            if (this.query) {
              this.index = this.context.searchHistory(this.query);
              if (this.index >= 0) {
                this.context.buffer = this.context.history[this.index];
                this.context.cursorIndex = this.context.buffer.length;
              }
            } else {
              this.index = -1;
              this.context.buffer = "";
              this.context.cursorIndex = 0;
            }
            this.updateDisplay();
          }
        }

        findNextMatch() {
          if (this.query && this.index > 0) {
            this.index = this.context.searchHistory(this.query, this.index - 1);
            if (this.index >= 0) {
              this.context.buffer = this.context.history[this.index];
              this.context.cursorIndex = this.context.buffer.length;
            }
            this.updateDisplay();
          }
        }

        cancelSearch() {
          this.context.buffer = this.savedBuffer;
          this.context.cursorIndex = this.savedBuffer.length;
        }

        updateDisplay() {
          const searchPrompt = `(reverse-i-search)\`${this.query}': `;
          let displayText = "";
          if (this.index >= 0) {
            displayText = this.context.history[this.index];
          }
          this.context.term.write(`\r\x1b[K${searchPrompt}${displayText}`);
        }
      }

      // ============================================================================
      // HISTORY
      // ============================================================================
      class HistoryManager {
        constructor() {
          this.history = [];
          this.loadFromStorage();
        }

        add(command) {
          const trimmed = command.trimEnd();
          if (!trimmed) return;

          const last = this.history[this.history.length - 1];
          if (last !== trimmed) {
            this.history.push(trimmed);
            this.saveToStorage();
          }
        }

        get(index) {
          return this.history[index];
        }

        get length() {
          return this.history.length;
        }

        search(query, startIndex = -1) {
          if (startIndex === -1) {
            startIndex = this.history.length - 1;
          }
          for (let i = startIndex; i >= 0; i--) {
            if (this.history[i].includes(query)) {
              return i;
            }
          }
          return -1;
        }

        loadFromStorage() {
          try {
            const saved = localStorage.getItem("0_commands");
            if (saved) {
              const parsed = JSON.parse(saved);
              if (Array.isArray(parsed)) {
                this.history = parsed;
              }
            }
          } catch (e) {
            console.error("Failed to load history from localStorage:", e);
          }
        }

        saveToStorage() {
          try {
            localStorage.setItem("0_commands", JSON.stringify(this.history));
          } catch (e) {
            console.error("Failed to save history to localStorage:", e);
          }
        }
      }

      // ============================================================================
      // FACTORY - Terminal creation
      // ============================================================================
      class TerminalFactory {
        static createXTermConfig() {
          return {
            cursorBlink: true,
            cursorStyle: "block",
            convertEol: true,
            scrollback: 2_000,
            fontSize: 18,
            lineHeight: 1.4,
            fontFamily: "monospace",
            theme: {
              background: "#000000",
              foreground: "rgba(255, 255, 255, 0.8)",
              cursor: "rgba(255, 255, 255, 0.8)",
              selection: "#404040",
              error: "#ff0000",
            },
          };
        }

        static createTerminal(element) {
          const fitAddon = new FitAddon.FitAddon();
          const config = this.createXTermConfig();
          const term = new Terminal(config);

          term.open(element);
          term.loadAddon(fitAddon);
          fitAddon.fit();
          term.focus();

          // Handle window resize
          window.addEventListener("resize", () => {
            setTimeout(() => fitAddon.fit(), 50);
          });

          // Re-fit after page load
          window.addEventListener("load", () => {
            setTimeout(() => fitAddon.fit(), 100);
          });

          return term;
        }
      }

      // ============================================================================
      // PyodideConsole - Main console class
      // ============================================================================
      class PyodideConsole {
        constructor(term, pyodide, pyconsole, awaitFut, reprShorten) {
          this.term = term;
          this.pyodide = pyodide;
          this.pyconsole = pyconsole;
          this.awaitFut = awaitFut;
          this.reprShorten = reprShorten;

          this.PS1 = ">>> ";
          this.PS2 = "... ";

          this.buffer = "";
          this.cursorIndex = 0;
          this.prompt = this.PS1;
          this.historyIndex = null;

          this.historyManager = new HistoryManager();

          this.states = {
            normal: new NormalInputState(this),
            reverseSearch: new ReverseSearchState(this),
          };
          this.state = this.states.normal;

          this.pyconsole.stdout_callback = (s) => this.term.write(s);
          this.pyconsole.stderr_callback = (s) =>
            this.term.write(`\x1b[31m${s}\x1b[0m`);

          this.term.write(this.prompt);
        }

        transitionTo(stateName) {
          this.state.exit();
          this.state = this.states[stateName];
          this.state.enter();
        }

        async handleInput(data) {
          await this.state.handleInput(data);
        }

        insertText(text) {
          const before = this.buffer.slice(0, this.cursorIndex);
          const after = this.buffer.slice(this.cursorIndex);
          this.buffer = before + text + after;
          this.cursorIndex += text.length;
          this.refreshLine();
        }

        deleteChar() {
          if (this.cursorIndex > 0) {
            const before = this.buffer.slice(0, this.cursorIndex - 1);
            const after = this.buffer.slice(this.cursorIndex);
            this.buffer = before + after;
            this.cursorIndex -= 1;
            this.refreshLine();
          }
        }

        moveCursor(direction) {
          this.cursorIndex = Math.max(
            0,
            Math.min(this.cursorIndex + direction, this.buffer.length)
          );
          this.refreshLine();
        }

        refreshLine() {
          const clearCommand = "\x1b[0K";
          const leftPart = this.prompt + this.buffer.slice(0, this.cursorIndex);
          const rightPart = this.buffer.slice(this.cursorIndex);
          this.term.write(
            `\x1b[0G${leftPart}\x1b[s${rightPart}${clearCommand}\x1b[u`
          );
        }

        // History management
        navigateHistory(direction) {
          if (this.prompt === this.PS1) {
            if (this.historyIndex === null) {
              this.historyIndex = this.historyManager.length;
            }

            const newIndex = this.historyIndex + direction;
            if (newIndex >= 0 && newIndex < this.historyManager.length) {
              this.historyIndex = newIndex;
              this.buffer = this.historyManager.get(this.historyIndex) || "";
              this.cursorIndex = this.buffer.length;
              this.refreshLine();
            } else if (
              direction > 0 &&
              newIndex >= this.historyManager.length
            ) {
              this.historyIndex = null;
              this.buffer = "";
              this.cursorIndex = 0;
              this.refreshLine();
            }
          }
        }

        searchHistory(query, startIndex = -1) {
          return this.historyManager.search(query, startIndex);
        }

        get history() {
          return this.historyManager.history;
        }

        // Command execution
        async executeCommand() {
          const line = this.buffer.replace(/\u00a0/g, " ");

          if (line === "clear") {
            this.term.clear();
            return;
          }

          const fut = this.pyconsole.push(line);

          switch (fut.syntax_check) {
            case "syntax-error":
              this.term.write(
                `\x1b[31m${fut.formatted_error.trimEnd()}\x1b[0m`
              );
              this.term.write("\r\n");
              this.prompt = this.PS1;
              this.historyManager.add(line);
              this.historyIndex = null;
              fut.destroy();
              break;

            case "incomplete":
              this.prompt = this.PS2;
              this.historyManager.add(line);
              this.historyIndex = null;
              return;

            case "complete":
              this.prompt = this.PS1;
              try {
                const wrapped = this.awaitFut(fut);
                const [value] = await wrapped;
                if (value !== undefined) {
                  const output = this.reprShorten.callKwargs(value, {
                    separator: "\n<long output truncated>\n",
                  });
                  this.term.write(output);
                  this.term.write("\r\n");
                }
                if (value instanceof this.pyodide.ffi.PyProxy) {
                  value.destroy();
                }
                wrapped.destroy();
              } catch (e) {
                const msg = fut.formatted_error || e.message;
                this.term.write(`\x1b[31m${String(msg).trimEnd()}\x1b[0m`);
                this.term.write("\r\n");
              } finally {
                fut.destroy();
              }
              this.historyManager.add(line);
              this.historyIndex = null;
              break;

            default:
              this.term.write(
                `\r\nUnexpected syntax_check value: ${fut.syntax_check}`
              );
          }
        }
      }

      // ============================================================================
      // INITIALIZATION
      // ============================================================================
      async function initializePyodide() {
        let indexURL = "{{ PYODIDE_BASE_URL }}";
        const urlParams = new URLSearchParams(window.location.search);
        const buildParam = urlParams.get("build");
        if (buildParam && ["full", "debug", "pyc"].includes(buildParam)) {
          indexURL = indexURL.replace("/full/", "/" + buildParam + "/");
        }

        const { loadPyodide } = await import(indexURL + "pyodide.mjs");
        const pyodide = await loadPyodide();
        globalThis.pyodide = pyodide;

        return pyodide;
      }

      // ============================================================================
      // MAIN
      // ============================================================================

      async function main() {
        const term = TerminalFactory.createTerminal(
          document.getElementById("terminal")
        );
        window.term = term;

        const pyodide = await initializePyodide();

        document.getElementById("loading").style.display = "none";

        const {
          repr_shorten,
          BANNER,
          PyodideConsole: PythonConsole,
        } = pyodide.pyimport("pyodide.console");

        term.writeln(
          `Welcome to the Pyodide ${pyodide.version} terminal emulator üêç\n${BANNER}`
        );

        const pyconsole = PythonConsole(pyodide.globals);

        const namespace = pyodide.globals.get("dict")();
        const awaitFut = pyodide.runPython(
          `
import builtins
from pyodide.ffi import to_js
async def await_fut(fut):
  res = await fut
  if res is not None:
      builtins._ = res
  return to_js([res], depth=1)
await_fut
        `,
          { globals: namespace }
        );
        namespace.destroy();

        // Handle fatal errors
        pyodide._api.on_fatal = async (e) => {
          if (e.name === "Exit") {
            term.write(`\x1b[31m${e}\x1b[0m\r\n`);
            term.write(
              "\x1b[31mPyodide exited and can no longer be used.\x1b[0m\r\n"
            );
          } else {
            term.write(
              "\x1b[31mPyodide has suffered a fatal error. Please report this to the Pyodide maintainers.\x1b[0m\r\n"
            );
            term.write("\x1b[31mThe cause of the fatal error was:\x1b[0m\r\n");
            term.write(`\x1b[31m${e.message || e}\x1b[0m\r\n`);
            term.write(
              "\x1b[31mLook in the browser console for more details.\x1b[0m\r\n"
            );
          }
        };

        const pyodideConsole = new PyodideConsole(
          term,
          pyodide,
          pyconsole,
          awaitFut,
          repr_shorten
        );
        window.pyodideConsole = pyodideConsole;

        term.onData(async (data) => {
          await pyodideConsole.handleInput(data);
        });

        // Extra features
        let idbkvPromise;
        async function getIDBKV() {
          if (!idbkvPromise) {
            idbkvPromise = await import(
              "https://unpkg.com/idb-keyval@5.0.2/dist/esm/index.js"
            );
          }
          return idbkvPromise;
        }

        async function mountDirectory(pyodideDirectory, directoryKey) {
          if (pyodide.FS.analyzePath(pyodideDirectory).exists) {
            return;
          }
          const { get, set } = await getIDBKV();
          const opts = { id: "mountdirid", mode: "readwrite" };
          let directoryHandle = await get(directoryKey);
          if (!directoryHandle) {
            directoryHandle = await showDirectoryPicker(opts);
            await set(directoryKey, directoryHandle);
          }
          const permissionStatus = await directoryHandle.requestPermission(
            opts
          );
          if (permissionStatus !== "granted") {
            throw new Error("readwrite access to directory not granted");
          }
          await pyodide.mountNativeFS(pyodideDirectory, directoryHandle);
        }
        globalThis.mountDirectory = mountDirectory;
      }

      window.console_ready = main();
    </script>
  </body>
</html>
