/**
 * This file handles stack switching for the C in-memory stack and for the
 * inaccessible wasm stack.
 */

/**
 * This file is processed with build_continuations.mjs and then #included into
 * continuations.c as the definition of continuations_init_js
 *
 * build_continuations resolves the wat imports by assembling wat and wraps it
 * in EM_JS.
 */
import wrap_syncifying_wasm from "./wrap_syncifying.wat";

/**
 * For each continuation, we need to save and restore the Python wasm VM's
 * global state. There are three components to this:
 * 1. The Python threadState. This information includes the Python frame, the
 *    recursion_depth, etc. This is highly sensitive to the Python version. See
 *    threadstate.c.
 * 2. The "true wasm stack" / call stack state. This state we can't access and
 *    is magically handled by the JS VM if it supports JS Promise Integration
 *    and we ask nicely. This is contained in suspender.
 * 3. The "argument stack" / "addressable stack". This is a stack in linear
 *    memory. The compiler spills variables to this stack if someone takes a
 *    pointer to the variable because it is impossible to take a pointer to data
 *    on the true call stack.
 */

/**
 * Record the current Python thread state and the wasm call stack and argument
 * stack state. This is called by the hiwire_syncify wasm module just prior to
 * suspending the thread. `hiwire_syncify` uses `externref` for the return value
 * so we don't need to wrap this in a hiwire ID.
 */
function save_state() {
  const stackState = new StackState();
  return {
    threadState: Module._captureThreadState(),
    stackState,
    suspender: Module.suspenderGlobal.value,
  };
}

/**
 * Restore the Python thread state and the wasm argument stack state. This is
 * called by the hiwire_syncify wasm module upon resuming the thread. The
 * argument is the return value from save_state.
 */
function restore_state(state) {
  state.stackState.restore();
  Module._restoreThreadState(state.threadState);
  Module.suspenderGlobal.value = state.suspender;
  Module.validSuspender.value = true;
}

/*
 * Stack layout for a continuation (diagram stolen from greenlet).
 *
 *               |     ^^^       |
 *               |  older data   |
 *               |               |
 *  stack_stop . |_______________|
 *        .      |               |
 *        .      |     data      |
 *        .      |   in stack    |
 *        .    * |_______________| . .  _____________  stack_start + _copy.length
 *        .      |               |     |             |
 *        .      |     data      |     |  data saved |
 *        .      |   for next    |     |  in _copy   |
 *               | continuation  |     |             |
 * stack_start . |               | . . |_____________| stack_start
 *               |               |
 *               |  newer data   |
 *               |     vvv       |
 *
 * Each continuation has some part (possibly none) of its argument stack data
 * at the correct place on the actual stack and some part (possibly none) that
 * has been evicted to _copy by some other continuation that needed the space.
 */

/**
 * This is a list of continuations that have some of their state in the actual
 * argument stack. We need to keep track of them because restore() may need to
 * evict them from the stack in which case it will have to save their data.
 *
 * Invariants:
 * 1. This list contains a StackState for every continuation that at least
 *    partially on the argument stack except the currently executing one.
 *    (save_state will add the currently executing one to this list when it
 *    suspends.)
 * 2. The entries are sorted. Earlier entries occupy space further up on the
 *    stack, later entries occupy space lower down on the stack.
 * @private
 */
const stackStates = [];

/**
 * A class to help us keep track of the argument stack data for our individual
 * continuations. The suspender automatically and opaquely handles the call
 * stack for us, but the argument stack is an abstraction generated by the
 * compiler and we have to manage it ourselves.
 *
 * We only expose `restore` which ensures that the arg stack data is restored to
 * its proper location and the stack pointer and stackStop are in the correct
 * place. `restore` handles saving the data from other continuations that are
 * evicted.
 * @private
 */
class StackState {
  constructor() {
    /** current stack pointer */
    this.start = Module.___stack_pointer.value;
    /**
     * The value the stack pointer had when we entered Python. This is how far
     * up the stack the current continuation cares about. This was recorded just
     * before we entered Python in callPyObjectKwargsSuspending.
     */
    this.stop = Module.stackStop;
    /**
     * Where we store the data if it gets ejected from the actual argument
     * stack.
     */
    this._copy = new Uint8Array(0);
    if (this.start !== this.stop) {
      // Edge case that probably never happens: If start and stop are equal, the
      // current continuation occupies no arg stack space.
      stackStates.push(this);
    }
  }

  /**
   * Restore the argument stack in preparation to run the continuation.
   * @returns How much data we copied. (Only for debugging purposes.)
   */
  restore() {
    let total = 0;
    // Search up the stack for things that need to be ejected in their entirety
    // and save them
    while (
      stackStates.length > 0 &&
      stackStates[stackStates.length - 1].stop < this.stop
    ) {
      total += stackStates.pop()._save();
    }
    // Part of one more object may need to be ejected.
    const last = stackStates[stackStates.length - 1];
    if (last && last !== this) {
      total += last._save_up_to(this.stop);
    }
    // If we just saved all of the last stackState it needs to be removed.
    // Alternatively, the current StackState may be on the stackStates list.
    // Technically it would make sense to leave it there, but we will add it
    // back if we suspend again and if we exit normally it gets removed from the
    // stack.
    if (last && last.stop === this.stop) {
      stackStates.pop();
    }
    if (this._copy.length !== 0) {
      // Now that we've saved everything that might be in our way we can restore
      // the current stack data if need be.
      Module.HEAP8.set(this._copy, this.start);
      total += this._copy.length;
      this._copy = new Uint8Array(0);
    }
    // Restore stack pointers
    Module.stackStop = this.stop;
    Module.___stack_pointer.value = this.start;
    return total;
  }

  /**
   * Copy part of a stack frame into the _copy Uint8Array
   * @param {number} stop What part of the frame to copy
   * @returns How much data we copied (for debugging only)
   */
  _save_up_to(stop) {
    let sz1 = this._copy.length;
    let sz2 = stop - this.start;
    if (sz2 <= sz1) {
      return 0;
    }
    const new_segment = HEAP8.subarray(this.start + sz1, this.start + sz2);
    const c = new Uint8Array(sz2);
    c.set(this._copy);
    c.set(new_segment, sz1);
    this._copy = c;
    return sz2;
  }

  /**
   * Copy all of a stack frame into its _copy Uint8Array
   * @returns How much data we copied (for debugging only)
   */
  _save() {
    return this._save_up_to(this.stop);
  }
}

// prettier-ignore
const WASM_PRELUDE = [
  0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
  0x01, 0x00, 0x00, 0x00, // version: 1
];

function insertSectionPrefix(sectionCode, sectionBody) {
  var section = [sectionCode];
  uleb128Encode(sectionBody.length, section); // length of section in bytes
  section.push(...sectionBody);
  return section;
}

const typeCodes = {
  i32: 0x7f,
  i64: 0x7e,
  f32: 0x7d,
  f64: 0x7c,
  externref: 0x6f,
};

const constCodes = {
  i32: 0x41,
  i64: 0x42,
  f32: 0x43,
  f64: 0x44,
};

function generateType({ parameters, results }, target) {
  target.push(0x60 /* form: func */);
  uleb128Encode(parameters.length, target);
  for (let p of parameters) {
    target.push(typeCodes[p]);
  }
  uleb128Encode(results.length, target);
  for (let p of results) {
    target.push(typeCodes[p]);
  }
}

function emscriptenSigToWasm(sig) {
  const lookup = {
    i: "i32",
    j: "i64",
    f: "f32",
    d: "f64",
    e: "externref",
    v: "",
  };
  const parameters = sig.split("").map((x) => lookup[x]);
  const result = parameters.shift();
  const results = result ? [result] : [];
  return { parameters, results };
}

// prettier-ignore
function createInvokeModule(sig) {
  const sections = [WASM_PRELUDE];
  const typeSection = [
    0x07, // number of types
  ];
  const invoke_sig = emscriptenSigToWasm(sig);
  const export_sig = structuredClone(invoke_sig);
  export_sig.parameters.unshift("i32");
  const try_sig = structuredClone(invoke_sig);
  try_sig.parameters = [];
  const tag_sig = emscriptenSigToWasm("ve");
  const save_sig = emscriptenSigToWasm("i");
  const restore_sig = emscriptenSigToWasm("vi");
  const setThrew_sig = emscriptenSigToWasm("vii");
  generateType(invoke_sig, typeSection);
  const invoke_type = 0x00;
  generateType(export_sig, typeSection);
  const export_type = 0x01;
  generateType(tag_sig, typeSection);
  const tag_type = 0x02;
  generateType(save_sig, typeSection);
  const save_type = 0x03;
  generateType(restore_sig, typeSection);
  const restore_type = 0x04;
  generateType(setThrew_sig, typeSection);
  const setThrew_type = 0x05;
  generateType(try_sig, typeSection);
  const try_type = 0x06;
  sections.push(insertSectionPrefix(0x01, typeSection));

  // (import "e" "t" (table $t 0 funcref))
  // (import "e" "s" (func $save (result i32)))
  // (import "e" "r" (func $restore (param i32)))
  // (import "e" "tag" (tag $tag (param externref)))

  const descr_func = 0x00;
  const descr_table = 0x01;
  const descr_tag = 0x04;
  const importSection = [
    0x05, // number of imports

    0x01, 0x65, // module "e"
    0x01, 0x74, // field "t"
    descr_table, 0x70, 0x00, 0x00, // table of funcref, no max, min of 0

    0x01, 0x65, // module "e"
    0x03, 0x74, 0x61, 0x67, // field "tag"
    descr_tag, 0x00, tag_type,

    0x01, 0x65, // module "e"
    0x01, 0x73, // field "s"
    descr_func, save_type,

    0x01, 0x65, // module "e"
    0x01, 0x72, // field "r"
    descr_func, restore_type,
    0x01, 0x65, // module "e"
    0x01, 0x71, // field "q"
    descr_func, setThrew_type,
  ];
  sections.push(insertSectionPrefix(0x02, importSection));
  const functionSection = [
    0x01, // number of functions = 1
    export_type,
  ];
  sections.push(insertSectionPrefix(0x03, functionSection));
  const exportSection = [
    0x01, // One export
    0x01,
    0x6f, // name "o"
    0x00, // type: function
    0x03, // function index 2 (after the three function imports)
  ];
  sections.push(insertSectionPrefix(0x07, exportSection));

  const code = [];
  code.push(
    0x01, // One run
    0x01, // of length 1
    typeCodes.i32, // of i32
  );
  const stateLocal = export_sig.parameters.length;

  code.push(0x10, 0x00); // call save
  code.push(0x21, stateLocal); // local.set stateLocal

  code.push(0x06, try_type); // try
  for(let i = 1; i < export_sig.parameters.length; i++) {
    code.push(0x20, i); // local.get i
  }
  code.push(0x20, 0); // local.get 0

  code.push(0x11, 0x00, 0x00); // call_indirect invoke type
  code.push(0x07, 0x00); // catch $tag
  code.push(0x1a); // drop the caught externref
  code.push(0x20, stateLocal); // local.get stateLocal
  code.push(0x10, 0x01); // call restore

  code.push(constCodes.i32, 0x01);
  code.push(constCodes.i32, 0x00);
  code.push(0x10, 0x02); // call setThrew
  const val = {
    i32 : [0],
    i64 : [0],
    f32 : [0,0,0,0],
    f64 : [0,0,0,0,0,0,0,0],
  };
  for(let x of export_sig.results) {
    code.push(constCodes[x], ...val[x]);
  }
  code.push(0x0b); // end
  code.push(0x0b); // end
  const codeSection = insertSectionPrefix(0x01 /* number of codes */, code);
  sections.push(insertSectionPrefix(0x0a, codeSection));

  const bytes = new Uint8Array([].concat.apply([], sections));
  // const fs = require("fs");
  // fs.writeFileSync("gen.wasm", bytes);
  // We can compile this wasm module synchronously because it is small.
  const module = new WebAssembly.Module(bytes);
  return module;
}

let jsWrapperTag;
try {
  jsWrapperTag = new WebAssembly.Tag({ parameters: ["externref"] });
  Module.jsWrapperTag = jsWrapperTag;
} catch (e) {}

if (jsWrapperTag) {
  Module.wrapException = (e) => new WebAssembly.Exception(jsWrapperTag, [e]);
}

function createInvoke(sig) {
  const module = createInvokeModule(sig);
  const instance = new WebAssembly.Instance(module, {
    e: {
      t: wasmTable,
      s: () => stackSave(),
      r: (x) => stackRestore(x),
      q: (x, y) => _setThrew(x, y),
      tag: jsWrapperTag,
    },
  });
  return instance.exports["o"];
}

Module.adjustWasmImports = function (wasmImports) {
  wasmImports.__indirect_function_table = wasmTable;
  if (jsWrapperTag) {
    const i = "invoke_";
    for (let name of Object.keys(wasmImports)) {
      if (!name.startsWith(i)) {
        continue;
      }
      wasmImports[name] = createInvoke(name.slice(i.length));
    }
  }
};

/**
 * Module.syncifyHandler does all of the work of hiwire_syncify (defined in
 * hiwire).
 */
function setSyncifyHandler() {
  const suspending_f = new WebAssembly.Function(
    { parameters: ["externref", "i32"], results: ["i32"] },
    async (x) => {
      try {
        return Hiwire.new_value(await Hiwire.get_value(x));
      } catch (e) {
        if (e && e.pyodide_fatal_error) {
          throw e;
        }
        // Error handling is tricky here. We want to set the error flag after
        // unswitching the stack. Just store the error for the moment.
        Module.syncify_error = e;
      }
    },
    { suspending: "first" },
  );
  // This module checks validSuspender, if there is no validSuspender returns 0
  // for error. Otherwise, it calls save_state, stores the result into an
  // externef, calls suspending_f with suspenderGlobal and the original argument
  // then it calls restore_state with the saved state and returns the result.
  // See wrap_syncifying.wat
  const module = new WebAssembly.Module(new Uint8Array(wrap_syncifying_wasm));
  const instance = new WebAssembly.Instance(module, {
    e: {
      s: Module.suspenderGlobal,
      i: suspending_f,
      c: Module.validSuspender,
      save: save_state,
      restore: restore_state,
    },
  });
  HEAP32[_syncifyHandler / 4] = addFunction(instance.exports.o);
}

Module.suspendableApply = function (...args) {
  // validSuspender is a flag so that we can ask for permission before trying
  // to suspend. We can't ask for forgiveness because our normal technique for
  // this is to insert a JavaScript frame where we can catch the error
  // generated. We cannot suspend through JavaScript frames (this limitation
  // is part of the intentional design of Wasm Promise Integration).
  Module.validSuspender.value = true;
  // Record the current stack position. See StackState in continuations.js
  Module.stackStop = Module.___stack_pointer.value;
  return Module.suspendableApplyHandler(...args);
};

// for using wasm types as map keys
function wasmTypeToString(ty) {
  return `params:${ty.parameters};results:${ty.results}`;
}

const selectorModuleMap = new Map();
// prettier-ignore
function createSelectorModule(async_type) {
  const async_type_str = wasmTypeToString(async_type);
  if (selectorModuleMap.has(async_type_str)) {
    return selectorModuleMap.get(async_type_str);
  }
  const sections = [WASM_PRELUDE];
  const typeSection = [
    0x02, // number of types = 2
  ];
  const sync_type = structuredClone(async_type);
  sync_type.parameters.shift();
  generateType(async_type, typeSection);
  generateType(sync_type, typeSection);
  sections.push(insertSectionPrefix(0x01, typeSection));

  const importSection = [
    0x04, // number of imports

    0x01, 0x65, // module "e"
    0x01, 0x63, // field "c"
    0x03, 0x7F, 0x01, // global i32 mutable

    0x01, 0x65, // module "e"
    0x01, 0x73, // field "s"
    0x03, 0x6F, 0x01, // global externref mutable

    0x01, 0x65, // module "e"
    0x01, 0x66, // field "f"
    0x00, 0x01, // function of type "sync_type"

    0x01, 0x65, // module "e"
    0x01, 0x61, // field "a"
    0x00, 0x00, // function of type "async_type"
  ];
  sections.push(insertSectionPrefix(0x02, importSection));
  const functionSection = [
    0x01, // number of functions = 1
    0x01, // type 1
  ];
  sections.push(insertSectionPrefix(0x03, functionSection));
  const exportSection = [
    0x01, // One export
    0x01, 0x6f, // name "o"
    0x00, // type: function
    0x02, // function index 1
  ];
  sections.push(insertSectionPrefix(0x07, exportSection));

  const code = [];
  code.push(
    0x01, // One run
    0x01, // of length 1
    0x6f, // of exterref
  );
  const suspenderLocal = sync_type.parameters.length;
  code.push(0x23, 0);    // global.get 0 <e.c> validSuspender
  code.push(0x45);       // i32.eqz
  code.push(0x04, 0x40); // if
  for (let i = 0; i < sync_type.parameters.length; i++) {
    code.push(0x20, i);  // local.get i
  }
  code.push(0x10, 0x00); // call "e.f" sync_fn
  code.push(0x0f);       // return
  code.push(0x0b);       // end if

  code.push(0x23, 1);    // global.get 0 <e.s> suspenderGlobal
  code.push(0x22, suspenderLocal); // local.tee suspender
  for (let i = 0; i < sync_type.parameters.length; i++) {
    code.push(0x20, i); // local.get i
  }
  code.push(0x10, 0x01); // call "e.a" async_fn
  code.push(0x20, suspenderLocal); // local.get suspender
  code.push(0x24, 1); // global.set 1
  code.push(0x0b); // end
  const codeSection = insertSectionPrefix(0x01 /* number of codes */, code);
  sections.push(insertSectionPrefix(0x0a, codeSection));

  const bytes = new Uint8Array([].concat.apply([], sections));
  // We can compile this wasm module synchronously because it is small.
  const module = new WebAssembly.Module(bytes);
  selectorModuleMap.set(async_type_str, module);
  return module;
}

function createSelector(sync_fn, async_wrapper) {
  const async_type = WebAssembly.Function.type(async_wrapper);
  const module = createSelectorModule(async_type);
  const instance = new WebAssembly.Instance(module, {
    e: {
      a: async_wrapper,
      f: sync_fn,
      s: Module.suspenderGlobal,
      c: Module.validSuspender,
    },
  });
  return instance.exports["o"];
}
Module.createSelector = createSelector;

const promisingModuleMap = new Map();
// prettier-ignore
function getPromisingModule(orig_type) {
  const type_str = wasmTypeToString(orig_type);
  if (promisingModuleMap.has(type_str)) {
    return promisingModuleMap.get(type_str);
  }
  const sections = [WASM_PRELUDE];
  const typeSection = [
    0x02, // number of types = 2
  ];
  const wrapped_type = structuredClone(orig_type);
  wrapped_type.parameters.unshift("externref");
  generateType(orig_type, typeSection);
  generateType(wrapped_type, typeSection);
  sections.push(insertSectionPrefix(0x01, typeSection));

  const importSection = [
    0x02, // number of imports
    // Import the wasmTable, which we will call "t"
    0x01, 0x65, // module "e"
    0x01, 0x73, // field "s"
    0x03, 0x6F, 0x01, // global externref mutable
    0x01, 0x65, // module "e"
    0x01, 0x69, // field "i"
    0x00, 0x00, // function of type "type"
  ];
  sections.push(insertSectionPrefix(0x02, importSection));
  const functionSection = [
    0x01, // number of functions = 1
    0x01, // type 1
  ];
  sections.push(insertSectionPrefix(0x03, functionSection));
  const exportSection = [
    0x01, // One export
    0x01, 0x6f, // name "o"
    0x00, // type: function
    0x01, // the function we define
  ];
  sections.push(insertSectionPrefix(0x07, exportSection));

  const code = [];
  code.push(0); // no locals
  code.push(0x20, 0); // local.get 0
  code.push(0x24, 0); // global.set 0
  for (let i = 1; i < wrapped_type.parameters.length; i++) {
    code.push(0x20, i); // local.get i
  }
  code.push(0x10, 0x00); // call "e.i"
  code.push(0x0b); // end
  const codeSection = insertSectionPrefix(0x01 /* number of codes */, code);
  sections.push(insertSectionPrefix(0x0a, codeSection));

  const bytes = new Uint8Array([].concat.apply([], sections));
  // We can compile this wasm module synchronously because it is small.
  const module = new WebAssembly.Module(bytes);
  promisingModuleMap.set(type_str, module);
  return module;
}

const promisingFunctionMap = new WeakMap();
function createPromising(wasm_func) {
  if (promisingFunctionMap.has(wasm_func)) {
    return promisingFunctionMap.get(wasm_func);
  }
  const type = WebAssembly.Function.type(wasm_func);
  const module = getPromisingModule(type);
  const instance = new WebAssembly.Instance(module, {
    e: { i: wasm_func, s: Module.suspenderGlobal },
  });
  const result = new WebAssembly.Function(
    { parameters: type.parameters, results: ["externref"] },
    instance.exports.o,
    { promising: "first" },
  );
  promisingFunctionMap.set(wasm_func, result);
  return result;
}
Module.createPromising = createPromising;

function syncHandler(genfunc, ...args) {
  let gen = genfunc(...args);
  let [fptr, call_args] = gen.next().value;
  return gen.next(getWasmTableEntry(fptr)(...call_args)).value;
}

async function promisingHandler(genfunc, ...args) {
  let gen = genfunc(...args);
  let [fptr, call_args] = gen.next().value;
  return gen.next(await createPromising(getWasmTableEntry(fptr))(...call_args))
    .value;
}

function getHandlerFn(trampoline, sig) {
  const sync_fn = syncHandler.bind(null, trampoline);
  if (Module.suspendersAvailable) {
    const wasmsig = emscriptenSigToWasm(sig);
    wasmsig.parameters.unshift("externref");
    const async_wrapper = new WebAssembly.Function(
      wasmsig,
      promisingHandler.bind(null, trampoline),
      { suspending: "first" },
    );
    return createSelector(sync_fn, async_wrapper);
  } else {
    return convertJsFunctionToWasm(sync_fn, sig);
  }
}
Module.getHandlerFn = getHandlerFn;

function setPythonTrampoline() {
  function* trampoline_generator(func, self, args, kw) {
    return yield [func, [self, args, kw]];
  }
  const handler = getHandlerFn(trampoline_generator, "iiiii");
  Module.HEAP32[Module._py_trampoline / 4] = addFunction(handler);
}

/**
 * This sets up syncify to work.
 *
 * We need to make:
 *
 * - suspenderGlobal where we store the suspender object
 *
 * - applyHandler which creates a suspender and stores it into suspenderGlobal
 *   then makes an onward call (used by callKwargsSyncifying)
 *
 * - the syncifyHandler which uses suspenderGlobal to suspend execution, then
 *   awaits a promise, then resumes execution and returns the promise result
 *   (used by hiwire_syncify)
 *
 * If the creation of these fails because JSPI is missing, then we set it up so
 * that callKwargsSyncifying and hiwire_syncify will always raise errors and
 * everything else can work as normal. In the short term, we'll almost always
 * end
 */
function initSuspenders() {
  try {
    Module.suspenderGlobal = new WebAssembly.Global(
      { value: "externref", mutable: true },
      null,
    );
    Module.suspendableApplyHandler = createPromising(Module.asm._pyproxy_apply);
    Module.suspendersAvailable = true;
  } catch (e) {
    Module.suspendersAvailable = false;
  }
  if (Module.suspendersAvailable) {
    Module.validSuspender = new WebAssembly.Global(
      { value: "i32", mutable: true },
      0,
    );
    setSyncifyHandler();
    setPythonTrampoline();
  } else {
    // Browser doesn't support JSPI.
    Module.validSuspender = { value: 0 };
    Module.suspendersAvailable = false;
    Module.syncifyHandler = function () {
      Module.handle_js_error(Error("Syncify not supported"));
      return 0;
    };
  }
}
